------- FILE spacetaxi.bas.asm LEVEL 1 PASS 2
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE spacetaxi.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE spacetaxi.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 05	   font       =	retroputer
      5  9000 ????
      6  9000 ????	       00 01	   pfscore    =	1
      7  9000 ????
      8  9000 ????	       00 9f	   _M_Edge_Right =	159
      9  9000 ????
     10  9000 ????	       00 02	   _M_Edge_Left =	2
     11  9000 ????
     12  9000 ????	       00 58	   _M_Edge_Bottom =	88
     13  9000 ????
     14  9000 ????	       00 02	   _M_Edge_Top =	2
     15  9000 ????
     16  9000 ????	       00 98	   _P_Edge_Right =	152
     17  9000 ????
     18  9000 ????	       00 01	   _P_Edge_Left =	1
     19  9000 ????
     20  9000 ????	       00 58	   _P_Edge_Bottom =	88
     21  9000 ????
     22  9000 ????	       00 09	   _P_Edge_Top =	9
     23  9000 ????
     24  9000 ????	       00 95	   _sc3       =	score + 2
     25  9000 ????
     26  9000 ????	       00 94	   _sc2       =	score + 1
     27  9000 ????
     28  9000 ????	       00 93	   _sc1       =	score
     29  9000 ????
     30  9000 ????	       00 ed	   rand16     =	z
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit7_M1_Moving =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit6_Swap_Scores =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit3_Auto_Play =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _Bit2_Game_Control =	y
     39  9000 ????
     40  9000 ????	       00 ec	   _Bit1_FireB_Restrainer =	y
     41  9000 ????
     42  9000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     43  9000 ????
     44  9000 ????	       00 ec	   _BitOp_01  =	y
     45  9000 ????
     46  9000 ????	       00 eb	   _High_Score3 =	x
     47  9000 ????
     48  9000 ????	       00 ea	   _High_Score2 =	w
     49  9000 ????
     50  9000 ????	       00 e9	   _High_Score1 =	v
     51  9000 ????
     52  9000 ????	       00 e8	   _Destination_Pad_Num =	u
     53  9000 ????
     54  9000 ????	       00 e7	   _Remaining_Fare =	t
     55  9000 ????
     56  9000 ????	       00 e6	   _Number_Of_Lives =	s
     57  9000 ????
     58  9000 ????	       00 e4	   _Player_Acceleration_Y =	q
     59  9000 ????
     60  9000 ????	       00 e3	   _Player_Acceleration_X =	p
     61  9000 ????
     62  9000 ????	       00 e2	   _Player_Direction_Y =	o
     63  9000 ????
     64  9000 ????	       00 e1	   _Player_Direction_X =	n
     65  9000 ????
     66  9000 ????	       00 e8	   _Score3_Mem =	u
     67  9000 ????
     68  9000 ????	       00 e7	   _Score2_Mem =	t
     69  9000 ????
     70  9000 ????	       00 e6	   _Score1_Mem =	s
     71  9000 ????
     72  9000 ????	       00 e5	   _Bit2_Pause_Clr_Scheme =	r
     73  9000 ????
     74  9000 ????	       00 e5	   _Bit1_BW_Check =	r
     75  9000 ????
     76  9000 ????	       00 e5	   _Bit0_BW_Mem =	r
     77  9000 ????
     78  9000 ????	       00 e5	   _BitOp_02  =	r
     79  9000 ????
     80  9000 ????	       00 df	   _Pause_Color_Tmp =	l
     81  9000 ????
     82  9000 ????	       00 df	   _AP_Dir_Counter =	l
     83  9000 ????
     84  9000 ????	       00 de	   _Pause_Mem_Color_Tmp =	k
     85  9000 ????
     86  9000 ????	       00 de	   _AP_2_Sec_Score_Flip =	k
     87  9000 ????
     88  9000 ????	       00 dd	   _AP_Mem_P0y =	j
     89  9000 ????
     90  9000 ????	       00 dc	   _AP_Mem_P0x =	i
     91  9000 ????
     92  9000 ????	       00 db	   _Pause_Counter_Tmp =	h
     93  9000 ????
     94  9000 ????	       00 db	   _AP_Mem_Dir =	h
     95  9000 ????
     96  9000 ????	       00 a0	   _T5_AP_Dir =	temp5
     97  9000 ????
     98  9000 ????	       00 da	   _Bit7_M1_Dir_Right =	g
     99  9000 ????
    100  9000 ????	       00 da	   _Bit6_M1_Dir_Left =	g
    101  9000 ????
    102  9000 ????	       00 da	   _Bit5_M1_Dir_Down =	g
    103  9000 ????
    104  9000 ????	       00 da	   _Bit4_M1_Dir_Up =	g
    105  9000 ????
    106  9000 ????	       00 da	   _Bit3_P0_Dir_Right =	g
    107  9000 ????
    108  9000 ????	       00 da	   _Bit2_P0_Dir_Left =	g
    109  9000 ????
    110  9000 ????	       00 da	   _Bit1_P0_Dir_Down =	g
    111  9000 ????
    112  9000 ????	       00 da	   _Bit0_P0_Dir_Up =	g
    113  9000 ????
    114  9000 ????	       00 da	   _BitOp_P0_M1_Dir =	g
    115  9000 ????
    116  9000 ????	       00 d9	   _Frame_Counter =	f
    117  9000 ????
    118  9000 ????	       00 d8	   _Master_Counter =	e
    119  9000 ????
    120  9000 ????	       00 07	   bs_mask    =	7
    121  9000 ????	       00 20	   bankswitch =	32
    122  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
    123  9000 ????	       00 01	   PFcolors   =	1
    124  9000 ????	       00 01	   no_blank_lines =	1
------- FILE 2600basic.h
      7  9000 ????
      8  9000 ????	       00 80	   player0x   =	$80
      9  9000 ????	       00 81	   player1x   =	$81
     10  9000 ????	       00 82	   missile0x  =	$82
     11  9000 ????	       00 83	   missile1x  =	$83
     12  9000 ????	       00 84	   ballx      =	$84
     13  9000 ????
     14  9000 ????	       00 85	   objecty    =	$85
     15  9000 ????	       00 85	   player0y   =	$85
     16  9000 ????	       00 86	   player1y   =	$86
     17  9000 ????	       00 87	   missile1height =	$87
     18  9000 ????	       00 88	   missile1y  =	$88
     19  9000 ????	       00 89	   bally      =	$89
     20  9000 ????
     21  9000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  9000 ????
     23  9000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  9000 ????	       00 8a	   player0pointerlo =	$8A
     25  9000 ????	       00 8b	   player0pointerhi =	$8B
     26  9000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  9000 ????	       00 8c	   player1pointerlo =	$8C
     28  9000 ????	       00 8d	   player1pointerhi =	$8D
     29  9000 ????
     30  9000 ????	       00 8e	   player0height =	$8E
     31  9000 ????	       00 8f	   player1height =	$8F
     32  9000 ????	       00 90	   missile0height =	$90
     33  9000 ????	       00 91	   missile0y  =	$91
     34  9000 ????	       00 92	   ballheight =	$92
     35  9000 ????
     36  9000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  9000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  9000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  9000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  9000 ????
     41  9000 ????	       00 93	   score      =	$93	; $93-$95
     42  9000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  9000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  9000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  9000 ????	       00 9e	   temp3      =	$9E
     46  9000 ????	       00 9f	   temp4      =	$9F
     47  9000 ????	       00 a0	   temp5      =	$A0
     48  9000 ????	       00 a1	   temp6      =	$A1
     49  9000 ????
     50  9000 ????	       00 a2	   rand       =	$A2
     51  9000 ????	       00 a3	   scorecolor =	$A3
     52  9000 ????
     53  9000 ????	       00 a4	   var0       =	$A4
     54  9000 ????	       00 a5	   var1       =	$A5
     55  9000 ????	       00 a6	   var2       =	$A6
     56  9000 ????	       00 a7	   var3       =	$A7
     57  9000 ????	       00 a8	   var4       =	$A8
     58  9000 ????	       00 a9	   var5       =	$A9
     59  9000 ????	       00 aa	   var6       =	$AA
     60  9000 ????	       00 ab	   var7       =	$AB
     61  9000 ????	       00 ac	   var8       =	$AC
     62  9000 ????	       00 ad	   var9       =	$AD
     63  9000 ????	       00 ae	   var10      =	$AE
     64  9000 ????	       00 af	   var11      =	$AF
     65  9000 ????	       00 b0	   var12      =	$B0
     66  9000 ????	       00 b1	   var13      =	$B1
     67  9000 ????	       00 b2	   var14      =	$B2
     68  9000 ????	       00 b3	   var15      =	$B3
     69  9000 ????	       00 b4	   var16      =	$B4
     70  9000 ????	       00 b5	   var17      =	$B5
     71  9000 ????	       00 b6	   var18      =	$B6
     72  9000 ????	       00 b7	   var19      =	$B7
     73  9000 ????	       00 b8	   var20      =	$B8
     74  9000 ????	       00 b9	   var21      =	$B9
     75  9000 ????	       00 ba	   var22      =	$BA
     76  9000 ????	       00 bb	   var23      =	$BB
     77  9000 ????	       00 bc	   var24      =	$BC
     78  9000 ????	       00 bd	   var25      =	$BD
     79  9000 ????	       00 be	   var26      =	$BE
     80  9000 ????	       00 bf	   var27      =	$BF
     81  9000 ????	       00 c0	   var28      =	$C0
     82  9000 ????	       00 c1	   var29      =	$C1
     83  9000 ????	       00 c2	   var30      =	$C2
     84  9000 ????	       00 c3	   var31      =	$C3
     85  9000 ????	       00 c4	   var32      =	$C4
     86  9000 ????	       00 c5	   var33      =	$C5
     87  9000 ????	       00 c6	   var34      =	$C6
     88  9000 ????	       00 c7	   var35      =	$C7
     89  9000 ????	       00 c8	   var36      =	$C8
     90  9000 ????	       00 c9	   var37      =	$C9
     91  9000 ????	       00 ca	   var38      =	$CA
     92  9000 ????	       00 cb	   var39      =	$CB
     93  9000 ????	       00 cc	   var40      =	$CC
     94  9000 ????	       00 cd	   var41      =	$CD
     95  9000 ????	       00 ce	   var42      =	$CE
     96  9000 ????	       00 cf	   var43      =	$CF
     97  9000 ????	       00 d0	   var44      =	$D0
     98  9000 ????	       00 d1	   var45      =	$D1
     99  9000 ????	       00 d2	   var46      =	$D2
    100  9000 ????	       00 d3	   var47      =	$D3
    101  9000 ????
    102  9000 ????	       00 d4	   A	      =	$d4
    103  9000 ????	       00 d4	   a	      =	$d4
    104  9000 ????	       00 d5	   B	      =	$d5
    105  9000 ????	       00 d5	   b	      =	$d5
    106  9000 ????	       00 d6	   C	      =	$d6
    107  9000 ????	       00 d6	   c	      =	$d6
    108  9000 ????	       00 d7	   D	      =	$d7
    109  9000 ????	       00 d7	   d	      =	$d7
    110  9000 ????	       00 d8	   E	      =	$d8
    111  9000 ????	       00 d8	   e	      =	$d8
    112  9000 ????	       00 d9	   F	      =	$d9
    113  9000 ????	       00 d9	   f	      =	$d9
    114  9000 ????	       00 da	   G	      =	$da
    115  9000 ????	       00 da	   g	      =	$da
    116  9000 ????	       00 db	   H	      =	$db
    117  9000 ????	       00 db	   h	      =	$db
    118  9000 ????	       00 dc	   I	      =	$dc
    119  9000 ????	       00 dc	   i	      =	$dc
    120  9000 ????	       00 dd	   J	      =	$dd
    121  9000 ????	       00 dd	   j	      =	$dd
    122  9000 ????	       00 de	   K	      =	$de
    123  9000 ????	       00 de	   k	      =	$de
    124  9000 ????	       00 df	   L	      =	$df
    125  9000 ????	       00 df	   l	      =	$df
    126  9000 ????	       00 e0	   M	      =	$e0
    127  9000 ????	       00 e0	   m	      =	$e0
    128  9000 ????	       00 e1	   N	      =	$e1
    129  9000 ????	       00 e1	   n	      =	$e1
    130  9000 ????	       00 e2	   O	      =	$e2
    131  9000 ????	       00 e2	   o	      =	$e2
    132  9000 ????	       00 e3	   P	      =	$e3
    133  9000 ????	       00 e3	   p	      =	$e3
    134  9000 ????	       00 e4	   Q	      =	$e4
    135  9000 ????	       00 e4	   q	      =	$e4
    136  9000 ????	       00 e5	   R	      =	$e5
    137  9000 ????	       00 e5	   r	      =	$e5
    138  9000 ????	       00 e6	   S	      =	$e6
    139  9000 ????	       00 e6	   s	      =	$e6
    140  9000 ????	       00 e7	   T	      =	$e7
    141  9000 ????	       00 e7	   t	      =	$e7
    142  9000 ????	       00 e8	   U	      =	$e8
    143  9000 ????	       00 e8	   u	      =	$e8
    144  9000 ????	       00 e9	   V	      =	$e9
    145  9000 ????	       00 e9	   v	      =	$e9
    146  9000 ????	       00 ea	   W	      =	$ea
    147  9000 ????	       00 ea	   w	      =	$ea
    148  9000 ????	       00 eb	   X	      =	$eb
    149  9000 ????	       00 eb	   x	      =	$eb
    150  9000 ????	       00 ec	   Y	      =	$ec
    151  9000 ????	       00 ec	   y	      =	$ec
    152  9000 ????	       00 ed	   Z	      =	$ed
    153  9000 ????	       00 ed	   z	      =	$ed
    154  9000 ????
    155  9000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  9000 ????	       00 ef	   playfieldpos =	$ef
    157  9000 ????
    158  9000 ????						; available for other uses, or if unused, provide more stack space
    159  9000 ????
    160  9000 ????	       00 f0	   aux1       =	$f0
    161  9000 ????	       00 f1	   aux2       =	$f1
    162  9000 ????	       00 f2	   aux3       =	$f2
    163  9000 ????	       00 f3	   aux4       =	$f3
    164  9000 ????	       00 f4	   aux5       =	$f4
    165  9000 ????	       00 f5	   aux6       =	$f5
    166  9000 ????
    167  9000 ????						; playfield color/height pointers
    168  9000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  9000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  9000 ????						; the above pointers are the same because if color and height are both used together,
    171  9000 ????						; they must used absolute indexed and cannot use pointers
    172  9000 ????
    173  9000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  9000 ????						; upper 3 bits of $f2 contain the number of lives
    175  9000 ????	       00 f4	   lifecolor  =	$f4
    176  9000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  9000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  9000 ????
    179  9000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  9000 ????	       00 f3	   pfscore2   =	$f3
    181  9000 ????	       00 f4	   pfscorecolor =	$f4
    182  9000 ????
    183  9000 ????	       00 f6	   stack1     =	$f6
    184  9000 ????	       00 f7	   stack2     =	$f7
    185  9000 ????	       00 f8	   stack3     =	$f8
    186  9000 ????	       00 f9	   stack4     =	$f9
    187  9000 ????						; the stack bytes above may be used in the kernel
    188  9000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  9000 ????
    190  9000 ????				      MAC	return
    191  9000 ????				      ifnconst	bankswitch
    192  9000 ????				      rts
    193  9000 ????				      else
    194  9000 ????				      jmp	BS_return
    195  9000 ????				      endif
    196  9000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  9000 ????
    198  9000 ????			  -	      ifconst	superchip
    199  9000 ????			  -playfieldbase =	$10D0
    200  9000 ????			  -	      include	superchip.h
    201  9000 ????				      else
    202  9000 ????	       00 a4	   playfieldbase =	$A4
    203  9000 ????				      endif
    204  9000 ????
    205  9000 ????				      ifnconst	pfhalfwidth
    206  9000 ????	       00 04	   pfwidth    =	4
    207  9000 ????	       00 0e	   PF1L       =	PF1
    208  9000 ????	       00 0f	   PF2L       =	PF2
    209  9000 ????	       00 0e	   PF1R       =	PF1
    210  9000 ????	       00 0f	   PF2R       =	PF2
    211  9000 ????	       00 00	   pfadjust   =	0
    212  9000 ????			  -	      else
    213  9000 ????			  -pfwidth    =	2
    214  9000 ????			  -	      ifconst	pfcenter
    215  9000 ????			  -PF1L       =	$3F	; no effect
    216  9000 ????			  -PF2L       =	PF2
    217  9000 ????			  -PF1R       =	$3F
    218  9000 ????			  -PF2R       =	PF2	; no effect
    219  9000 ????			  -pfadjust   =	1
    220  9000 ????			  -	      else
    221  9000 ????			  -PF1L       =	PF1
    222  9000 ????			  -PF2L       =	PF2
    223  9000 ????			  -PF1R       =	$3F	; no effect
    224  9000 ????			  -PF2R       =	$3F	; no effect
    225  9000 ????			  -pfadjust   =	0
    226  9000 ????			  -	      endif
    227  9000 ????				      endif
    228  9000 ????
    229  9000 ????						; define playfield start based on height
    230  9000 ????				      ifnconst	pfres
    231  9000 ????	       00 a4	   playfield  =	playfieldbase
    232  9000 ????			  -	      else
    233  9000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  9000 ????				      endif
------- FILE spacetaxi.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 05	   font       =	retroputer
      5  9000 ????
      6  9000 ????	       00 01	   pfscore    =	1
      7  9000 ????
      8  9000 ????	       00 9f	   _M_Edge_Right =	159
      9  9000 ????
     10  9000 ????	       00 02	   _M_Edge_Left =	2
     11  9000 ????
     12  9000 ????	       00 58	   _M_Edge_Bottom =	88
     13  9000 ????
     14  9000 ????	       00 02	   _M_Edge_Top =	2
     15  9000 ????
     16  9000 ????	       00 98	   _P_Edge_Right =	152
     17  9000 ????
     18  9000 ????	       00 01	   _P_Edge_Left =	1
     19  9000 ????
     20  9000 ????	       00 58	   _P_Edge_Bottom =	88
     21  9000 ????
     22  9000 ????	       00 09	   _P_Edge_Top =	9
     23  9000 ????
     24  9000 ????	       00 95	   _sc3       =	score + 2
     25  9000 ????
     26  9000 ????	       00 94	   _sc2       =	score + 1
     27  9000 ????
     28  9000 ????	       00 93	   _sc1       =	score
     29  9000 ????
     30  9000 ????	       00 ed	   rand16     =	z
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit7_M1_Moving =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit6_Swap_Scores =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit3_Auto_Play =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _Bit2_Game_Control =	y
     39  9000 ????
     40  9000 ????	       00 ec	   _Bit1_FireB_Restrainer =	y
     41  9000 ????
     42  9000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     43  9000 ????
     44  9000 ????	       00 ec	   _BitOp_01  =	y
     45  9000 ????
     46  9000 ????	       00 eb	   _High_Score3 =	x
     47  9000 ????
     48  9000 ????	       00 ea	   _High_Score2 =	w
     49  9000 ????
     50  9000 ????	       00 e9	   _High_Score1 =	v
     51  9000 ????
     52  9000 ????	       00 e8	   _Destination_Pad_Num =	u
     53  9000 ????
     54  9000 ????	       00 e7	   _Remaining_Fare =	t
     55  9000 ????
     56  9000 ????	       00 e6	   _Number_Of_Lives =	s
     57  9000 ????
     58  9000 ????	       00 e4	   _Player_Acceleration_Y =	q
     59  9000 ????
     60  9000 ????	       00 e3	   _Player_Acceleration_X =	p
     61  9000 ????
     62  9000 ????	       00 e2	   _Player_Direction_Y =	o
     63  9000 ????
     64  9000 ????	       00 e1	   _Player_Direction_X =	n
     65  9000 ????
     66  9000 ????	       00 e8	   _Score3_Mem =	u
     67  9000 ????
     68  9000 ????	       00 e7	   _Score2_Mem =	t
     69  9000 ????
     70  9000 ????	       00 e6	   _Score1_Mem =	s
     71  9000 ????
     72  9000 ????	       00 e5	   _Bit2_Pause_Clr_Scheme =	r
     73  9000 ????
     74  9000 ????	       00 e5	   _Bit1_BW_Check =	r
     75  9000 ????
     76  9000 ????	       00 e5	   _Bit0_BW_Mem =	r
     77  9000 ????
     78  9000 ????	       00 e5	   _BitOp_02  =	r
     79  9000 ????
     80  9000 ????	       00 df	   _Pause_Color_Tmp =	l
     81  9000 ????
     82  9000 ????	       00 df	   _AP_Dir_Counter =	l
     83  9000 ????
     84  9000 ????	       00 de	   _Pause_Mem_Color_Tmp =	k
     85  9000 ????
     86  9000 ????	       00 de	   _AP_2_Sec_Score_Flip =	k
     87  9000 ????
     88  9000 ????	       00 dd	   _AP_Mem_P0y =	j
     89  9000 ????
     90  9000 ????	       00 dc	   _AP_Mem_P0x =	i
     91  9000 ????
     92  9000 ????	       00 db	   _Pause_Counter_Tmp =	h
     93  9000 ????
     94  9000 ????	       00 db	   _AP_Mem_Dir =	h
     95  9000 ????
     96  9000 ????	       00 a0	   _T5_AP_Dir =	temp5
     97  9000 ????
     98  9000 ????	       00 da	   _Bit7_M1_Dir_Right =	g
     99  9000 ????
    100  9000 ????	       00 da	   _Bit6_M1_Dir_Left =	g
    101  9000 ????
    102  9000 ????	       00 da	   _Bit5_M1_Dir_Down =	g
    103  9000 ????
    104  9000 ????	       00 da	   _Bit4_M1_Dir_Up =	g
    105  9000 ????
    106  9000 ????	       00 da	   _Bit3_P0_Dir_Right =	g
    107  9000 ????
    108  9000 ????	       00 da	   _Bit2_P0_Dir_Left =	g
    109  9000 ????
    110  9000 ????	       00 da	   _Bit1_P0_Dir_Down =	g
    111  9000 ????
    112  9000 ????	       00 da	   _Bit0_P0_Dir_Up =	g
    113  9000 ????
    114  9000 ????	       00 da	   _BitOp_P0_M1_Dir =	g
    115  9000 ????
    116  9000 ????	       00 d9	   _Frame_Counter =	f
    117  9000 ????
    118  9000 ????	       00 d8	   _Master_Counter =	e
    119  9000 ????
    120  9000 ????	       00 07	   bs_mask    =	7
    121  9000 ????	       00 20	   bankswitch =	32
    122  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
    123  9000 ????	       00 01	   PFcolors   =	1
    124  9000 ????	       00 01	   no_blank_lines =	1
------- FILE spacetaxi.bas.asm
      8  9000 ????				      ifconst	bankswitch
      9  9000 ????			  -	      if	bankswitch == 8
     10  9000 ????			  -	      ORG	$1000
     11  9000 ????			  -	      RORG	$D000
     12  9000 ????				      endif
     13  9000 ????			  -	      if	bankswitch == 16
     14  9000 ????			  -	      ORG	$1000
     15  9000 ????			  -	      RORG	$9000
     16  9000 ????				      endif
     17  9000 ????				      if	bankswitch == 32
     18  1000					      ORG	$1000
     19  1000					      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							;
     37  1000
     38  1000				   .
     39  1000							;
     40  1000
     41  1000				   .
     42  1000							;
     43  1000
     44  1000				   .
     45  1000							;
     46  1000
     47  1000				   .
     48  1000							;
     49  1000
     50  1000				   .
     51  1000							;
     52  1000
     53  1000				   .
     54  1000							;
     55  1000
     56  1000				   .
     57  1000							;
     58  1000
     59  1000				   .
     60  1000							;
     61  1000
     62  1000				   .
     63  1000							;
     64  1000
     65  1000				   .
     66  1000							;
     67  1000
     68  1000				   .
     69  1000							;
     70  1000
     71  1000				   .
     72  1000							;
     73  1000
     74  1000				   .
     75  1000							;
     76  1000
     77  1000				   .
     78  1000							;
     79  1000
     80  1000				   .
     81  1000							;
     82  1000
     83  1000				   .
     84  1000							;
     85  1000
     86  1000				   .
     87  1000							;
     88  1000
     89  1000				   .
     90  1000							;
     91  1000
     92  1000				   .
     93  1000							;
     94  1000
     95  1000				   .
     96  1000							;
     97  1000
     98  1000				   .
     99  1000							;
    100  1000
    101  1000				   .
    102  1000							;
    103  1000
    104  1000				   .
    105  1000							;
    106  1000
    107  1000				   .
    108  1000							;
    109  1000
    110  1000				   .
    111  1000							;
    112  1000
    113  1000				   .
    114  1000							;
    115  1000
    116  1000				   .
    117  1000							;
    118  1000
    119  1000				   .
    120  1000							;
    121  1000
    122  1000				   .
    123  1000							;
    124  1000
    125  1000				   .
    126  1000							;
    127  1000
    128  1000				   .
    129  1000							;
    130  1000
    131  1000				   .
    132  1000							;
    133  1000
    134  1000				   .
    135  1000							;
    136  1000
    137  1000				   .
    138  1000							;
    139  1000
    140  1000				   .
    141  1000							;
    142  1000
    143  1000				   .
    144  1000							;
    145  1000
    146  1000				   .
    147  1000							;
    148  1000
    149  1000				   .
    150  1000							;
    151  1000
    152  1000				   .
    153  1000							;
    154  1000
    155  1000				   .
    156  1000							;
    157  1000
    158  1000				   .
    159  1000							;
    160  1000
    161  1000				   .
    162  1000							;
    163  1000
    164  1000				   .
    165  1000							;
    166  1000
    167  1000				   .
    168  1000							;
    169  1000
    170  1000				   .
    171  1000							;
    172  1000
    173  1000				   .
    174  1000							;
    175  1000
    176  1000				   .
    177  1000							;
    178  1000
    179  1000				   .
    180  1000							;
    181  1000
    182  1000				   .
    183  1000							;
    184  1000
    185  1000				   .
    186  1000							;
    187  1000
    188  1000				   .
    189  1000							;
    190  1000
    191  1000				   .
    192  1000							;
    193  1000
    194  1000				   .
    195  1000							;
    196  1000
    197  1000				   .
    198  1000							;
    199  1000
    200  1000				   .
    201  1000							;
    202  1000
    203  1000				   .
    204  1000							;
    205  1000
    206  1000				   .
    207  1000							;
    208  1000
    209  1000				   .
    210  1000							;
    211  1000
    212  1000				   .
    213  1000							;
    214  1000
    215  1000				   .
    216  1000							;
    217  1000
    218  1000				   .
    219  1000							;
    220  1000
    221  1000				   .
    222  1000							;
    223  1000
    224  1000				   .
    225  1000							;
    226  1000
    227  1000				   .L00 		;  set kernel_options pfcolors no_blank_lines
    228  1000
    229  1000				   .
    230  1000							;
    231  1000
    232  1000				   .
    233  1000							;
    234  1000
    235  1000				   .
    236  1000							;
    237  1000
    238  1000				   .
    239  1000							;
    240  1000
    241  1000				   .
    242  1000							;
    243  1000
    244  1000				   .
    245  1000							;
    246  1000
    247  1000				   .
    248  1000							;
    249  1000
    250  1000				   .L01 		;  set romsize 32k
    251  1000
    252  1000				   .
    253  1000							;
    254  1000
    255  1000				   .
    256  1000							;
    257  1000
    258  1000				   .
    259  1000							;
    260  1000
    261  1000				   .
    262  1000							;
    263  1000
    264  1000				   .
    265  1000							;
    266  1000
    267  1000				   .
    268  1000							;
    269  1000
    270  1000				   .
    271  1000							;
    272  1000
    273  1000				   .
    274  1000							;
    275  1000
    276  1000				   .L02 		;  set optimization inlinerand
    277  1000
    278  1000				   .
    279  1000							;
    280  1000
    281  1000				   .
    282  1000							;
    283  1000
    284  1000				   .
    285  1000							;
    286  1000
    287  1000				   .
    288  1000							;
    289  1000
    290  1000				   .
    291  1000							;
    292  1000
    293  1000				   .
    294  1000							;
    295  1000
    296  1000				   .
    297  1000							;
    298  1000
    299  1000				   .
    300  1000							;
    301  1000
    302  1000				   .
    303  1000							;
    304  1000
    305  1000				   .
    306  1000							;
    307  1000
    308  1000				   .
    309  1000							;
    310  1000
    311  1000				   .
    312  1000							;
    313  1000
    314  1000				   .
    315  1000							;
    316  1000
    317  1000				   .
    318  1000							;
    319  1000
    320  1000				   .
    321  1000							;
    322  1000
    323  1000				   .
    324  1000							;
    325  1000
    326  1000				   .
    327  1000							;
    328  1000
    329  1000				   .
    330  1000							;
    331  1000
    332  1000				   .
    333  1000							;
    334  1000
    335  1000				   .
    336  1000							;
    337  1000
    338  1000				   .
    339  1000							;
    340  1000
    341  1000				   .
    342  1000							;
    343  1000
    344  1000				   .
    345  1000							;
    346  1000
    347  1000				   .
    348  1000							;
    349  1000
    350  1000				   .
    351  1000							;
    352  1000
    353  1000				   .
    354  1000							;
    355  1000
    356  1000				   .
    357  1000							;
    358  1000
    359  1000				   .
    360  1000							;
    361  1000
    362  1000				   .
    363  1000							;
    364  1000
    365  1000				   .
    366  1000							;
    367  1000
    368  1000				   .
    369  1000							;
    370  1000
    371  1000				   .L03 		;  dim _Master_Counter  =  e
    372  1000
    373  1000				   .L04 		;  dim _Frame_Counter	=  f
    374  1000
    375  1000				   .
    376  1000							;
    377  1000
    378  1000				   .
    379  1000							;
    380  1000
    381  1000				   .
    382  1000							;
    383  1000
    384  1000				   .
    385  1000							;
    386  1000
    387  1000				   .L05 		;  dim _BitOp_P0_M1_Dir  =  g
    388  1000
    389  1000				   .L06 		;  dim _Bit0_P0_Dir_Up  =  g
    390  1000
    391  1000				   .L07 		;  dim _Bit1_P0_Dir_Down  =  g
    392  1000
    393  1000				   .L08 		;  dim _Bit2_P0_Dir_Left  =  g
    394  1000
    395  1000				   .L09 		;  dim _Bit3_P0_Dir_Right  =  g
    396  1000
    397  1000				   .L010		;  dim _Bit4_M1_Dir_Up  =  g
    398  1000
    399  1000				   .L011		;  dim _Bit5_M1_Dir_Down  =  g
    400  1000
    401  1000				   .L012		;  dim _Bit6_M1_Dir_Left  =  g
    402  1000
    403  1000				   .L013		;  dim _Bit7_M1_Dir_Right  =  g
    404  1000
    405  1000				   .
    406  1000							;
    407  1000
    408  1000				   .
    409  1000							;
    410  1000
    411  1000				   .
    412  1000							;
    413  1000
    414  1000				   .
    415  1000							;
    416  1000
    417  1000				   .
    418  1000							;
    419  1000
    420  1000				   .
    421  1000							;
    422  1000
    423  1000				   .L014		;  dim _T5_AP_Dir  =  temp5
    424  1000
    425  1000				   .
    426  1000							;
    427  1000
    428  1000				   .
    429  1000							;
    430  1000
    431  1000				   .
    432  1000							;
    433  1000
    434  1000				   .
    435  1000							;
    436  1000
    437  1000				   .
    438  1000							;
    439  1000
    440  1000				   .
    441  1000							;
    442  1000
    443  1000				   .
    444  1000							;
    445  1000
    446  1000				   .
    447  1000							;
    448  1000
    449  1000				   .L015		;  dim _AP_Mem_Dir  =	h
    450  1000
    451  1000				   .
    452  1000							;
    453  1000
    454  1000				   .
    455  1000							;
    456  1000
    457  1000				   .
    458  1000							;
    459  1000
    460  1000				   .
    461  1000							;
    462  1000
    463  1000				   .
    464  1000							;
    465  1000
    466  1000				   .
    467  1000							;
    468  1000
    469  1000				   .L016		;  dim _Pause_Counter_Tmp  =  h
    470  1000
    471  1000				   .
    472  1000							;
    473  1000
    474  1000				   .
    475  1000							;
    476  1000
    477  1000				   .
    478  1000							;
    479  1000
    480  1000				   .
    481  1000							;
    482  1000
    483  1000				   .
    484  1000							;
    485  1000
    486  1000				   .
    487  1000							;
    488  1000
    489  1000				   .
    490  1000							;
    491  1000
    492  1000				   .L017		;  dim _AP_Mem_P0x  =	i
    493  1000
    494  1000				   .L018		;  dim _AP_Mem_P0y  =	j
    495  1000
    496  1000				   .
    497  1000							;
    498  1000
    499  1000				   .
    500  1000							;
    501  1000
    502  1000				   .
    503  1000							;
    504  1000
    505  1000				   .
    506  1000							;
    507  1000
    508  1000				   .
    509  1000							;
    510  1000
    511  1000				   .
    512  1000							;
    513  1000
    514  1000				   .L019		;  dim _AP_2_Sec_Score_Flip  =  k
    515  1000
    516  1000				   .
    517  1000							;
    518  1000
    519  1000				   .
    520  1000							;
    521  1000
    522  1000				   .
    523  1000							;
    524  1000
    525  1000				   .
    526  1000							;
    527  1000
    528  1000				   .
    529  1000							;
    530  1000
    531  1000				   .
    532  1000							;
    533  1000
    534  1000				   .L020		;  dim _Pause_Mem_Color_Tmp  =  k
    535  1000
    536  1000				   .
    537  1000							;
    538  1000
    539  1000				   .
    540  1000							;
    541  1000
    542  1000				   .
    543  1000							;
    544  1000
    545  1000				   .
    546  1000							;
    547  1000
    548  1000				   .
    549  1000							;
    550  1000
    551  1000				   .
    552  1000							;
    553  1000
    554  1000				   .L021		;  dim _AP_Dir_Counter  =  l
    555  1000
    556  1000				   .
    557  1000							;
    558  1000
    559  1000				   .
    560  1000							;
    561  1000
    562  1000				   .
    563  1000							;
    564  1000
    565  1000				   .
    566  1000							;
    567  1000
    568  1000				   .
    569  1000							;
    570  1000
    571  1000				   .
    572  1000							;
    573  1000
    574  1000				   .L022		;  dim _Pause_Color_Tmp  =  l
    575  1000
    576  1000				   .
    577  1000							;
    578  1000
    579  1000				   .
    580  1000							;
    581  1000
    582  1000				   .
    583  1000							;
    584  1000
    585  1000				   .
    586  1000							;
    587  1000
    588  1000				   .
    589  1000							;
    590  1000
    591  1000				   .L023		;  dim _BitOp_02  =  r
    592  1000
    593  1000				   .
    594  1000							;
    595  1000
    596  1000				   .
    597  1000							;
    598  1000
    599  1000				   .
    600  1000							;
    601  1000
    602  1000				   .
    603  1000							;
    604  1000
    605  1000				   .L024		;  dim _Bit0_BW_Mem  =  r
    606  1000
    607  1000				   .
    608  1000							;
    609  1000
    610  1000				   .
    611  1000							;
    612  1000
    613  1000				   .
    614  1000							;
    615  1000
    616  1000				   .
    617  1000							;
    618  1000
    619  1000				   .L025		;  dim _Bit1_BW_Check	=  r
    620  1000
    621  1000				   .
    622  1000							;
    623  1000
    624  1000				   .
    625  1000							;
    626  1000
    627  1000				   .
    628  1000							;
    629  1000
    630  1000				   .
    631  1000							;
    632  1000
    633  1000				   .L026		;  dim _Bit2_Pause_Clr_Scheme	=  r
    634  1000
    635  1000				   .
    636  1000							;
    637  1000
    638  1000				   .
    639  1000							;
    640  1000
    641  1000				   .
    642  1000							;
    643  1000
    644  1000				   .
    645  1000							;
    646  1000
    647  1000				   .
    648  1000							;
    649  1000
    650  1000				   .
    651  1000							;
    652  1000
    653  1000				   .
    654  1000							;
    655  1000
    656  1000				   .
    657  1000							;
    658  1000
    659  1000				   .L027		;  dim _Score1_Mem  =	s
    660  1000
    661  1000				   .L028		;  dim _Score2_Mem  =	t
    662  1000
    663  1000				   .L029		;  dim _Score3_Mem  =	u
    664  1000
    665  1000				   .
    666  1000							;
    667  1000
    668  1000				   .
    669  1000							;
    670  1000
    671  1000				   .
    672  1000							;
    673  1000
    674  1000				   .
    675  1000							;
    676  1000
    677  1000				   .
    678  1000							;
    679  1000
    680  1000				   .L030		;  dim _Player_Direction_X  =	n
    681  1000
    682  1000				   .L031		;  dim _Player_Direction_Y  =	o
    683  1000
    684  1000				   .L032		;  dim _Player_Acceleration_X	=  p
    685  1000
    686  1000				   .L033		;  dim _Player_Acceleration_Y	=  q
    687  1000
    688  1000				   .L034		;  dim _Number_Of_Lives  =  s
    689  1000
    690  1000				   .L035		;  dim _Remaining_Fare  =  t
    691  1000
    692  1000				   .L036		;  dim _Destination_Pad_Num  =  u
    693  1000
    694  1000				   .
    695  1000							;
    696  1000
    697  1000				   .
    698  1000							;
    699  1000
    700  1000				   .
    701  1000							;
    702  1000
    703  1000				   .
    704  1000							;
    705  1000
    706  1000				   .L037		;  dim _High_Score1  =  v
    707  1000
    708  1000				   .L038		;  dim _High_Score2  =  w
    709  1000
    710  1000				   .L039		;  dim _High_Score3  =  x
    711  1000
    712  1000				   .
    713  1000							;
    714  1000
    715  1000				   .
    716  1000							;
    717  1000
    718  1000				   .
    719  1000							;
    720  1000
    721  1000				   .
    722  1000							;
    723  1000
    724  1000				   .
    725  1000							;
    726  1000
    727  1000				   .L040		;  dim _BitOp_01  =  y
    728  1000
    729  1000				   .L041		;  dim _Bit0_Reset_Restrainer	=  y
    730  1000
    731  1000				   .L042		;  dim _Bit1_FireB_Restrainer	=  y
    732  1000
    733  1000				   .L043		;  dim _Bit2_Game_Control  =  y
    734  1000
    735  1000				   .L044		;  dim _Bit3_Auto_Play  =  y
    736  1000
    737  1000				   .L045		;  dim _Bit6_Swap_Scores  =  y
    738  1000
    739  1000				   .L046		;  dim _Bit7_M1_Moving  =  y
    740  1000
    741  1000				   .
    742  1000							;
    743  1000
    744  1000				   .
    745  1000							;
    746  1000
    747  1000				   .
    748  1000							;
    749  1000
    750  1000				   .
    751  1000							;
    752  1000
    753  1000				   .L047		;  dim rand16	=  z
    754  1000
    755  1000				   .
    756  1000							;
    757  1000
    758  1000				   .
    759  1000							;
    760  1000
    761  1000				   .
    762  1000							;
    763  1000
    764  1000				   .
    765  1000							;
    766  1000
    767  1000				   .
    768  1000							;
    769  1000
    770  1000				   .
    771  1000							;
    772  1000
    773  1000				   .
    774  1000							;
    775  1000
    776  1000				   .
    777  1000							;
    778  1000
    779  1000				   .L048		;  dim _sc1  =  score
    780  1000
    781  1000				   .L049		;  dim _sc2  =  score + 1
    782  1000
    783  1000				   .L050		;  dim _sc3  =  score + 2
    784  1000
    785  1000				   .
    786  1000							;
    787  1000
    788  1000				   .
    789  1000							;
    790  1000
    791  1000				   .
    792  1000							;
    793  1000
    794  1000				   .
    795  1000							;
    796  1000
    797  1000				   .
    798  1000							;
    799  1000
    800  1000				   .
    801  1000							;
    802  1000
    803  1000				   .
    804  1000							;
    805  1000
    806  1000				   .
    807  1000							;
    808  1000
    809  1000				   .L051		;  const _P_Edge_Top  =  9
    810  1000
    811  1000				   .L052		;  const _P_Edge_Bottom  =  88
    812  1000
    813  1000				   .L053		;  const _P_Edge_Left	=  1
    814  1000
    815  1000				   .L054		;  const _P_Edge_Right  =  152
    816  1000
    817  1000				   .
    818  1000							;
    819  1000
    820  1000				   .
    821  1000							;
    822  1000
    823  1000				   .
    824  1000							;
    825  1000
    826  1000				   .
    827  1000							;
    828  1000
    829  1000				   .
    830  1000							;
    831  1000
    832  1000				   .
    833  1000							;
    834  1000
    835  1000				   .
    836  1000							;
    837  1000
    838  1000				   .
    839  1000							;
    840  1000
    841  1000				   .
    842  1000							;
    843  1000
    844  1000				   .L055		;  const _M_Edge_Top  =  2
    845  1000
    846  1000				   .L056		;  const _M_Edge_Bottom  =  88
    847  1000
    848  1000				   .L057		;  const _M_Edge_Left	=  2
    849  1000
    850  1000				   .L058		;  const _M_Edge_Right  =  159
    851  1000
    852  1000				   .
    853  1000							;
    854  1000
    855  1000				   .
    856  1000							;
    857  1000
    858  1000				   .
    859  1000							;
    860  1000
    861  1000				   .
    862  1000							;
    863  1000
    864  1000				   .
    865  1000							;
    866  1000
    867  1000				   .
    868  1000							;
    869  1000
    870  1000				   .
    871  1000							;
    872  1000
    873  1000				   .L059		;  const pfscore  =  1
    874  1000
    875  1000				   .L060		;  const font	=  retroputer
    876  1000
    877  1000				   .
    878  1000							;
    879  1000
    880  1000				   .
    881  1000							;
    882  1000
    883  1000				   .
    884  1000							;
    885  1000
    886  1000				   .
    887  1000							;
    888  1000
    889  1000				   .
    890  1000							;
    891  1000
    892  1000				   .L061		;  pfscore1  =  %10101010
    893  1000
    894  1000		       a9 aa		      LDA	#%10101010
    895  1002		       85 f2		      STA	pfscore1
    896  1004				   .L062		;  pfscore2  =  %11111111
    897  1004
    898  1004		       a9 ff		      LDA	#%11111111
    899  1006		       85 f3		      STA	pfscore2
    900  1008				   .
    901  1008							;
    902  1008
    903  1008				   .
    904  1008							;
    905  1008
    906  1008				   .
    907  1008							;
    908  1008
    909  1008				   .
    910  1008							;
    911  1008
    912  1008				   .
    913  1008							;
    914  1008
    915  1008				   .L063		;  pfscorecolor  =  $CB
    916  1008
    917  1008		       a9 cb		      LDA	#$CB
    918  100a		       85 f4		      STA	pfscorecolor
    919  100c				   .
    920  100c							;
    921  100c
    922  100c				   .
    923  100c							;
    924  100c
    925  100c				   .
    926  100c							;
    927  100c
    928  100c				   .
    929  100c							;
    930  100c
    931  100c				   .
    932  100c							;
    933  100c
    934  100c				   .
    935  100c							;
    936  100c
    937  100c				   .
    938  100c							;
    939  100c
    940  100c				   .
    941  100c							;
    942  100c
    943  100c				   .__Start_Restart
    944  100c							; __Start_Restart
    945  100c
    946  100c				   .
    947  100c							;
    948  100c
    949  100c				   .
    950  100c							;
    951  100c
    952  100c				   .
    953  100c							;
    954  100c
    955  100c				   .
    956  100c							;
    957  100c
    958  100c				   .
    959  100c							;
    960  100c
    961  100c				   .
    962  100c							;
    963  100c
    964  100c				   .L064		;  AUDV0  =  0  :  AUDV1  =  0
    965  100c
    966  100c		       a9 00		      LDA	#0
    967  100e		       85 19		      STA	AUDV0
    968  1010		       85 1a		      STA	AUDV1
    969  1012				   .
    970  1012							;
    971  1012
    972  1012				   .
    973  1012							;
    974  1012
    975  1012				   .
    976  1012							;
    977  1012
    978  1012				   .
    979  1012							;
    980  1012
    981  1012				   .
    982  1012							;
    983  1012
    984  1012				   .
    985  1012							;
    986  1012
    987  1012				   .
    988  1012							;
    989  1012
    990  1012				   .
    991  1012							;
    992  1012
    993  1012				   .
    994  1012							;
    995  1012
    996  1012				   .
    997  1012							;
    998  1012
    999  1012				   .
   1000  1012							;
   1001  1012
   1002  1012				   .L065		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
   1003  1012
   1004  1012		       a9 00		      LDA	#0
   1005  1014		       85 d4		      STA	a
   1006  1016		       85 d5		      STA	b
   1007  1018		       85 d6		      STA	c
   1008  101a		       85 d7		      STA	d
   1009  101c		       85 d8		      STA	e
   1010  101e		       85 d9		      STA	f
   1011  1020		       85 da		      STA	g
   1012  1022		       85 db		      STA	h
   1013  1024		       85 dc		      STA	i
   1014  1026				   .L066		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
   1015  1026
   1016  1026		       a9 00		      LDA	#0
   1017  1028		       85 dd		      STA	j
   1018  102a		       85 de		      STA	k
   1019  102c		       85 df		      STA	l
   1020  102e		       85 e0		      STA	m
   1021  1030		       85 e1		      STA	n
   1022  1032		       85 e2		      STA	o
   1023  1034		       85 e3		      STA	p
   1024  1036		       85 e4		      STA	q
   1025  1038		       85 e5		      STA	r
   1026  103a				   .L067		;  s  =  0  :	t  =  0  :  u  =  0
   1027  103a
   1028  103a		       a9 00		      LDA	#0
   1029  103c		       85 e6		      STA	s
   1030  103e		       85 e7		      STA	t
   1031  1040		       85 e8		      STA	u
   1032  1042				   .
   1033  1042							;
   1034  1042
   1035  1042				   .
   1036  1042							;
   1037  1042
   1038  1042				   .
   1039  1042							;
   1040  1042
   1041  1042				   .
   1042  1042							;
   1043  1042
   1044  1042				   .
   1045  1042							;
   1046  1042
   1047  1042				   .
   1048  1042							;
   1049  1042
   1050  1042				   .
   1051  1042							;
   1052  1042
   1053  1042				   .
   1054  1042							;
   1055  1042
   1056  1042				   .
   1057  1042							;
   1058  1042
   1059  1042				   .L068		;  _BitOp_01  =  _BitOp_01  &	%00000100
   1060  1042
   1061  1042		       a5 ec		      LDA	_BitOp_01
   1062  1044		       29 04		      AND	#%00000100
   1063  1046		       85 ec		      STA	_BitOp_01
   1064  1048				   .
   1065  1048							;
   1066  1048
   1067  1048				   .
   1068  1048							;
   1069  1048
   1070  1048				   .
   1071  1048							;
   1072  1048
   1073  1048				   .
   1074  1048							;
   1075  1048
   1076  1048				   .
   1077  1048							;
   1078  1048
   1079  1048				   .
   1080  1048							;
   1081  1048
   1082  1048				   .L069		;  player0y  =  200  :  player1y  =  200  :  missile1y  =  200
   1083  1048
   1084  1048		       a9 c8		      LDA	#200
   1085  104a		       85 85		      STA	player0y
   1086  104c		       85 86		      STA	player1y
   1087  104e		       85 88		      STA	missile1y
   1088  1050				   .
   1089  1050							;
   1090  1050
   1091  1050				   .
   1092  1050							;
   1093  1050
   1094  1050				   .
   1095  1050							;
   1096  1050
   1097  1050				   .
   1098  1050							;
   1099  1050
   1100  1050				   .
   1101  1050							;
   1102  1050
   1103  1050				   .
   1104  1050							;
   1105  1050
   1106  1050				   .
   1107  1050							;
   1108  1050
   1109  1050				   .
   1110  1050							;
   1111  1050
   1112  1050				   .
   1113  1050							;
   1114  1050
   1115  1050				   .
   1116  1050							;
   1117  1050
   1118  1050				   .
   1119  1050							;
   1120  1050
   1121  1050				   .L070		;  if _Bit2_Game_Control{2} then goto __Main_Loop_Setup bank2
   1122  1050
   1123  1050		       a5 ec		      LDA	_Bit2_Game_Control
   1124  1052		       29 04		      AND	#4
   1125  1054		       f0 12		      BEQ	.skipL070
   1126  1056				   .condpart0
   1127  1056		       85 ee		      sta	temp7
   1128  1058		       a9 2f		      lda	#>(.__Main_Loop_Setup-1)
   1129  105a		       48		      pha
   1130  105b		       a9 ff		      lda	#<(.__Main_Loop_Setup-1)
   1131  105d		       48		      pha
   1132  105e		       a5 ee		      lda	temp7
   1133  1060		       48		      pha
   1134  1061		       8a		      txa
   1135  1062		       48		      pha
   1136  1063		       a2 02		      ldx	#2
   1137  1065		       4c eb ff 	      jmp	BS_jsr
   1138  1068				   .skipL070
   1139  1068				   .
   1140  1068							;
   1141  1068
   1142  1068				   .
   1143  1068							;
   1144  1068
   1145  1068				   .
   1146  1068							;
   1147  1068
   1148  1068				   .
   1149  1068							;
   1150  1068
   1151  1068				   .
   1152  1068							;
   1153  1068
   1154  1068				   .
   1155  1068							;
   1156  1068
   1157  1068				   .
   1158  1068							;
   1159  1068
   1160  1068				   .
   1161  1068							;
   1162  1068
   1163  1068				   .
   1164  1068							;
   1165  1068
   1166  1068				   .
   1167  1068							;
   1168  1068
   1169  1068				   .
   1170  1068							;
   1171  1068
   1172  1068				   .__Title_Screen_Setup
   1173  1068							; __Title_Screen_Setup
   1174  1068
   1175  1068				   .
   1176  1068							;
   1177  1068
   1178  1068				   .
   1179  1068							;
   1180  1068
   1181  1068				   .
   1182  1068							;
   1183  1068
   1184  1068				   .
   1185  1068							;
   1186  1068
   1187  1068				   .
   1188  1068							;
   1189  1068
   1190  1068				   .
   1191  1068							;
   1192  1068
   1193  1068				   .L071		;  scorecolor	=  0
   1194  1068
   1195  1068		       a9 00		      LDA	#0
   1196  106a		       85 a3		      STA	scorecolor
   1197  106c				   .L072		;  pfscorecolor  =  0
   1198  106c
   1199  106c		       a9 00		      LDA	#0
   1200  106e		       85 f4		      STA	pfscorecolor
   1201  1070				   .
   1202  1070							;
   1203  1070
   1204  1070				   .
   1205  1070							;
   1206  1070
   1207  1070				   .
   1208  1070							;
   1209  1070
   1210  1070				   .
   1211  1070							;
   1212  1070
   1213  1070				   .
   1214  1070							;
   1215  1070
   1216  1070				   .
   1217  1070							;
   1218  1070
   1219  1070				   .L073		;  COLUBK  =  0
   1220  1070
   1221  1070		       a9 00		      LDA	#0
   1222  1072		       85 09		      STA	COLUBK
   1223  1074				   .
   1224  1074							;
   1225  1074
   1226  1074				   .
   1227  1074							;
   1228  1074
   1229  1074				   .
   1230  1074							;
   1231  1074
   1232  1074				   .
   1233  1074							;
   1234  1074
   1235  1074				   .
   1236  1074							;
   1237  1074
   1238  1074				   .
   1239  1074							;
   1240  1074
   1241  1074				   .
   1242  1074							;
   1243  1074
   1244  1074				   .
   1245  1074							;
   1246  1074
   1247  1074				   .
   1248  1074							;
   1249  1074
   1250  1074				   .
   1251  1074							;
   1252  1074
   1253  1074				   .
   1254  1074							;
   1255  1074
   1256  1074				   .L074		;  _Bit0_Reset_Restrainer{0}  =  1
   1257  1074
   1258  1074		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1259  1076		       09 01		      ORA	#1
   1260  1078		       85 ec		      STA	_Bit0_Reset_Restrainer
   1261  107a				   .
   1262  107a							;
   1263  107a
   1264  107a				   .
   1265  107a							;
   1266  107a
   1267  107a				   .
   1268  107a							;
   1269  107a
   1270  107a				   .
   1271  107a							;
   1272  107a
   1273  107a				   .
   1274  107a							;
   1275  107a
   1276  107a				   .
   1277  107a							;
   1278  107a
   1279  107a				   .L075		;  playfield:
   1280  107a
   1281  107a				  -	      ifconst	pfres
   1282  107a				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   1283  107a					      else
   1284  107a		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   1285  107c					      endif
   1286  107c		       4c ab 10 	      jmp	pflabel0
   1287  107f				   PF_data0
   1288  107f		       7d cf		      .byte.b	%01111101, %11001111
   1289  1081					      if	(pfwidth>2)
   1290  1081		       c7 f9		      .byte.b	%11000111, %11111001
   1291  1083					      endif
   1292  1083		       e1 69		      .byte.b	%11100001, %01101001
   1293  1085					      if	(pfwidth>2)
   1294  1085		       6c 0c		      .byte.b	%01101100, %00001100
   1295  1087					      endif
   1296  1087		       79 e7		      .byte.b	%01111001, %11100111
   1297  1089					      if	(pfwidth>2)
   1298  1089		       ec 3c		      .byte.b	%11101100, %00111100
   1299  108b					      endif
   1300  108b		       0d 61		      .byte.b	%00001101, %01100001
   1301  108d					      if	(pfwidth>2)
   1302  108d		       6c 0c		      .byte.b	%01101100, %00001100
   1303  108f					      endif
   1304  108f		       f9 61		      .byte.b	%11111001, %01100001
   1305  1091					      if	(pfwidth>2)
   1306  1091		       67 f9		      .byte.b	%01100111, %11111001
   1307  1093					      endif
   1308  1093		       00 00		      .byte.b	%00000000, %00000000
   1309  1095					      if	(pfwidth>2)
   1310  1095		       00 00		      .byte.b	%00000000, %00000000
   1311  1097					      endif
   1312  1097		       ff 3c		      .byte.b	%11111111, %00111100
   1313  1099					      if	(pfwidth>2)
   1314  1099		       60 66		      .byte.b	%01100000, %01100110
   1315  109b					      endif
   1316  109b		       18 66		      .byte.b	%00011000, %01100110
   1317  109d					      if	(pfwidth>2)
   1318  109d		       19 61		      .byte.b	%00011001, %01100001
   1319  109f					      endif
   1320  109f		       18 7e		      .byte.b	%00011000, %01111110
   1321  10a1					      if	(pfwidth>2)
   1322  10a1		       06 60		      .byte.b	%00000110, %01100000
   1323  10a3					      endif
   1324  10a3		       18 66		      .byte.b	%00011000, %01100110
   1325  10a5					      if	(pfwidth>2)
   1326  10a5		       19 61		      .byte.b	%00011001, %01100001
   1327  10a7					      endif
   1328  10a7		       18 66		      .byte.b	%00011000, %01100110
   1329  10a9					      if	(pfwidth>2)
   1330  10a9		       60 66		      .byte.b	%01100000, %01100110
   1331  10ab					      endif
   1332  10ab				   pflabel0
   1333  10ab		       bd 7f 10 	      lda	PF_data0,x
   1334  10ae		       95 a4		      sta	playfield,x
   1335  10b0		       ca		      dex
   1336  10b1		       10 f8		      bpl	pflabel0
   1337  10b3				   .
   1338  10b3							;
   1339  10b3
   1340  10b3				   .
   1341  10b3							;
   1342  10b3
   1343  10b3				   .
   1344  10b3							;
   1345  10b3
   1346  10b3				   .L076		;  player0x  =  0  :  player0y  =  0
   1347  10b3
   1348  10b3		       a9 00		      LDA	#0
   1349  10b5		       85 80		      STA	player0x
   1350  10b7		       85 85		      STA	player0y
   1351  10b9				   .
   1352  10b9							;
   1353  10b9
   1354  10b9				   .
   1355  10b9							;
   1356  10b9
   1357  10b9				   .
   1358  10b9							;
   1359  10b9
   1360  10b9				   .
   1361  10b9							;
   1362  10b9
   1363  10b9				   .
   1364  10b9							;
   1365  10b9
   1366  10b9				   .
   1367  10b9							;
   1368  10b9
   1369  10b9				   .
   1370  10b9							;
   1371  10b9
   1372  10b9				   .
   1373  10b9							;
   1374  10b9
   1375  10b9				   .__Title_Screen_Loop
   1376  10b9							; __Title_Screen_Loop
   1377  10b9
   1378  10b9				   .
   1379  10b9							;
   1380  10b9
   1381  10b9				   .
   1382  10b9							;
   1383  10b9
   1384  10b9				   .
   1385  10b9							;
   1386  10b9
   1387  10b9				   .
   1388  10b9							;
   1389  10b9
   1390  10b9				   .
   1391  10b9							;
   1392  10b9
   1393  10b9				   .
   1394  10b9							;
   1395  10b9
   1396  10b9				   .
   1397  10b9							;
   1398  10b9
   1399  10b9				   .L077		;  pfcolors:
   1400  10b9
   1401  10b9		       a9 1e		      lda	# $1E
   1402  10bb		       85 08		      sta	COLUPF
   1403  10bd				  -	      ifconst	pfres
   1404  10bd				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
   1405  10bd					      else
   1406  10bd		       a9 f5		      lda	#>(pfcolorlabel13-84)
   1407  10bf					      endif
   1408  10bf		       85 f1		      sta	pfcolortable+1
   1409  10c1				  -	      ifconst	pfres
   1410  10c1				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
   1411  10c1					      else
   1412  10c1		       a9 04		      lda	#<(pfcolorlabel13-84)
   1413  10c3					      endif
   1414  10c3		       85 f0		      sta	pfcolortable
   1415  10c5				   .
   1416  10c5							;
   1417  10c5
   1418  10c5				   .
   1419  10c5							;
   1420  10c5
   1421  10c5				   .
   1422  10c5							;
   1423  10c5
   1424  10c5				   .
   1425  10c5							;
   1426  10c5
   1427  10c5				   .
   1428  10c5							;
   1429  10c5
   1430  10c5				   .
   1431  10c5							;
   1432  10c5
   1433  10c5				   .
   1434  10c5							;
   1435  10c5
   1436  10c5				   .
   1437  10c5							;
   1438  10c5
   1439  10c5				   .
   1440  10c5							;
   1441  10c5
   1442  10c5				   .
   1443  10c5							;
   1444  10c5
   1445  10c5				   .
   1446  10c5							;
   1447  10c5
   1448  10c5				   .
   1449  10c5							;
   1450  10c5
   1451  10c5				   .
   1452  10c5							;
   1453  10c5
   1454  10c5				   .L078		;  _Master_Counter  =	_Master_Counter  +  1
   1455  10c5
   1456  10c5		       e6 d8		      INC	_Master_Counter
   1457  10c7				   .
   1458  10c7							;
   1459  10c7
   1460  10c7				   .
   1461  10c7							;
   1462  10c7
   1463  10c7				   .
   1464  10c7							;
   1465  10c7
   1466  10c7				   .
   1467  10c7							;
   1468  10c7
   1469  10c7				   .L079		;  if _Master_Counter	<  60 then goto __TS_AP_Skip
   1470  10c7
   1471  10c7		       a5 d8		      LDA	_Master_Counter
   1472  10c9		       c9 3c		      CMP	#60
   1473  10cb		       b0 03		      BCS	.skipL079
   1474  10cd				   .condpart1
   1475  10cd		       4c f4 10 	      jmp	.__TS_AP_Skip
   1476  10d0
   1477  10d0				   .skipL079
   1478  10d0				   .
   1479  10d0							;
   1480  10d0
   1481  10d0				   .
   1482  10d0							;
   1483  10d0
   1484  10d0				   .
   1485  10d0							;
   1486  10d0
   1487  10d0				   .
   1488  10d0							;
   1489  10d0
   1490  10d0				   .L080		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
   1491  10d0
   1492  10d0		       e6 d9		      INC	_Frame_Counter
   1493  10d2		       a9 00		      LDA	#0
   1494  10d4		       85 d8		      STA	_Master_Counter
   1495  10d6				   .
   1496  10d6							;
   1497  10d6
   1498  10d6				   .
   1499  10d6							;
   1500  10d6
   1501  10d6				   .
   1502  10d6							;
   1503  10d6
   1504  10d6				   .
   1505  10d6							;
   1506  10d6
   1507  10d6				   .
   1508  10d6							;
   1509  10d6
   1510  10d6				   .
   1511  10d6							;
   1512  10d6
   1513  10d6				   .
   1514  10d6							;
   1515  10d6
   1516  10d6				   .L081		;  if _Frame_Counter  >  9 then _Bit3_Auto_Play{3}  =	1  :  goto __Main_Loop_Setup bank2
   1517  10d6
   1518  10d6		       a9 09		      LDA	#9
   1519  10d8		       c5 d9		      CMP	_Frame_Counter
   1520  10da		       b0 18		      BCS	.skipL081
   1521  10dc				   .condpart2
   1522  10dc		       a5 ec		      LDA	_Bit3_Auto_Play
   1523  10de		       09 08		      ORA	#8
   1524  10e0		       85 ec		      STA	_Bit3_Auto_Play
   1525  10e2		       85 ee		      sta	temp7
   1526  10e4		       a9 2f		      lda	#>(.__Main_Loop_Setup-1)
   1527  10e6		       48		      pha
   1528  10e7		       a9 ff		      lda	#<(.__Main_Loop_Setup-1)
   1529  10e9		       48		      pha
   1530  10ea		       a5 ee		      lda	temp7
   1531  10ec		       48		      pha
   1532  10ed		       8a		      txa
   1533  10ee		       48		      pha
   1534  10ef		       a2 02		      ldx	#2
   1535  10f1		       4c eb ff 	      jmp	BS_jsr
   1536  10f4				   .skipL081
   1537  10f4				   .
   1538  10f4							;
   1539  10f4
   1540  10f4				   .__TS_AP_Skip
   1541  10f4							; __TS_AP_Skip
   1542  10f4
   1543  10f4				   .
   1544  10f4							;
   1545  10f4
   1546  10f4				   .
   1547  10f4							;
   1548  10f4
   1549  10f4				   .
   1550  10f4							;
   1551  10f4
   1552  10f4				   .
   1553  10f4							;
   1554  10f4
   1555  10f4				   .
   1556  10f4							;
   1557  10f4
   1558  10f4				   .
   1559  10f4							;
   1560  10f4
   1561  10f4				   .
   1562  10f4							;
   1563  10f4
   1564  10f4				   .L082		;  drawscreen
   1565  10f4
   1566  10f4		       85 ee		      sta	temp7
   1567  10f6		       a9 11		      lda	#>(ret_point1-1)
   1568  10f8		       48		      pha
   1569  10f9		       a9 0b		      lda	#<(ret_point1-1)
   1570  10fb		       48		      pha
   1571  10fc		       a9 f4		      lda	#>(drawscreen-1)
   1572  10fe		       48		      pha
   1573  10ff		       a9 3b		      lda	#<(drawscreen-1)
   1574  1101		       48		      pha
   1575  1102		       a5 ee		      lda	temp7
   1576  1104		       48		      pha
   1577  1105		       8a		      txa
   1578  1106		       48		      pha
   1579  1107		       a2 08		      ldx	#8
   1580  1109		       4c eb ff 	      jmp	BS_jsr
   1581  110c				   ret_point1
   1582  110c				   .
   1583  110c							;
   1584  110c
   1585  110c				   .
   1586  110c							;
   1587  110c
   1588  110c				   .
   1589  110c							;
   1590  110c
   1591  110c				   .
   1592  110c							;
   1593  110c
   1594  110c				   .
   1595  110c							;
   1596  110c
   1597  110c				   .
   1598  110c							;
   1599  110c
   1600  110c				   .
   1601  110c							;
   1602  110c
   1603  110c				   .
   1604  110c							;
   1605  110c
   1606  110c				   .
   1607  110c							;
   1608  110c
   1609  110c				   .
   1610  110c							;
   1611  110c
   1612  110c				   .
   1613  110c							;
   1614  110c
   1615  110c				   .
   1616  110c							;
   1617  110c
   1618  110c				   .
   1619  110c							;
   1620  110c
   1621  110c				   .
   1622  110c							;
   1623  110c
   1624  110c				   .L083		;  if !switchreset  &&  !joy0fire then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Title_Screen_Loop
   1625  110c
   1626  110c		       a9 01		      lda	#1
   1627  110e		       2c 82 02 	      bit	SWCHB
   1628  1111		       f0 0d		      BEQ	.skipL083
   1629  1113				   .condpart3
   1630  1113		       24 0c		      bit	INPT4
   1631  1115		       10 09		      BPL	.skip3then
   1632  1117				   .condpart4
   1633  1117		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1634  1119		       29 fe		      AND	#254
   1635  111b		       85 ec		      STA	_Bit0_Reset_Restrainer
   1636  111d		       4c b9 10 	      jmp	.__Title_Screen_Loop
   1637  1120
   1638  1120				   .skip3then
   1639  1120				   .skipL083
   1640  1120				   .
   1641  1120							;
   1642  1120
   1643  1120				   .
   1644  1120							;
   1645  1120
   1646  1120				   .
   1647  1120							;
   1648  1120
   1649  1120				   .
   1650  1120							;
   1651  1120
   1652  1120				   .
   1653  1120							;
   1654  1120
   1655  1120				   .L084		;  if _Bit0_Reset_Restrainer{0} then goto __Title_Screen_Loop
   1656  1120
   1657  1120		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1658  1122		       4a		      LSR
   1659  1123		       90 03		      BCC	.skipL084
   1660  1125				   .condpart5
   1661  1125		       4c b9 10 	      jmp	.__Title_Screen_Loop
   1662  1128
   1663  1128				   .skipL084
   1664  1128				   .
   1665  1128							;
   1666  1128
   1667  1128				   .
   1668  1128							;
   1669  1128
   1670  1128				   .
   1671  1128							;
   1672  1128
   1673  1128				   .
   1674  1128							;
   1675  1128
   1676  1128				   .L085		;  _Bit2_Game_Control{2}  =  1
   1677  1128
   1678  1128		       a5 ec		      LDA	_Bit2_Game_Control
   1679  112a		       09 04		      ORA	#4
   1680  112c		       85 ec		      STA	_Bit2_Game_Control
   1681  112e				   .
   1682  112e							;
   1683  112e
   1684  112e				   .
   1685  112e							;
   1686  112e
   1687  112e				   .
   1688  112e							;
   1689  112e
   1690  112e				   .
   1691  112e							;
   1692  112e
   1693  112e				   .L086		;  goto __Start_Restart
   1694  112e
   1695  112e		       4c 0c 10 	      jmp	.__Start_Restart
   1696  1131
   1697  1131				   .
   1698  1131							;
   1699  1131
   1700  1131				   .
   1701  1131							;
   1702  1131
   1703  1131				   .
   1704  1131							;
   1705  1131
   1706  1131				   .
   1707  1131							;
   1708  1131
   1709  1131				   .
   1710  1131							;
   1711  1131
   1712  1131				   .L087		;  bank 2
   1713  1131
   1714  1131					      if	ECHO1
      3747 bytes of ROM space left in bank 1
   1715  1131					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1716  1131					      endif
   1717  1131		       00 01	   ECHO1      =	1
   1718  1fd4					      ORG	$1FF4-bscode_length
   1719  1fd4					      RORG	$1FF4-bscode_length
   1720  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1721  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1722  1fd6				  -	      stx	FASTFETCH
   1723  1fd6					      endif
   1724  1fd6		       9a		      txs
   1725  1fd7				  -	      if	bankswitch == 64
   1726  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1727  1fd7					      else
   1728  1fd7		       a9 f2		      lda	#>(start-1)
   1729  1fd9					      endif
   1730  1fd9		       48		      pha
   1731  1fda		       a9 51		      lda	#<(start-1)
   1732  1fdc		       48		      pha
   1733  1fdd		       48		      pha
   1734  1fde		       8a		      txa
   1735  1fdf		       48		      pha
   1736  1fe0		       ba		      tsx
   1737  1fe1					      if	bankswitch != 64
   1738  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1739  1fe3		       2a		      rol
   1740  1fe4		       2a		      rol
   1741  1fe5		       2a		      rol
   1742  1fe6		       2a		      rol
   1743  1fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1744  1fe9		       aa		      tax
   1745  1fea		       e8		      inx
   1746  1feb				  -	      else
   1747  1feb				  -	      lda	4,x	; get high byte of return address
   1748  1feb				  -	      tay
   1749  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1750  1feb				  -	      sta	4,x
   1751  1feb				  -	      tya
   1752  1feb				  -	      lsr
   1753  1feb				  -	      lsr
   1754  1feb				  -	      lsr
   1755  1feb				  -	      lsr
   1756  1feb				  -	      tax
   1757  1feb				  -	      inx
   1758  1feb					      endif
   1759  1feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1760  1fee		       68		      pla
   1761  1fef		       aa		      tax
   1762  1ff0		       68		      pla
   1763  1ff1		       60		      rts
   1764  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1765  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1766  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1767  1ff2					      endif
   1768  1ffc					      ORG	$1FFC
   1769  1ffc					      RORG	$1FFC
   1770  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1771  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1772  2000					      ORG	$2000
   1773  2000					      RORG	$3000
   1774  2000				   .
   1775  2000							;
   1776  2000
   1777  2000				   .
   1778  2000							;
   1779  2000
   1780  2000				   .
   1781  2000							;
   1782  2000
   1783  2000				   .
   1784  2000							;
   1785  2000
   1786  2000				   .
   1787  2000							;
   1788  2000
   1789  2000				   .
   1790  2000							;
   1791  2000
   1792  2000				   .
   1793  2000							;
   1794  2000
   1795  2000				   .
   1796  2000							;
   1797  2000
   1798  2000				   .
   1799  2000							;
   1800  2000
   1801  2000				   .
   1802  2000							;
   1803  2000
   1804  2000				   .
   1805  2000							;
   1806  2000
   1807  2000				   .__Main_Loop_Setup
   1808  2000							; __Main_Loop_Setup
   1809  2000
   1810  2000				   .
   1811  2000							;
   1812  2000
   1813  2000				   .
   1814  2000							;
   1815  2000
   1816  2000				   .
   1817  2000							;
   1818  2000
   1819  2000				   .
   1820  2000							;
   1821  2000
   1822  2000				   .
   1823  2000							;
   1824  2000
   1825  2000				   .
   1826  2000							;
   1827  2000
   1828  2000				   .
   1829  2000							;
   1830  2000
   1831  2000				   .
   1832  2000							;
   1833  2000
   1834  2000				   .
   1835  2000							;
   1836  2000
   1837  2000				   .
   1838  2000							;
   1839  2000
   1840  2000				   .L088		;  _Bit2_Game_Control{2}  =  0
   1841  2000
   1842  2000		       a5 ec		      LDA	_Bit2_Game_Control
   1843  2002		       29 fb		      AND	#251
   1844  2004		       85 ec		      STA	_Bit2_Game_Control
   1845  2006				   .
   1846  2006							;
   1847  2006
   1848  2006				   .
   1849  2006							;
   1850  2006
   1851  2006				   .
   1852  2006							;
   1853  2006
   1854  2006				   .
   1855  2006							;
   1856  2006
   1857  2006				   .
   1858  2006							;
   1859  2006
   1860  2006				   .
   1861  2006							;
   1862  2006
   1863  2006				   .
   1864  2006							;
   1865  2006
   1866  2006				   .
   1867  2006							;
   1868  2006
   1869  2006				   .
   1870  2006							;
   1871  2006
   1872  2006				   .
   1873  2006							;
   1874  2006
   1875  2006				   .
   1876  2006							;
   1877  2006
   1878  2006				   .
   1879  2006							;
   1880  2006
   1881  2006				   .
   1882  2006							;
   1883  2006
   1884  2006				   .L089		;  _Bit0_Reset_Restrainer{0}  =  1
   1885  2006
   1886  2006		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1887  2008		       09 01		      ORA	#1
   1888  200a		       85 ec		      STA	_Bit0_Reset_Restrainer
   1889  200c				   .
   1890  200c							;
   1891  200c
   1892  200c				   .
   1893  200c							;
   1894  200c
   1895  200c				   .
   1896  200c							;
   1897  200c
   1898  200c				   .
   1899  200c							;
   1900  200c
   1901  200c				   .
   1902  200c							;
   1903  200c
   1904  200c				   .
   1905  200c							;
   1906  200c
   1907  200c				   .
   1908  200c							;
   1909  200c
   1910  200c				   .
   1911  200c							;
   1912  200c
   1913  200c				   .
   1914  200c							;
   1915  200c
   1916  200c				   .
   1917  200c							;
   1918  200c
   1919  200c				   .
   1920  200c							;
   1921  200c
   1922  200c				   .
   1923  200c							;
   1924  200c
   1925  200c				   .L090		;  _Bit1_FireB_Restrainer{1}  =  1
   1926  200c
   1927  200c		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   1928  200e		       09 02		      ORA	#2
   1929  2010		       85 ec		      STA	_Bit1_FireB_Restrainer
   1930  2012				   .
   1931  2012							;
   1932  2012
   1933  2012				   .
   1934  2012							;
   1935  2012
   1936  2012				   .
   1937  2012							;
   1938  2012
   1939  2012				   .
   1940  2012							;
   1941  2012
   1942  2012				   .
   1943  2012							;
   1944  2012
   1945  2012				   .
   1946  2012							;
   1947  2012
   1948  2012				   .L091		;  player0x  =  77  :	player0y  =  53
   1949  2012
   1950  2012		       a9 4d		      LDA	#77
   1951  2014		       85 80		      STA	player0x
   1952  2016		       a9 35		      LDA	#53
   1953  2018		       85 85		      STA	player0y
   1954  201a				   .
   1955  201a							;
   1956  201a
   1957  201a				   .
   1958  201a							;
   1959  201a
   1960  201a				   .
   1961  201a							;
   1962  201a
   1963  201a				   .
   1964  201a							;
   1965  201a
   1966  201a				   .
   1967  201a							;
   1968  201a
   1969  201a				   .
   1970  201a							;
   1971  201a
   1972  201a				   .L092		;  scorecolor	=  $1C
   1973  201a
   1974  201a		       a9 1c		      LDA	#$1C
   1975  201c		       85 a3		      STA	scorecolor
   1976  201e				   .L093		;  pfscorecolor  =  $1C
   1977  201e
   1978  201e		       a9 1c		      LDA	#$1C
   1979  2020		       85 f4		      STA	pfscorecolor
   1980  2022				   .
   1981  2022							;
   1982  2022
   1983  2022				   .L094		;  pfscore1  =  %10101000
   1984  2022
   1985  2022		       a9 a8		      LDA	#%10101000
   1986  2024		       85 f2		      STA	pfscore1
   1987  2026				   .L095		;  pfscore2  =  %11111111
   1988  2026
   1989  2026		       a9 ff		      LDA	#%11111111
   1990  2028		       85 f3		      STA	pfscore2
   1991  202a				   .
   1992  202a							;
   1993  202a
   1994  202a				   .
   1995  202a							;
   1996  202a
   1997  202a				   .
   1998  202a							;
   1999  202a
   2000  202a				   .
   2001  202a							;
   2002  202a
   2003  202a				   .
   2004  202a							;
   2005  202a
   2006  202a				   .L096		;  missile1height  =  1
   2007  202a
   2008  202a		       a9 01		      LDA	#1
   2009  202c		       85 87		      STA	missile1height
   2010  202e				   .
   2011  202e							;
   2012  202e
   2013  202e				   .
   2014  202e							;
   2015  202e
   2016  202e				   .
   2017  202e							;
   2018  202e
   2019  202e				   .
   2020  202e							;
   2021  202e
   2022  202e				   .
   2023  202e							;
   2024  202e
   2025  202e				   .
   2026  202e							;
   2027  202e
   2028  202e				   .
   2029  202e							;
   2030  202e
   2031  202e				   .L097		;  _Bit3_P0_Dir_Right{3}  =  1
   2032  202e
   2033  202e		       a5 da		      LDA	_Bit3_P0_Dir_Right
   2034  2030		       09 08		      ORA	#8
   2035  2032		       85 da		      STA	_Bit3_P0_Dir_Right
   2036  2034				   .
   2037  2034							;
   2038  2034
   2039  2034				   .
   2040  2034							;
   2041  2034
   2042  2034				   .
   2043  2034							;
   2044  2034
   2045  2034				   .
   2046  2034							;
   2047  2034
   2048  2034				   .
   2049  2034							;
   2050  2034
   2051  2034				   .
   2052  2034							;
   2053  2034
   2054  2034				   .L098		;  player0:
   2055  2034
   2056  2034		       a2 84		      LDX	#<playerL098_0
   2057  2036		       86 8a		      STX	player0pointerlo
   2058  2038		       a9 f5		      LDA	#>playerL098_0
   2059  203a		       85 8b		      STA	player0pointerhi
   2060  203c		       a9 03		      LDA	#3
   2061  203e		       85 8e		      STA	player0height
   2062  2040				   .
   2063  2040							;
   2064  2040
   2065  2040				   .
   2066  2040							;
   2067  2040
   2068  2040				   .
   2069  2040							;
   2070  2040
   2071  2040				   .
   2072  2040							;
   2073  2040
   2074  2040				   .
   2075  2040							;
   2076  2040
   2077  2040				   .
   2078  2040							;
   2079  2040
   2080  2040				   .L099		;  player1:
   2081  2040
   2082  2040		       a2 88		      LDX	#<playerL099_1
   2083  2042		       86 8c		      STX	player1pointerlo
   2084  2044		       a9 f5		      LDA	#>playerL099_1
   2085  2046		       85 8d		      STA	player1pointerhi
   2086  2048		       a9 04		      LDA	#4
   2087  204a		       85 8f		      STA	player1height
   2088  204c				   .
   2089  204c							;
   2090  204c
   2091  204c				   .L0100		;  _Player_Direction_X  =  0
   2092  204c
   2093  204c		       a9 00		      LDA	#0
   2094  204e		       85 e1		      STA	_Player_Direction_X
   2095  2050				   .L0101		;  _Player_Direction_Y  =  0
   2096  2050
   2097  2050		       a9 00		      LDA	#0
   2098  2052		       85 e2		      STA	_Player_Direction_Y
   2099  2054				   .
   2100  2054							;
   2101  2054
   2102  2054				   .
   2103  2054							;
   2104  2054
   2105  2054				   .
   2106  2054							;
   2107  2054
   2108  2054				   .
   2109  2054							;
   2110  2054
   2111  2054				   .
   2112  2054							;
   2113  2054
   2114  2054				   .
   2115  2054							;
   2116  2054
   2117  2054				   .
   2118  2054							;
   2119  2054
   2120  2054				   .
   2121  2054							;
   2122  2054
   2123  2054				   .
   2124  2054							;
   2125  2054
   2126  2054				   .
   2127  2054							;
   2128  2054
   2129  2054				   .
   2130  2054							;
   2131  2054
   2132  2054				   .
   2133  2054							;
   2134  2054
   2135  2054				   .
   2136  2054							;
   2137  2054
   2138  2054				   .
   2139  2054							;
   2140  2054
   2141  2054				   .
   2142  2054							;
   2143  2054
   2144  2054				   .
   2145  2054							;
   2146  2054
   2147  2054				   .
   2148  2054							;
   2149  2054
   2150  2054				   .
   2151  2054							;
   2152  2054
   2153  2054				   .L0102		;  player1y  =   ( rand & 63 )   +  15  :  temp5  =  rand
   2154  2054
   2155  2054							; complex statement detected
   2156  2054		       a5 a2		      lda	rand
   2157  2056		       4a		      lsr
   2158  2057					      ifconst	rand16
   2159  2057		       26 ed		      rol	rand16
   2160  2059					      endif
   2161  2059		       90 02		      bcc	*+4
   2162  205b		       49 b4		      eor	#$B4
   2163  205d		       85 a2		      sta	rand
   2164  205f					      ifconst	rand16
   2165  205f		       45 ed		      eor	rand16
   2166  2061					      endif
   2167  2061		       29 3f		      AND	#63
   2168  2063		       18		      CLC
   2169  2064		       69 0f		      ADC	#15
   2170  2066		       85 86		      STA	player1y
   2171  2068		       a5 a2		      lda	rand
   2172  206a		       4a		      lsr
   2173  206b					      ifconst	rand16
   2174  206b		       26 ed		      rol	rand16
   2175  206d					      endif
   2176  206d		       90 02		      bcc	*+4
   2177  206f		       49 b4		      eor	#$B4
   2178  2071		       85 a2		      sta	rand
   2179  2073					      ifconst	rand16
   2180  2073		       45 ed		      eor	rand16
   2181  2075					      endif
   2182  2075		       85 a0		      STA	temp5
   2183  2077				   .
   2184  2077							;
   2185  2077
   2186  2077				   .L0103		;  if temp5  >  128 then player1x  =	( rand & 7 )   +  5  :	goto __Skip_Enemy_Setup
   2187  2077
   2188  2077		       a9 80		      LDA	#128
   2189  2079		       c5 a0		      CMP	temp5
   2190  207b		       b0 17		      BCS	.skipL0103
   2191  207d				   .condpart6
   2192  207d							; complex statement detected
   2193  207d		       a5 a2		      lda	rand
   2194  207f		       4a		      lsr
   2195  2080					      ifconst	rand16
   2196  2080		       26 ed		      rol	rand16
   2197  2082					      endif
   2198  2082		       90 02		      bcc	*+4
   2199  2084		       49 b4		      eor	#$B4
   2200  2086		       85 a2		      sta	rand
   2201  2088					      ifconst	rand16
   2202  2088		       45 ed		      eor	rand16
   2203  208a					      endif
   2204  208a		       29 07		      AND	#7
   2205  208c		       18		      CLC
   2206  208d		       69 05		      ADC	#5
   2207  208f		       85 81		      STA	player1x
   2208  2091		       4c a8 30 	      jmp	.__Skip_Enemy_Setup
   2209  2094
   2210  2094				   .skipL0103
   2211  2094				   .
   2212  2094							;
   2213  2094
   2214  2094				   .L0104		;  player1x  =   ( rand & 7 )	 +  140
   2215  2094
   2216  2094							; complex statement detected
   2217  2094		       a5 a2		      lda	rand
   2218  2096		       4a		      lsr
   2219  2097					      ifconst	rand16
   2220  2097		       26 ed		      rol	rand16
   2221  2099					      endif
   2222  2099		       90 02		      bcc	*+4
   2223  209b		       49 b4		      eor	#$B4
   2224  209d		       85 a2		      sta	rand
   2225  209f					      ifconst	rand16
   2226  209f		       45 ed		      eor	rand16
   2227  20a1					      endif
   2228  20a1		       29 07		      AND	#7
   2229  20a3		       18		      CLC
   2230  20a4		       69 8c		      ADC	#140
   2231  20a6		       85 81		      STA	player1x
   2232  20a8				   .
   2233  20a8							;
   2234  20a8
   2235  20a8				   .__Skip_Enemy_Setup
   2236  20a8							; __Skip_Enemy_Setup
   2237  20a8
   2238  20a8				   .
   2239  20a8							;
   2240  20a8
   2241  20a8				   .
   2242  20a8							;
   2243  20a8
   2244  20a8				   .
   2245  20a8							;
   2246  20a8
   2247  20a8				   .
   2248  20a8							;
   2249  20a8
   2250  20a8				   .
   2251  20a8							;
   2252  20a8
   2253  20a8				   .
   2254  20a8							;
   2255  20a8
   2256  20a8				   .L0105		;  playfield:
   2257  20a8
   2258  20a8				  -	      ifconst	pfres
   2259  20a8				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   2260  20a8					      else
   2261  20a8		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   2262  20aa					      endif
   2263  20aa		       4c d9 30 	      jmp	pflabel1
   2264  20ad				   PF_data1
   2265  20ad		       00 00		      .byte.b	%00000000, %00000000
   2266  20af					      if	(pfwidth>2)
   2267  20af		       00 00		      .byte.b	%00000000, %00000000
   2268  20b1					      endif
   2269  20b1		       00 00		      .byte.b	%00000000, %00000000
   2270  20b3					      if	(pfwidth>2)
   2271  20b3		       00 00		      .byte.b	%00000000, %00000000
   2272  20b5					      endif
   2273  20b5		       00 00		      .byte.b	%00000000, %00000000
   2274  20b7					      if	(pfwidth>2)
   2275  20b7		       00 7c		      .byte.b	%00000000, %01111100
   2276  20b9					      endif
   2277  20b9		       3e 00		      .byte.b	%00111110, %00000000
   2278  20bb					      if	(pfwidth>2)
   2279  20bb		       00 00		      .byte.b	%00000000, %00000000
   2280  20bd					      endif
   2281  20bd		       00 00		      .byte.b	%00000000, %00000000
   2282  20bf					      if	(pfwidth>2)
   2283  20bf		       00 00		      .byte.b	%00000000, %00000000
   2284  20c1					      endif
   2285  20c1		       00 00		      .byte.b	%00000000, %00000000
   2286  20c3					      if	(pfwidth>2)
   2287  20c3		       00 f8		      .byte.b	%00000000, %11111000
   2288  20c5					      endif
   2289  20c5		       00 00		      .byte.b	%00000000, %00000000
   2290  20c7					      if	(pfwidth>2)
   2291  20c7		       00 00		      .byte.b	%00000000, %00000000
   2292  20c9					      endif
   2293  20c9		       f8 00		      .byte.b	%11111000, %00000000
   2294  20cb					      if	(pfwidth>2)
   2295  20cb		       00 00		      .byte.b	%00000000, %00000000
   2296  20cd					      endif
   2297  20cd		       00 00		      .byte.b	%00000000, %00000000
   2298  20cf					      if	(pfwidth>2)
   2299  20cf		       00 00		      .byte.b	%00000000, %00000000
   2300  20d1					      endif
   2301  20d1		       00 c0		      .byte.b	%00000000, %11000000
   2302  20d3					      if	(pfwidth>2)
   2303  20d3		       e0 00		      .byte.b	%11100000, %00000000
   2304  20d5					      endif
   2305  20d5		       00 00		      .byte.b	%00000000, %00000000
   2306  20d7					      if	(pfwidth>2)
   2307  20d7		       00 00		      .byte.b	%00000000, %00000000
   2308  20d9					      endif
   2309  20d9				   pflabel1
   2310  20d9		       bd ad 30 	      lda	PF_data1,x
   2311  20dc		       95 a4		      sta	playfield,x
   2312  20de		       ca		      dex
   2313  20df		       10 f8		      bpl	pflabel1
   2314  20e1				   .
   2315  20e1							;
   2316  20e1
   2317  20e1				   .
   2318  20e1							;
   2319  20e1
   2320  20e1				   .
   2321  20e1							;
   2322  20e1
   2323  20e1				   .
   2324  20e1							;
   2325  20e1
   2326  20e1				   .
   2327  20e1							;
   2328  20e1
   2329  20e1				   .
   2330  20e1							;
   2331  20e1
   2332  20e1				   .L0106		;  _Bit0_BW_Mem{0}  =	0  :  if switchbw then _Bit0_BW_Mem{0}	=  1
   2333  20e1
   2334  20e1		       a5 e5		      LDA	_Bit0_BW_Mem
   2335  20e3		       29 fe		      AND	#254
   2336  20e5		       85 e5		      STA	_Bit0_BW_Mem
   2337  20e7		       a9 08		      lda	#8
   2338  20e9		       2c 82 02 	      bit	SWCHB
   2339  20ec		       d0 06		      BNE	.skipL0106
   2340  20ee				   .condpart7
   2341  20ee		       a5 e5		      LDA	_Bit0_BW_Mem
   2342  20f0		       09 01		      ORA	#1
   2343  20f2		       85 e5		      STA	_Bit0_BW_Mem
   2344  20f4				   .skipL0106
   2345  20f4				   .
   2346  20f4							;
   2347  20f4
   2348  20f4				   .
   2349  20f4							;
   2350  20f4
   2351  20f4				   .
   2352  20f4							;
   2353  20f4
   2354  20f4				   .
   2355  20f4							;
   2356  20f4
   2357  20f4				   .
   2358  20f4							;
   2359  20f4
   2360  20f4				   .
   2361  20f4							;
   2362  20f4
   2363  20f4				   .
   2364  20f4							;
   2365  20f4
   2366  20f4				   .
   2367  20f4							;
   2368  20f4
   2369  20f4				   .
   2370  20f4							;
   2371  20f4
   2372  20f4				   .L0107		;  if !_Bit3_Auto_Play{3} then score  =  0  :	goto __AP_Skip_AP_Setup
   2373  20f4
   2374  20f4		       a5 ec		      LDA	_Bit3_Auto_Play
   2375  20f6		       29 08		      AND	#8
   2376  20f8		       d0 0f		      BNE	.skipL0107
   2377  20fa				   .condpart8
   2378  20fa		       a9 00		      LDA	#$00
   2379  20fc		       85 95		      STA	score+2
   2380  20fe		       a9 00		      LDA	#$00
   2381  2100		       85 94		      STA	score+1
   2382  2102		       a9 00		      LDA	#$00
   2383  2104		       85 93		      STA	score
   2384  2106		       4c 1b 31 	      jmp	.__AP_Skip_AP_Setup
   2385  2109
   2386  2109				   .skipL0107
   2387  2109				   .
   2388  2109							;
   2389  2109
   2390  2109				   .
   2391  2109							;
   2392  2109
   2393  2109				   .
   2394  2109							;
   2395  2109
   2396  2109				   .
   2397  2109							;
   2398  2109
   2399  2109				   .L0108		;  _Score1_Mem  =  _sc1  :  _Score2_Mem  =  _sc2  :  _Score3_Mem  =  _sc3
   2400  2109
   2401  2109		       a5 93		      LDA	_sc1
   2402  210b		       85 e6		      STA	_Score1_Mem
   2403  210d		       a5 94		      LDA	_sc2
   2404  210f		       85 e7		      STA	_Score2_Mem
   2405  2111		       a5 95		      LDA	_sc3
   2406  2113		       85 e8		      STA	_Score3_Mem
   2407  2115				   .
   2408  2115							;
   2409  2115
   2410  2115				   .L0109		;  _Bit6_Swap_Scores{6}  =  0
   2411  2115
   2412  2115		       a5 ec		      LDA	_Bit6_Swap_Scores
   2413  2117		       29 bf		      AND	#191
   2414  2119		       85 ec		      STA	_Bit6_Swap_Scores
   2415  211b				   .
   2416  211b							;
   2417  211b
   2418  211b				   .__AP_Skip_AP_Setup
   2419  211b							; __AP_Skip_AP_Setup
   2420  211b
   2421  211b				   .
   2422  211b							;
   2423  211b
   2424  211b				   .
   2425  211b							;
   2426  211b
   2427  211b				   .
   2428  211b							;
   2429  211b
   2430  211b				   .
   2431  211b							;
   2432  211b
   2433  211b				   .
   2434  211b							;
   2435  211b
   2436  211b				   .
   2437  211b							;
   2438  211b
   2439  211b				   .
   2440  211b							;
   2441  211b
   2442  211b				   .
   2443  211b							;
   2444  211b
   2445  211b				   .
   2446  211b							;
   2447  211b
   2448  211b				   .
   2449  211b							;
   2450  211b
   2451  211b				   .
   2452  211b							;
   2453  211b
   2454  211b				   .__Main_Loop
   2455  211b							; __Main_Loop
   2456  211b
   2457  211b				   .
   2458  211b							;
   2459  211b
   2460  211b				   .
   2461  211b							;
   2462  211b
   2463  211b				   .
   2464  211b							;
   2465  211b
   2466  211b				   .
   2467  211b							;
   2468  211b
   2469  211b				   .
   2470  211b							;
   2471  211b
   2472  211b				   .
   2473  211b							;
   2474  211b
   2475  211b				   .
   2476  211b							;
   2477  211b
   2478  211b				   .
   2479  211b							;
   2480  211b
   2481  211b				   .
   2482  211b							;
   2483  211b
   2484  211b				   .
   2485  211b							;
   2486  211b
   2487  211b				   .
   2488  211b							;
   2489  211b
   2490  211b				   .
   2491  211b							;
   2492  211b
   2493  211b				   .
   2494  211b							;
   2495  211b
   2496  211b				   .
   2497  211b							;
   2498  211b
   2499  211b				   .
   2500  211b							;
   2501  211b
   2502  211b				   .L0110		;  pfcolors:
   2503  211b
   2504  211b		       a9 26		      lda	# $26
   2505  211d		       85 08		      sta	COLUPF
   2506  211f				  -	      ifconst	pfres
   2507  211f				  -	      lda	#>(pfcolorlabel13-131+pfres*pfwidth)
   2508  211f					      else
   2509  211f		       a9 f5		      lda	#>(pfcolorlabel13-83)
   2510  2121					      endif
   2511  2121		       85 f1		      sta	pfcolortable+1
   2512  2123				  -	      ifconst	pfres
   2513  2123				  -	      lda	#<(pfcolorlabel13-131+pfres*pfwidth)
   2514  2123					      else
   2515  2123		       a9 05		      lda	#<(pfcolorlabel13-83)
   2516  2125					      endif
   2517  2125		       85 f0		      sta	pfcolortable
   2518  2127				   .
   2519  2127							;
   2520  2127
   2521  2127				   .
   2522  2127							;
   2523  2127
   2524  2127				   .
   2525  2127							;
   2526  2127
   2527  2127				   .
   2528  2127							;
   2529  2127
   2530  2127				   .
   2531  2127							;
   2532  2127
   2533  2127				   .
   2534  2127							;
   2535  2127
   2536  2127				   .
   2537  2127							;
   2538  2127
   2539  2127				   .L0111		;  COLUP0  =  $1C  :  COLUP1  =  $3E
   2540  2127
   2541  2127		       a9 1c		      LDA	#$1C
   2542  2129		       85 06		      STA	COLUP0
   2543  212b		       a9 3e		      LDA	#$3E
   2544  212d		       85 07		      STA	COLUP1
   2545  212f				   .
   2546  212f							;
   2547  212f
   2548  212f				   .
   2549  212f							;
   2550  212f
   2551  212f				   .
   2552  212f							;
   2553  212f
   2554  212f				   .
   2555  212f							;
   2556  212f
   2557  212f				   .
   2558  212f							;
   2559  212f
   2560  212f				   .
   2561  212f							;
   2562  212f
   2563  212f				   .L0112		;  NUSIZ0  =  $30
   2564  212f
   2565  212f		       a9 30		      LDA	#$30
   2566  2131		       85 04		      STA	NUSIZ0
   2567  2133				   .L0113		;  NUSIZ1  =  $30
   2568  2133
   2569  2133		       a9 30		      LDA	#$30
   2570  2135		       85 05		      STA	NUSIZ1
   2571  2137				   .
   2572  2137							;
   2573  2137
   2574  2137				   .
   2575  2137							;
   2576  2137
   2577  2137				   .
   2578  2137							;
   2579  2137
   2580  2137				   .
   2581  2137							;
   2582  2137
   2583  2137				   .
   2584  2137							;
   2585  2137
   2586  2137				   .
   2587  2137							;
   2588  2137
   2589  2137				   .__Check_Acceleration_X_Right
   2590  2137							; __Check_Acceleration_X_Right
   2591  2137
   2592  2137				   .L0114		;  if _Player_Direction_X  <>	2 then goto __Check_Acceleration_X_Left
   2593  2137
   2594  2137		       a5 e1		      LDA	_Player_Direction_X
   2595  2139		       c9 02		      CMP	#2
   2596  213b		       f0 03		      BEQ	.skipL0114
   2597  213d				   .condpart9
   2598  213d		       4c 5c 31 	      jmp	.__Check_Acceleration_X_Left
   2599  2140
   2600  2140				   .skipL0114
   2601  2140				   .
   2602  2140							;
   2603  2140
   2604  2140				   .L0115		;  if player0x  =  160 then goto __Check_Acceleration_X_Left
   2605  2140
   2606  2140		       a5 80		      LDA	player0x
   2607  2142		       c9 a0		      CMP	#160
   2608  2144		       d0 03		      BNE	.skipL0115
   2609  2146				   .condpart10
   2610  2146		       4c 5c 31 	      jmp	.__Check_Acceleration_X_Left
   2611  2149
   2612  2149				   .skipL0115
   2613  2149				   .
   2614  2149							;
   2615  2149
   2616  2149				   .L0116		;  player0x  =  player0x  +  _Player_Acceleration_X
   2617  2149
   2618  2149		       a5 80		      LDA	player0x
   2619  214b		       18		      CLC
   2620  214c		       65 e3		      ADC	_Player_Acceleration_X
   2621  214e		       85 80		      STA	player0x
   2622  2150				   .L0117		;  _Player_Acceleration_X  =  _Player_Acceleration_X  -  1
   2623  2150
   2624  2150		       c6 e3		      DEC	_Player_Acceleration_X
   2625  2152				   .L0118		;  if _Player_Acceleration_X  =  0 then _Player_Direction_X  =  0
   2626  2152
   2627  2152		       a5 e3		      LDA	_Player_Acceleration_X
   2628  2154		       c9 00		      CMP	#0
   2629  2156		       d0 04		      BNE	.skipL0118
   2630  2158				   .condpart11
   2631  2158		       a9 00		      LDA	#0
   2632  215a		       85 e1		      STA	_Player_Direction_X
   2633  215c				   .skipL0118
   2634  215c				   .
   2635  215c							;
   2636  215c
   2637  215c				   .__Check_Acceleration_X_Left
   2638  215c							; __Check_Acceleration_X_Left
   2639  215c
   2640  215c				   .L0119		;  if _Player_Direction_X  <>	1 then goto __Check_Acceleration_Y_Up
   2641  215c
   2642  215c		       a5 e1		      LDA	_Player_Direction_X
   2643  215e		       c9 01		      CMP	#1
   2644  2160		       f0 03		      BEQ	.skipL0119
   2645  2162				   .condpart12
   2646  2162		       4c 81 31 	      jmp	.__Check_Acceleration_Y_Up
   2647  2165
   2648  2165				   .skipL0119
   2649  2165				   .
   2650  2165							;
   2651  2165
   2652  2165				   .L0120		;  if player0x  =  0 then goto __Check_Acceleration_Y_Up
   2653  2165
   2654  2165		       a5 80		      LDA	player0x
   2655  2167		       c9 00		      CMP	#0
   2656  2169		       d0 03		      BNE	.skipL0120
   2657  216b				   .condpart13
   2658  216b		       4c 81 31 	      jmp	.__Check_Acceleration_Y_Up
   2659  216e
   2660  216e				   .skipL0120
   2661  216e				   .
   2662  216e							;
   2663  216e
   2664  216e				   .L0121		;  player0x  =  player0x  -  _Player_Acceleration_X
   2665  216e
   2666  216e		       a5 80		      LDA	player0x
   2667  2170		       38		      SEC
   2668  2171		       e5 e3		      SBC	_Player_Acceleration_X
   2669  2173		       85 80		      STA	player0x
   2670  2175				   .L0122		;  _Player_Acceleration_X  =  _Player_Acceleration_X  -  1
   2671  2175
   2672  2175		       c6 e3		      DEC	_Player_Acceleration_X
   2673  2177				   .L0123		;  if _Player_Acceleration_X  =  0 then _Player_Direction_X  =  0
   2674  2177
   2675  2177		       a5 e3		      LDA	_Player_Acceleration_X
   2676  2179		       c9 00		      CMP	#0
   2677  217b		       d0 04		      BNE	.skipL0123
   2678  217d				   .condpart14
   2679  217d		       a9 00		      LDA	#0
   2680  217f		       85 e1		      STA	_Player_Direction_X
   2681  2181				   .skipL0123
   2682  2181				   .
   2683  2181							;
   2684  2181
   2685  2181				   .__Check_Acceleration_Y_Up
   2686  2181							; __Check_Acceleration_Y_Up
   2687  2181
   2688  2181				   .L0124		;  if _Player_Direction_Y  <>	1 then goto __Check_Acceleration_Y_Down
   2689  2181
   2690  2181		       a5 e2		      LDA	_Player_Direction_Y
   2691  2183		       c9 01		      CMP	#1
   2692  2185		       f0 03		      BEQ	.skipL0124
   2693  2187				   .condpart15
   2694  2187		       4c a6 31 	      jmp	.__Check_Acceleration_Y_Down
   2695  218a
   2696  218a				   .skipL0124
   2697  218a				   .
   2698  218a							;
   2699  218a
   2700  218a				   .L0125		;  if player0y  =  0 then goto __Check_Acceleration_Y_Down
   2701  218a
   2702  218a		       a5 85		      LDA	player0y
   2703  218c		       c9 00		      CMP	#0
   2704  218e		       d0 03		      BNE	.skipL0125
   2705  2190				   .condpart16
   2706  2190		       4c a6 31 	      jmp	.__Check_Acceleration_Y_Down
   2707  2193
   2708  2193				   .skipL0125
   2709  2193				   .
   2710  2193							;
   2711  2193
   2712  2193				   .L0126		;  player0y  =  player0y  -  _Player_Acceleration_Y
   2713  2193
   2714  2193		       a5 85		      LDA	player0y
   2715  2195		       38		      SEC
   2716  2196		       e5 e4		      SBC	_Player_Acceleration_Y
   2717  2198		       85 85		      STA	player0y
   2718  219a				   .L0127		;  _Player_Acceleration_Y  =  _Player_Acceleration_Y  -  1
   2719  219a
   2720  219a		       c6 e4		      DEC	_Player_Acceleration_Y
   2721  219c				   .L0128		;  if _Player_Acceleration_Y  =  0 then _Player_Direction_Y  =  0
   2722  219c
   2723  219c		       a5 e4		      LDA	_Player_Acceleration_Y
   2724  219e		       c9 00		      CMP	#0
   2725  21a0		       d0 04		      BNE	.skipL0128
   2726  21a2				   .condpart17
   2727  21a2		       a9 00		      LDA	#0
   2728  21a4		       85 e2		      STA	_Player_Direction_Y
   2729  21a6				   .skipL0128
   2730  21a6				   .
   2731  21a6							;
   2732  21a6
   2733  21a6				   .__Check_Acceleration_Y_Down
   2734  21a6							; __Check_Acceleration_Y_Down
   2735  21a6
   2736  21a6				   .L0129		;  if _Player_Direction_Y  <>	2 then goto __Check_Joystick_Movement
   2737  21a6
   2738  21a6		       a5 e2		      LDA	_Player_Direction_Y
   2739  21a8		       c9 02		      CMP	#2
   2740  21aa		       f0 03		      BEQ	.skipL0129
   2741  21ac				   .condpart18
   2742  21ac		       4c cb 31 	      jmp	.__Check_Joystick_Movement
   2743  21af
   2744  21af				   .skipL0129
   2745  21af				   .
   2746  21af							;
   2747  21af
   2748  21af				   .L0130		;  if player0y  =  120 then goto __Check_Acceleration_Y_Down
   2749  21af
   2750  21af		       a5 85		      LDA	player0y
   2751  21b1		       c9 78		      CMP	#120
   2752  21b3		       d0 03		      BNE	.skipL0130
   2753  21b5				   .condpart19
   2754  21b5		       4c a6 31 	      jmp	.__Check_Acceleration_Y_Down
   2755  21b8
   2756  21b8				   .skipL0130
   2757  21b8				   .
   2758  21b8							;
   2759  21b8
   2760  21b8				   .L0131		;  player0y  =  player0y  +  _Player_Acceleration_Y
   2761  21b8
   2762  21b8		       a5 85		      LDA	player0y
   2763  21ba		       18		      CLC
   2764  21bb		       65 e4		      ADC	_Player_Acceleration_Y
   2765  21bd		       85 85		      STA	player0y
   2766  21bf				   .L0132		;  _Player_Acceleration_Y  =  _Player_Acceleration_Y  -  1
   2767  21bf
   2768  21bf		       c6 e4		      DEC	_Player_Acceleration_Y
   2769  21c1				   .L0133		;  if _Player_Acceleration_Y  =  0 then _Player_Direction_Y  =  0
   2770  21c1
   2771  21c1		       a5 e4		      LDA	_Player_Acceleration_Y
   2772  21c3		       c9 00		      CMP	#0
   2773  21c5		       d0 04		      BNE	.skipL0133
   2774  21c7				   .condpart20
   2775  21c7		       a9 00		      LDA	#0
   2776  21c9		       85 e2		      STA	_Player_Direction_Y
   2777  21cb				   .skipL0133
   2778  21cb				   .
   2779  21cb							;
   2780  21cb
   2781  21cb				   .__Check_Joystick_Movement
   2782  21cb							; __Check_Joystick_Movement
   2783  21cb
   2784  21cb				   .
   2785  21cb							;
   2786  21cb
   2787  21cb				   .
   2788  21cb							;
   2789  21cb
   2790  21cb				   .
   2791  21cb							;
   2792  21cb
   2793  21cb				   .
   2794  21cb							;
   2795  21cb
   2796  21cb				   .
   2797  21cb							;
   2798  21cb
   2799  21cb				   .
   2800  21cb							;
   2801  21cb
   2802  21cb				   .
   2803  21cb							;
   2804  21cb
   2805  21cb				   .
   2806  21cb							;
   2807  21cb
   2808  21cb				   .L0134		;  if _Bit3_Auto_Play{3} then goto __Skip_Joystick_Precheck
   2809  21cb
   2810  21cb		       a5 ec		      LDA	_Bit3_Auto_Play
   2811  21cd		       29 08		      AND	#8
   2812  21cf		       f0 03		      BEQ	.skipL0134
   2813  21d1				   .condpart21
   2814  21d1		       4c f5 31 	      jmp	.__Skip_Joystick_Precheck
   2815  21d4
   2816  21d4				   .skipL0134
   2817  21d4				   .
   2818  21d4							;
   2819  21d4
   2820  21d4				   .
   2821  21d4							;
   2822  21d4
   2823  21d4				   .
   2824  21d4							;
   2825  21d4
   2826  21d4				   .
   2827  21d4							;
   2828  21d4
   2829  21d4				   .L0135		;  if !joy0up	&&  !joy0down  &&  !joy0left  &&  !joy0right then goto __Skip_Joystick_Precheck
   2830  21d4
   2831  21d4		       a9 10		      lda	#$10
   2832  21d6		       2c 80 02 	      bit	SWCHA
   2833  21d9		       f0 14		      BEQ	.skipL0135
   2834  21db				   .condpart22
   2835  21db		       a9 20		      lda	#$20
   2836  21dd		       2c 80 02 	      bit	SWCHA
   2837  21e0		       f0 0d		      BEQ	.skip22then
   2838  21e2				   .condpart23
   2839  21e2		       2c 80 02 	      bit	SWCHA
   2840  21e5		       50 08		      BVC	.skip23then
   2841  21e7				   .condpart24
   2842  21e7		       2c 80 02 	      bit	SWCHA
   2843  21ea		       10 03		      BPL	.skip24then
   2844  21ec				   .condpart25
   2845  21ec		       4c f5 31 	      jmp	.__Skip_Joystick_Precheck
   2846  21ef
   2847  21ef				   .skip24then
   2848  21ef				   .skip23then
   2849  21ef				   .skip22then
   2850  21ef				   .skipL0135
   2851  21ef				   .
   2852  21ef							;
   2853  21ef
   2854  21ef				   .
   2855  21ef							;
   2856  21ef
   2857  21ef				   .
   2858  21ef							;
   2859  21ef
   2860  21ef				   .
   2861  21ef							;
   2862  21ef
   2863  21ef				   .L0136		;  _BitOp_P0_M1_Dir  =  _BitOp_P0_M1_Dir  &  %11110000
   2864  21ef
   2865  21ef		       a5 da		      LDA	_BitOp_P0_M1_Dir
   2866  21f1		       29 f0		      AND	#%11110000
   2867  21f3		       85 da		      STA	_BitOp_P0_M1_Dir
   2868  21f5				   .
   2869  21f5							;
   2870  21f5
   2871  21f5				   .__Skip_Joystick_Precheck
   2872  21f5							; __Skip_Joystick_Precheck
   2873  21f5
   2874  21f5				   .
   2875  21f5							;
   2876  21f5
   2877  21f5				   .
   2878  21f5							;
   2879  21f5
   2880  21f5				   .
   2881  21f5							;
   2882  21f5
   2883  21f5				   .
   2884  21f5							;
   2885  21f5
   2886  21f5				   .
   2887  21f5							;
   2888  21f5
   2889  21f5				   .
   2890  21f5							;
   2891  21f5
   2892  21f5				   .
   2893  21f5							;
   2894  21f5
   2895  21f5				   .
   2896  21f5							;
   2897  21f5
   2898  21f5				   .
   2899  21f5							;
   2900  21f5
   2901  21f5				   .
   2902  21f5							;
   2903  21f5
   2904  21f5				   .
   2905  21f5							;
   2906  21f5
   2907  21f5				   .L0137		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_New_Dir
   2908  21f5
   2909  21f5		       a5 ec		      LDA	_Bit3_Auto_Play
   2910  21f7		       29 08		      AND	#8
   2911  21f9		       d0 03		      BNE	.skipL0137
   2912  21fb				   .condpart26
   2913  21fb		       4c b7 33 	      jmp	.__AP_Skip_New_Dir
   2914  21fe
   2915  21fe				   .skipL0137
   2916  21fe				   .
   2917  21fe							;
   2918  21fe
   2919  21fe				   .
   2920  21fe							;
   2921  21fe
   2922  21fe				   .
   2923  21fe							;
   2924  21fe
   2925  21fe				   .
   2926  21fe							;
   2927  21fe
   2928  21fe				   .L0138		;  _AP_Dir_Counter  =	_AP_Dir_Counter  +  1
   2929  21fe
   2930  21fe		       e6 df		      INC	_AP_Dir_Counter
   2931  2200				   .
   2932  2200							;
   2933  2200
   2934  2200				   .
   2935  2200							;
   2936  2200
   2937  2200				   .
   2938  2200							;
   2939  2200
   2940  2200				   .
   2941  2200							;
   2942  2200
   2943  2200				   .
   2944  2200							;
   2945  2200
   2946  2200				   .L0139		;  if _AP_Dir_Counter	>  254 then goto __Get_New_AP_Direction
   2947  2200
   2948  2200		       a9 fe		      LDA	#254
   2949  2202		       c5 df		      CMP	_AP_Dir_Counter
   2950  2204		       b0 03		      BCS	.skipL0139
   2951  2206				   .condpart27
   2952  2206		       4c 3e 32 	      jmp	.__Get_New_AP_Direction
   2953  2209
   2954  2209				   .skipL0139
   2955  2209				   .
   2956  2209							;
   2957  2209
   2958  2209				   .
   2959  2209							;
   2960  2209
   2961  2209				   .
   2962  2209							;
   2963  2209
   2964  2209				   .
   2965  2209							;
   2966  2209
   2967  2209				   .
   2968  2209							;
   2969  2209
   2970  2209				   .
   2971  2209							;
   2972  2209
   2973  2209				   .L0140		;  temp6  =   ( rand & 63 )   +  50
   2974  2209
   2975  2209							; complex statement detected
   2976  2209		       a5 a2		      lda	rand
   2977  220b		       4a		      lsr
   2978  220c					      ifconst	rand16
   2979  220c		       26 ed		      rol	rand16
   2980  220e					      endif
   2981  220e		       90 02		      bcc	*+4
   2982  2210		       49 b4		      eor	#$B4
   2983  2212		       85 a2		      sta	rand
   2984  2214					      ifconst	rand16
   2985  2214		       45 ed		      eor	rand16
   2986  2216					      endif
   2987  2216		       29 3f		      AND	#63
   2988  2218		       18		      CLC
   2989  2219		       69 32		      ADC	#50
   2990  221b		       85 a1		      STA	temp6
   2991  221d				   .
   2992  221d							;
   2993  221d
   2994  221d				   .
   2995  221d							;
   2996  221d
   2997  221d				   .
   2998  221d							;
   2999  221d
   3000  221d				   .
   3001  221d							;
   3002  221d
   3003  221d				   .L0141		;  if _AP_Dir_Counter	<  temp6 then goto __AP_Skip_New_Dir
   3004  221d
   3005  221d		       a5 df		      LDA	_AP_Dir_Counter
   3006  221f		       c5 a1		      CMP	temp6
   3007  2221		       b0 03		      BCS	.skipL0141
   3008  2223				   .condpart28
   3009  2223		       4c b7 33 	      jmp	.__AP_Skip_New_Dir
   3010  2226
   3011  2226				   .skipL0141
   3012  2226				   .
   3013  2226							;
   3014  2226
   3015  2226				   .
   3016  2226							;
   3017  2226
   3018  2226				   .
   3019  2226							;
   3020  2226
   3021  2226				   .
   3022  2226							;
   3023  2226
   3024  2226				   .L0142		;  temp5  =  rand
   3025  2226
   3026  2226		       a5 a2		      lda	rand
   3027  2228		       4a		      lsr
   3028  2229					      ifconst	rand16
   3029  2229		       26 ed		      rol	rand16
   3030  222b					      endif
   3031  222b		       90 02		      bcc	*+4
   3032  222d		       49 b4		      eor	#$B4
   3033  222f		       85 a2		      sta	rand
   3034  2231					      ifconst	rand16
   3035  2231		       45 ed		      eor	rand16
   3036  2233					      endif
   3037  2233		       85 a0		      STA	temp5
   3038  2235				   .
   3039  2235							;
   3040  2235
   3041  2235				   .
   3042  2235							;
   3043  2235
   3044  2235				   .
   3045  2235							;
   3046  2235
   3047  2235				   .
   3048  2235							;
   3049  2235
   3050  2235				   .L0143		;  if temp5  <  230 then goto __AP_Skip_New_Dir
   3051  2235
   3052  2235		       a5 a0		      LDA	temp5
   3053  2237		       c9 e6		      CMP	#230
   3054  2239		       b0 03		      BCS	.skipL0143
   3055  223b				   .condpart29
   3056  223b		       4c b7 33 	      jmp	.__AP_Skip_New_Dir
   3057  223e
   3058  223e				   .skipL0143
   3059  223e				   .
   3060  223e							;
   3061  223e
   3062  223e				   .__Get_New_AP_Direction
   3063  223e							; __Get_New_AP_Direction
   3064  223e
   3065  223e				   .
   3066  223e							;
   3067  223e
   3068  223e				   .
   3069  223e							;
   3070  223e
   3071  223e				   .
   3072  223e							;
   3073  223e
   3074  223e				   .
   3075  223e							;
   3076  223e
   3077  223e				   .
   3078  223e							;
   3079  223e
   3080  223e				   .
   3081  223e							;
   3082  223e
   3083  223e				   .
   3084  223e							;
   3085  223e
   3086  223e				   .
   3087  223e							;
   3088  223e
   3089  223e				   .
   3090  223e							;
   3091  223e
   3092  223e				   .
   3093  223e							;
   3094  223e
   3095  223e				   .
   3096  223e							;
   3097  223e
   3098  223e				   .
   3099  223e							;
   3100  223e
   3101  223e				   .
   3102  223e							;
   3103  223e
   3104  223e				   .L0144		;  _T5_AP_Dir	=   ( rand & 7 )
   3105  223e
   3106  223e							; complex statement detected
   3107  223e		       a5 a2		      lda	rand
   3108  2240		       4a		      lsr
   3109  2241					      ifconst	rand16
   3110  2241		       26 ed		      rol	rand16
   3111  2243					      endif
   3112  2243		       90 02		      bcc	*+4
   3113  2245		       49 b4		      eor	#$B4
   3114  2247		       85 a2		      sta	rand
   3115  2249					      ifconst	rand16
   3116  2249		       45 ed		      eor	rand16
   3117  224b					      endif
   3118  224b		       29 07		      AND	#7
   3119  224d		       85 a0		      STA	_T5_AP_Dir
   3120  224f				   .
   3121  224f							;
   3122  224f
   3123  224f				   .
   3124  224f							;
   3125  224f
   3126  224f				   .
   3127  224f							;
   3128  224f
   3129  224f				   .
   3130  224f							;
   3131  224f
   3132  224f				   .
   3133  224f							;
   3134  224f
   3135  224f				   .
   3136  224f							;
   3137  224f
   3138  224f				   .
   3139  224f							;
   3140  224f
   3141  224f				   .L0145		;  if _T5_AP_Dir  =  _AP_Mem_Dir then _T5_AP_Dir  =  _T5_AP_Dir  +   ( rand & 1 )   +	 ( rand & 3 )	+  2  :  if _T5_AP_Dir	>  7 then _T5_AP_Dir  =  _T5_AP_Dir  -	8
   3142  224f
   3143  224f		       a5 a0		      LDA	_T5_AP_Dir
   3144  2251		       c5 db		      CMP	_AP_Mem_Dir
   3145  2253		       d0 40		      BNE	.skipL0145
   3146  2255				   .condpart30
   3147  2255							; complex statement detected
   3148  2255		       a5 a0		      LDA	_T5_AP_Dir
   3149  2257		       48		      PHA
   3150  2258		       a5 a2		      lda	rand
   3151  225a		       4a		      lsr
   3152  225b					      ifconst	rand16
   3153  225b		       26 ed		      rol	rand16
   3154  225d					      endif
   3155  225d		       90 02		      bcc	*+4
   3156  225f		       49 b4		      eor	#$B4
   3157  2261		       85 a2		      sta	rand
   3158  2263					      ifconst	rand16
   3159  2263		       45 ed		      eor	rand16
   3160  2265					      endif
   3161  2265		       29 01		      AND	#1
   3162  2267		       ba		      TSX
   3163  2268		       e8		      INX
   3164  2269		       9a		      TXS
   3165  226a		       18		      CLC
   3166  226b		       75 00		      ADC	$00,x
   3167  226d		       48		      PHA
   3168  226e		       a5 a2		      lda	rand
   3169  2270		       4a		      lsr
   3170  2271					      ifconst	rand16
   3171  2271		       26 ed		      rol	rand16
   3172  2273					      endif
   3173  2273		       90 02		      bcc	*+4
   3174  2275		       49 b4		      eor	#$B4
   3175  2277		       85 a2		      sta	rand
   3176  2279					      ifconst	rand16
   3177  2279		       45 ed		      eor	rand16
   3178  227b					      endif
   3179  227b		       29 03		      AND	#3
   3180  227d		       ba		      TSX
   3181  227e		       e8		      INX
   3182  227f		       9a		      TXS
   3183  2280		       18		      CLC
   3184  2281		       75 00		      ADC	$00,x
   3185  2283		       18		      CLC
   3186  2284		       69 02		      ADC	#2
   3187  2286		       85 a0		      STA	_T5_AP_Dir
   3188  2288		       a9 07		      LDA	#7
   3189  228a		       c5 a0		      CMP	_T5_AP_Dir
   3190  228c		       b0 07		      BCS	.skip30then
   3191  228e				   .condpart31
   3192  228e		       a5 a0		      LDA	_T5_AP_Dir
   3193  2290		       38		      SEC
   3194  2291		       e9 08		      SBC	#8
   3195  2293		       85 a0		      STA	_T5_AP_Dir
   3196  2295				   .skip30then
   3197  2295				   .skipL0145
   3198  2295				   .
   3199  2295							;
   3200  2295
   3201  2295				   .
   3202  2295							;
   3203  2295
   3204  2295				   .
   3205  2295							;
   3206  2295
   3207  2295				   .
   3208  2295							;
   3209  2295
   3210  2295				   .L0146		;  if player0y  >  85 then _T5_AP_Dir	=  1  :  temp6	=  rand  :  if temp6  >  128 then _T5_AP_Dir  =  7
   3211  2295
   3212  2295		       a9 55		      LDA	#85
   3213  2297		       c5 85		      CMP	player0y
   3214  2299		       b0 1d		      BCS	.skipL0146
   3215  229b				   .condpart32
   3216  229b		       a9 01		      LDA	#1
   3217  229d		       85 a0		      STA	_T5_AP_Dir
   3218  229f		       a5 a2		      lda	rand
   3219  22a1		       4a		      lsr
   3220  22a2					      ifconst	rand16
   3221  22a2		       26 ed		      rol	rand16
   3222  22a4					      endif
   3223  22a4		       90 02		      bcc	*+4
   3224  22a6		       49 b4		      eor	#$B4
   3225  22a8		       85 a2		      sta	rand
   3226  22aa					      ifconst	rand16
   3227  22aa		       45 ed		      eor	rand16
   3228  22ac					      endif
   3229  22ac		       85 a1		      STA	temp6
   3230  22ae		       a9 80		      LDA	#128
   3231  22b0		       c5 a1		      CMP	temp6
   3232  22b2		       b0 04		      BCS	.skip32then
   3233  22b4				   .condpart33
   3234  22b4		       a9 07		      LDA	#7
   3235  22b6		       85 a0		      STA	_T5_AP_Dir
   3236  22b8				   .skip32then
   3237  22b8				   .skipL0146
   3238  22b8				   .
   3239  22b8							;
   3240  22b8
   3241  22b8				   .
   3242  22b8							;
   3243  22b8
   3244  22b8				   .
   3245  22b8							;
   3246  22b8
   3247  22b8				   .
   3248  22b8							;
   3249  22b8
   3250  22b8				   .L0147		;  if player0y  <  12 then _T5_AP_Dir	=  3  :  temp6	=  rand  :  if temp6  >  128 then _T5_AP_Dir  =  5
   3251  22b8
   3252  22b8		       a5 85		      LDA	player0y
   3253  22ba		       c9 0c		      CMP	#12
   3254  22bc		       b0 1d		      BCS	.skipL0147
   3255  22be				   .condpart34
   3256  22be		       a9 03		      LDA	#3
   3257  22c0		       85 a0		      STA	_T5_AP_Dir
   3258  22c2		       a5 a2		      lda	rand
   3259  22c4		       4a		      lsr
   3260  22c5					      ifconst	rand16
   3261  22c5		       26 ed		      rol	rand16
   3262  22c7					      endif
   3263  22c7		       90 02		      bcc	*+4
   3264  22c9		       49 b4		      eor	#$B4
   3265  22cb		       85 a2		      sta	rand
   3266  22cd					      ifconst	rand16
   3267  22cd		       45 ed		      eor	rand16
   3268  22cf					      endif
   3269  22cf		       85 a1		      STA	temp6
   3270  22d1		       a9 80		      LDA	#128
   3271  22d3		       c5 a1		      CMP	temp6
   3272  22d5		       b0 04		      BCS	.skip34then
   3273  22d7				   .condpart35
   3274  22d7		       a9 05		      LDA	#5
   3275  22d9		       85 a0		      STA	_T5_AP_Dir
   3276  22db				   .skip34then
   3277  22db				   .skipL0147
   3278  22db				   .
   3279  22db							;
   3280  22db
   3281  22db				   .
   3282  22db							;
   3283  22db
   3284  22db				   .
   3285  22db							;
   3286  22db
   3287  22db				   .
   3288  22db							;
   3289  22db
   3290  22db				   .L0148		;  if player0x  >  148 then _T5_AP_Dir  =  7  :  temp6  =  rand  :  if temp6  >  128 then _T5_AP_Dir  =  5
   3291  22db
   3292  22db		       a9 94		      LDA	#148
   3293  22dd		       c5 80		      CMP	player0x
   3294  22df		       b0 1d		      BCS	.skipL0148
   3295  22e1				   .condpart36
   3296  22e1		       a9 07		      LDA	#7
   3297  22e3		       85 a0		      STA	_T5_AP_Dir
   3298  22e5		       a5 a2		      lda	rand
   3299  22e7		       4a		      lsr
   3300  22e8					      ifconst	rand16
   3301  22e8		       26 ed		      rol	rand16
   3302  22ea					      endif
   3303  22ea		       90 02		      bcc	*+4
   3304  22ec		       49 b4		      eor	#$B4
   3305  22ee		       85 a2		      sta	rand
   3306  22f0					      ifconst	rand16
   3307  22f0		       45 ed		      eor	rand16
   3308  22f2					      endif
   3309  22f2		       85 a1		      STA	temp6
   3310  22f4		       a9 80		      LDA	#128
   3311  22f6		       c5 a1		      CMP	temp6
   3312  22f8		       b0 04		      BCS	.skip36then
   3313  22fa				   .condpart37
   3314  22fa		       a9 05		      LDA	#5
   3315  22fc		       85 a0		      STA	_T5_AP_Dir
   3316  22fe				   .skip36then
   3317  22fe				   .skipL0148
   3318  22fe				   .
   3319  22fe							;
   3320  22fe
   3321  22fe				   .
   3322  22fe							;
   3323  22fe
   3324  22fe				   .
   3325  22fe							;
   3326  22fe
   3327  22fe				   .
   3328  22fe							;
   3329  22fe
   3330  22fe				   .L0149		;  if player0x  <  4 then _T5_AP_Dir  =  1  :	temp6  =  rand	:  if temp6  >	128 then _T5_AP_Dir  =	3
   3331  22fe
   3332  22fe		       a5 80		      LDA	player0x
   3333  2300		       c9 04		      CMP	#4
   3334  2302		       b0 1d		      BCS	.skipL0149
   3335  2304				   .condpart38
   3336  2304		       a9 01		      LDA	#1
   3337  2306		       85 a0		      STA	_T5_AP_Dir
   3338  2308		       a5 a2		      lda	rand
   3339  230a		       4a		      lsr
   3340  230b					      ifconst	rand16
   3341  230b		       26 ed		      rol	rand16
   3342  230d					      endif
   3343  230d		       90 02		      bcc	*+4
   3344  230f		       49 b4		      eor	#$B4
   3345  2311		       85 a2		      sta	rand
   3346  2313					      ifconst	rand16
   3347  2313		       45 ed		      eor	rand16
   3348  2315					      endif
   3349  2315		       85 a1		      STA	temp6
   3350  2317		       a9 80		      LDA	#128
   3351  2319		       c5 a1		      CMP	temp6
   3352  231b		       b0 04		      BCS	.skip38then
   3353  231d				   .condpart39
   3354  231d		       a9 03		      LDA	#3
   3355  231f		       85 a0		      STA	_T5_AP_Dir
   3356  2321				   .skip38then
   3357  2321				   .skipL0149
   3358  2321				   .
   3359  2321							;
   3360  2321
   3361  2321				   .
   3362  2321							;
   3363  2321
   3364  2321				   .
   3365  2321							;
   3366  2321
   3367  2321				   .
   3368  2321							;
   3369  2321
   3370  2321				   .
   3371  2321							;
   3372  2321
   3373  2321				   .
   3374  2321							;
   3375  2321
   3376  2321				   .L0150		;  _AP_Mem_Dir  =  _T5_AP_Dir	+  4  :  if _AP_Mem_Dir  >  7 then _AP_Mem_Dir	=  _AP_Mem_Dir	-  8
   3377  2321
   3378  2321		       a5 a0		      LDA	_T5_AP_Dir
   3379  2323		       18		      CLC
   3380  2324		       69 04		      ADC	#4
   3381  2326		       85 db		      STA	_AP_Mem_Dir
   3382  2328		       a9 07		      LDA	#7
   3383  232a		       c5 db		      CMP	_AP_Mem_Dir
   3384  232c		       b0 07		      BCS	.skipL0150
   3385  232e				   .condpart40
   3386  232e		       a5 db		      LDA	_AP_Mem_Dir
   3387  2330		       38		      SEC
   3388  2331		       e9 08		      SBC	#8
   3389  2333		       85 db		      STA	_AP_Mem_Dir
   3390  2335				   .skipL0150
   3391  2335				   .
   3392  2335							;
   3393  2335
   3394  2335				   .
   3395  2335							;
   3396  2335
   3397  2335				   .
   3398  2335							;
   3399  2335
   3400  2335				   .
   3401  2335							;
   3402  2335
   3403  2335				   .L0151		;  _AP_Dir_Counter  =	0  :  _BitOp_P0_M1_Dir	=  _BitOp_P0_M1_Dir  &	%11110000
   3404  2335
   3405  2335		       a9 00		      LDA	#0
   3406  2337		       85 df		      STA	_AP_Dir_Counter
   3407  2339		       a5 da		      LDA	_BitOp_P0_M1_Dir
   3408  233b		       29 f0		      AND	#%11110000
   3409  233d		       85 da		      STA	_BitOp_P0_M1_Dir
   3410  233f				   .
   3411  233f							;
   3412  233f
   3413  233f				   .
   3414  233f							;
   3415  233f
   3416  233f				   .
   3417  233f							;
   3418  233f
   3419  233f				   .
   3420  233f							;
   3421  233f
   3422  233f				   .L0152		;  if _T5_AP_Dir  =  0 then _Bit0_P0_Dir_Up{0}  =  1
   3423  233f
   3424  233f		       a5 a0		      LDA	_T5_AP_Dir
   3425  2341		       c9 00		      CMP	#0
   3426  2343		       d0 06		      BNE	.skipL0152
   3427  2345				   .condpart41
   3428  2345		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3429  2347		       09 01		      ORA	#1
   3430  2349		       85 da		      STA	_Bit0_P0_Dir_Up
   3431  234b				   .skipL0152
   3432  234b				   .L0153		;  if _T5_AP_Dir  =  1 then _Bit0_P0_Dir_Up{0}  =  1  :  _Bit3_P0_Dir_Right{3}  =  1
   3433  234b
   3434  234b		       a5 a0		      LDA	_T5_AP_Dir
   3435  234d		       c9 01		      CMP	#1
   3436  234f		       d0 0c		      BNE	.skipL0153
   3437  2351				   .condpart42
   3438  2351		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3439  2353		       09 01		      ORA	#1
   3440  2355		       85 da		      STA	_Bit0_P0_Dir_Up
   3441  2357		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3442  2359		       09 08		      ORA	#8
   3443  235b		       85 da		      STA	_Bit3_P0_Dir_Right
   3444  235d				   .skipL0153
   3445  235d				   .L0154		;  if _T5_AP_Dir  =  2 then _Bit3_P0_Dir_Right{3}  =  1
   3446  235d
   3447  235d		       a5 a0		      LDA	_T5_AP_Dir
   3448  235f		       c9 02		      CMP	#2
   3449  2361		       d0 06		      BNE	.skipL0154
   3450  2363				   .condpart43
   3451  2363		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3452  2365		       09 08		      ORA	#8
   3453  2367		       85 da		      STA	_Bit3_P0_Dir_Right
   3454  2369				   .skipL0154
   3455  2369				   .L0155		;  if _T5_AP_Dir  =  3 then _Bit1_P0_Dir_Down{1}  =  1  :  _Bit3_P0_Dir_Right{3}  =  1
   3456  2369
   3457  2369		       a5 a0		      LDA	_T5_AP_Dir
   3458  236b		       c9 03		      CMP	#3
   3459  236d		       d0 0c		      BNE	.skipL0155
   3460  236f				   .condpart44
   3461  236f		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3462  2371		       09 02		      ORA	#2
   3463  2373		       85 da		      STA	_Bit1_P0_Dir_Down
   3464  2375		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3465  2377		       09 08		      ORA	#8
   3466  2379		       85 da		      STA	_Bit3_P0_Dir_Right
   3467  237b				   .skipL0155
   3468  237b				   .L0156		;  if _T5_AP_Dir  =  4 then _Bit1_P0_Dir_Down{1}  =  1
   3469  237b
   3470  237b		       a5 a0		      LDA	_T5_AP_Dir
   3471  237d		       c9 04		      CMP	#4
   3472  237f		       d0 06		      BNE	.skipL0156
   3473  2381				   .condpart45
   3474  2381		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3475  2383		       09 02		      ORA	#2
   3476  2385		       85 da		      STA	_Bit1_P0_Dir_Down
   3477  2387				   .skipL0156
   3478  2387				   .L0157		;  if _T5_AP_Dir  =  5 then _Bit1_P0_Dir_Down{1}  =  1  :  _Bit2_P0_Dir_Left{2}  =  1
   3479  2387
   3480  2387		       a5 a0		      LDA	_T5_AP_Dir
   3481  2389		       c9 05		      CMP	#5
   3482  238b		       d0 0c		      BNE	.skipL0157
   3483  238d				   .condpart46
   3484  238d		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3485  238f		       09 02		      ORA	#2
   3486  2391		       85 da		      STA	_Bit1_P0_Dir_Down
   3487  2393		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3488  2395		       09 04		      ORA	#4
   3489  2397		       85 da		      STA	_Bit2_P0_Dir_Left
   3490  2399				   .skipL0157
   3491  2399				   .L0158		;  if _T5_AP_Dir  =  6 then _Bit2_P0_Dir_Left{2}  =  1
   3492  2399
   3493  2399		       a5 a0		      LDA	_T5_AP_Dir
   3494  239b		       c9 06		      CMP	#6
   3495  239d		       d0 06		      BNE	.skipL0158
   3496  239f				   .condpart47
   3497  239f		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3498  23a1		       09 04		      ORA	#4
   3499  23a3		       85 da		      STA	_Bit2_P0_Dir_Left
   3500  23a5				   .skipL0158
   3501  23a5				   .L0159		;  if _T5_AP_Dir  =  7 then _Bit0_P0_Dir_Up{0}  =  1  :  _Bit2_P0_Dir_Left{2}	=  1
   3502  23a5
   3503  23a5		       a5 a0		      LDA	_T5_AP_Dir
   3504  23a7		       c9 07		      CMP	#7
   3505  23a9		       d0 0c		      BNE	.skipL0159
   3506  23ab				   .condpart48
   3507  23ab		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3508  23ad		       09 01		      ORA	#1
   3509  23af		       85 da		      STA	_Bit0_P0_Dir_Up
   3510  23b1		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3511  23b3		       09 04		      ORA	#4
   3512  23b5		       85 da		      STA	_Bit2_P0_Dir_Left
   3513  23b7				   .skipL0159
   3514  23b7				   .
   3515  23b7							;
   3516  23b7
   3517  23b7				   .
   3518  23b7							;
   3519  23b7
   3520  23b7				   .
   3521  23b7							;
   3522  23b7
   3523  23b7				   .
   3524  23b7							;
   3525  23b7
   3526  23b7				   .__AP_Skip_New_Dir
   3527  23b7							; __AP_Skip_New_Dir
   3528  23b7
   3529  23b7				   .
   3530  23b7							;
   3531  23b7
   3532  23b7				   .
   3533  23b7							;
   3534  23b7
   3535  23b7				   .
   3536  23b7							;
   3537  23b7
   3538  23b7				   .
   3539  23b7							;
   3540  23b7
   3541  23b7				   .
   3542  23b7							;
   3543  23b7
   3544  23b7				   .
   3545  23b7							;
   3546  23b7
   3547  23b7				   .
   3548  23b7							;
   3549  23b7
   3550  23b7				   .
   3551  23b7							;
   3552  23b7
   3553  23b7				   .
   3554  23b7							;
   3555  23b7
   3556  23b7				   .
   3557  23b7							;
   3558  23b7
   3559  23b7				   .
   3560  23b7							;
   3561  23b7
   3562  23b7				   .L0160		;  if _Bit3_Auto_Play{3}  &&  _Bit0_P0_Dir_Up{0} then goto __AP_Move_Up
   3563  23b7
   3564  23b7		       a5 ec		      LDA	_Bit3_Auto_Play
   3565  23b9		       29 08		      AND	#8
   3566  23bb		       f0 08		      BEQ	.skipL0160
   3567  23bd				   .condpart49
   3568  23bd		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3569  23bf		       4a		      LSR
   3570  23c0		       90 03		      BCC	.skip49then
   3571  23c2				   .condpart50
   3572  23c2		       4c d5 33 	      jmp	.__AP_Move_Up
   3573  23c5
   3574  23c5				   .skip49then
   3575  23c5				   .skipL0160
   3576  23c5				   .
   3577  23c5							;
   3578  23c5
   3579  23c5				   .
   3580  23c5							;
   3581  23c5
   3582  23c5				   .
   3583  23c5							;
   3584  23c5
   3585  23c5				   .
   3586  23c5							;
   3587  23c5
   3588  23c5				   .L0161		;  if !joy0up then goto __Skip_Joy0_Up
   3589  23c5
   3590  23c5		       a9 10		      lda	#$10
   3591  23c7		       2c 80 02 	      bit	SWCHA
   3592  23ca		       f0 03		      BEQ	.skipL0161
   3593  23cc				   .condpart51
   3594  23cc		       4c 84 34 	      jmp	.__Skip_Joy0_Up
   3595  23cf
   3596  23cf				   .skipL0161
   3597  23cf				   .
   3598  23cf							;
   3599  23cf
   3600  23cf				   .
   3601  23cf							;
   3602  23cf
   3603  23cf				   .
   3604  23cf							;
   3605  23cf
   3606  23cf				   .
   3607  23cf							;
   3608  23cf
   3609  23cf				   .L0162		;  _Bit0_P0_Dir_Up{0}	=  1
   3610  23cf
   3611  23cf		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3612  23d1		       09 01		      ORA	#1
   3613  23d3		       85 da		      STA	_Bit0_P0_Dir_Up
   3614  23d5				   .
   3615  23d5							;
   3616  23d5
   3617  23d5				   .__AP_Move_Up
   3618  23d5							; __AP_Move_Up
   3619  23d5
   3620  23d5				   .
   3621  23d5							;
   3622  23d5
   3623  23d5				   .
   3624  23d5							;
   3625  23d5
   3626  23d5				   .
   3627  23d5							;
   3628  23d5
   3629  23d5				   .
   3630  23d5							;
   3631  23d5
   3632  23d5				   .L0163		;  if player0y  <=  _P_Edge_Top then goto __Skip_Joy0_Up
   3633  23d5
   3634  23d5		       a9 09		      LDA	#_P_Edge_Top
   3635  23d7		       c5 85		      CMP	player0y
   3636  23d9		       90 03		      BCC	.skipL0163
   3637  23db				   .condpart52
   3638  23db		       4c 84 34 	      jmp	.__Skip_Joy0_Up
   3639  23de
   3640  23de				   .skipL0163
   3641  23de				   .
   3642  23de							;
   3643  23de
   3644  23de				   .
   3645  23de							;
   3646  23de
   3647  23de				   .
   3648  23de							;
   3649  23de
   3650  23de				   .
   3651  23de							;
   3652  23de
   3653  23de				   .L0164		;  temp5  =   ( player0x - 10 )  / 4
   3654  23de
   3655  23de							; complex statement detected
   3656  23de		       a5 80		      LDA	player0x
   3657  23e0		       38		      SEC
   3658  23e1		       e9 0a		      SBC	#10
   3659  23e3		       4a		      lsr
   3660  23e4		       4a		      lsr
   3661  23e5		       85 a0		      STA	temp5
   3662  23e7				   .
   3663  23e7							;
   3664  23e7
   3665  23e7				   .L0165		;  temp4  =   ( player0x - 17 )  / 4
   3666  23e7
   3667  23e7							; complex statement detected
   3668  23e7		       a5 80		      LDA	player0x
   3669  23e9		       38		      SEC
   3670  23ea		       e9 11		      SBC	#17
   3671  23ec		       4a		      lsr
   3672  23ed		       4a		      lsr
   3673  23ee		       85 9f		      STA	temp4
   3674  23f0				   .
   3675  23f0							;
   3676  23f0
   3677  23f0				   .L0166		;  temp3  =  temp5  -	1
   3678  23f0
   3679  23f0		       a5 a0		      LDA	temp5
   3680  23f2		       38		      SEC
   3681  23f3		       e9 01		      SBC	#1
   3682  23f5		       85 9e		      STA	temp3
   3683  23f7				   .
   3684  23f7							;
   3685  23f7
   3686  23f7				   .L0167		;  temp6  =   ( player0y - 9 )  / 8
   3687  23f7
   3688  23f7							; complex statement detected
   3689  23f7		       a5 85		      LDA	player0y
   3690  23f9		       38		      SEC
   3691  23fa		       e9 09		      SBC	#9
   3692  23fc		       4a		      lsr
   3693  23fd		       4a		      lsr
   3694  23fe		       4a		      lsr
   3695  23ff		       85 a1		      STA	temp6
   3696  2401				   .
   3697  2401							;
   3698  2401
   3699  2401				   .L0168		;  if temp5  <  34 then if pfread ( temp5 , temp6 )  then goto __Skip_Joy0_Up
   3700  2401
   3701  2401		       a5 a0		      LDA	temp5
   3702  2403		       c9 22		      CMP	#34
   3703  2405		       b0 21		      BCS	.skipL0168
   3704  2407				   .condpart53
   3705  2407		       a5 a0		      LDA	temp5
   3706  2409		       a4 a1		      LDY	temp6
   3707  240b		       85 ee		      sta	temp7
   3708  240d		       a9 34		      lda	#>(ret_point2-1)
   3709  240f		       48		      pha
   3710  2410		       a9 22		      lda	#<(ret_point2-1)
   3711  2412		       48		      pha
   3712  2413		       a9 f2		      lda	#>(pfread-1)
   3713  2415		       48		      pha
   3714  2416		       a9 ab		      lda	#<(pfread-1)
   3715  2418		       48		      pha
   3716  2419		       a5 ee		      lda	temp7
   3717  241b		       48		      pha
   3718  241c		       8a		      txa
   3719  241d		       48		      pha
   3720  241e		       a2 08		      ldx	#8
   3721  2420		       4c eb ff 	      jmp	BS_jsr
   3722  2423				   ret_point2
   3723  2423		       d0 03		      BNE	.skip53then
   3724  2425				   .condpart54
   3725  2425		       4c 84 34 	      jmp	.__Skip_Joy0_Up
   3726  2428
   3727  2428				   .skip53then
   3728  2428				   .skipL0168
   3729  2428				   .
   3730  2428							;
   3731  2428
   3732  2428				   .L0169		;  if temp4  <  34 then if pfread ( temp4 , temp6 )  then goto __Skip_Joy0_Up
   3733  2428
   3734  2428		       a5 9f		      LDA	temp4
   3735  242a		       c9 22		      CMP	#34
   3736  242c		       b0 21		      BCS	.skipL0169
   3737  242e				   .condpart55
   3738  242e		       a5 9f		      LDA	temp4
   3739  2430		       a4 a1		      LDY	temp6
   3740  2432		       85 ee		      sta	temp7
   3741  2434		       a9 34		      lda	#>(ret_point3-1)
   3742  2436		       48		      pha
   3743  2437		       a9 49		      lda	#<(ret_point3-1)
   3744  2439		       48		      pha
   3745  243a		       a9 f2		      lda	#>(pfread-1)
   3746  243c		       48		      pha
   3747  243d		       a9 ab		      lda	#<(pfread-1)
   3748  243f		       48		      pha
   3749  2440		       a5 ee		      lda	temp7
   3750  2442		       48		      pha
   3751  2443		       8a		      txa
   3752  2444		       48		      pha
   3753  2445		       a2 08		      ldx	#8
   3754  2447		       4c eb ff 	      jmp	BS_jsr
   3755  244a				   ret_point3
   3756  244a		       d0 03		      BNE	.skip55then
   3757  244c				   .condpart56
   3758  244c		       4c 84 34 	      jmp	.__Skip_Joy0_Up
   3759  244f
   3760  244f				   .skip55then
   3761  244f				   .skipL0169
   3762  244f				   .
   3763  244f							;
   3764  244f
   3765  244f				   .L0170		;  if temp3  <  34 then if pfread ( temp3 , temp6 )  then goto __Skip_Joy0_Up
   3766  244f
   3767  244f		       a5 9e		      LDA	temp3
   3768  2451		       c9 22		      CMP	#34
   3769  2453		       b0 21		      BCS	.skipL0170
   3770  2455				   .condpart57
   3771  2455		       a5 9e		      LDA	temp3
   3772  2457		       a4 a1		      LDY	temp6
   3773  2459		       85 ee		      sta	temp7
   3774  245b		       a9 34		      lda	#>(ret_point4-1)
   3775  245d		       48		      pha
   3776  245e		       a9 70		      lda	#<(ret_point4-1)
   3777  2460		       48		      pha
   3778  2461		       a9 f2		      lda	#>(pfread-1)
   3779  2463		       48		      pha
   3780  2464		       a9 ab		      lda	#<(pfread-1)
   3781  2466		       48		      pha
   3782  2467		       a5 ee		      lda	temp7
   3783  2469		       48		      pha
   3784  246a		       8a		      txa
   3785  246b		       48		      pha
   3786  246c		       a2 08		      ldx	#8
   3787  246e		       4c eb ff 	      jmp	BS_jsr
   3788  2471				   ret_point4
   3789  2471		       d0 03		      BNE	.skip57then
   3790  2473				   .condpart58
   3791  2473		       4c 84 34 	      jmp	.__Skip_Joy0_Up
   3792  2476
   3793  2476				   .skip57then
   3794  2476				   .skipL0170
   3795  2476				   .
   3796  2476							;
   3797  2476
   3798  2476				   .
   3799  2476							;
   3800  2476
   3801  2476				   .
   3802  2476							;
   3803  2476
   3804  2476				   .
   3805  2476							;
   3806  2476
   3807  2476				   .L0171		;  player0y  =  player0y  -  1
   3808  2476
   3809  2476		       c6 85		      DEC	player0y
   3810  2478				   .
   3811  2478							;
   3812  2478
   3813  2478				   .L0172		;  _Player_Direction_Y  =  1
   3814  2478
   3815  2478		       a9 01		      LDA	#1
   3816  247a		       85 e2		      STA	_Player_Direction_Y
   3817  247c				   .
   3818  247c							;
   3819  247c
   3820  247c				   .L0173		;  if _Player_Acceleration_Y  <  30 then _Player_Acceleration_Y  =  _Player_Acceleration_Y  +	1
   3821  247c
   3822  247c		       a5 e4		      LDA	_Player_Acceleration_Y
   3823  247e		       c9 1e		      CMP	#30
   3824  2480		       b0 02		      BCS	.skipL0173
   3825  2482				   .condpart59
   3826  2482		       e6 e4		      INC	_Player_Acceleration_Y
   3827  2484				   .skipL0173
   3828  2484				   .
   3829  2484							;
   3830  2484
   3831  2484				   .__Skip_Joy0_Up
   3832  2484							; __Skip_Joy0_Up
   3833  2484
   3834  2484				   .
   3835  2484							;
   3836  2484
   3837  2484				   .
   3838  2484							;
   3839  2484
   3840  2484				   .
   3841  2484							;
   3842  2484
   3843  2484				   .
   3844  2484							;
   3845  2484
   3846  2484				   .
   3847  2484							;
   3848  2484
   3849  2484				   .
   3850  2484							;
   3851  2484
   3852  2484				   .
   3853  2484							;
   3854  2484
   3855  2484				   .
   3856  2484							;
   3857  2484
   3858  2484				   .
   3859  2484							;
   3860  2484
   3861  2484				   .
   3862  2484							;
   3863  2484
   3864  2484				   .L0174		;  if _Bit3_Auto_Play{3}  &&  _Bit1_P0_Dir_Down{1} then goto __AP_Move_Down
   3865  2484
   3866  2484		       a5 ec		      LDA	_Bit3_Auto_Play
   3867  2486		       29 08		      AND	#8
   3868  2488		       f0 09		      BEQ	.skipL0174
   3869  248a				   .condpart60
   3870  248a		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3871  248c		       29 02		      AND	#2
   3872  248e		       f0 03		      BEQ	.skip60then
   3873  2490				   .condpart61
   3874  2490		       4c a3 34 	      jmp	.__AP_Move_Down
   3875  2493
   3876  2493				   .skip60then
   3877  2493				   .skipL0174
   3878  2493				   .
   3879  2493							;
   3880  2493
   3881  2493				   .
   3882  2493							;
   3883  2493
   3884  2493				   .
   3885  2493							;
   3886  2493
   3887  2493				   .
   3888  2493							;
   3889  2493
   3890  2493				   .L0175		;  if !joy0down then goto __Skip_Joy0_Down
   3891  2493
   3892  2493		       a9 20		      lda	#$20
   3893  2495		       2c 80 02 	      bit	SWCHA
   3894  2498		       f0 03		      BEQ	.skipL0175
   3895  249a				   .condpart62
   3896  249a		       4c 52 35 	      jmp	.__Skip_Joy0_Down
   3897  249d
   3898  249d				   .skipL0175
   3899  249d				   .
   3900  249d							;
   3901  249d
   3902  249d				   .
   3903  249d							;
   3904  249d
   3905  249d				   .
   3906  249d							;
   3907  249d
   3908  249d				   .
   3909  249d							;
   3910  249d
   3911  249d				   .L0176		;  _Bit1_P0_Dir_Down{1}  =  1
   3912  249d
   3913  249d		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3914  249f		       09 02		      ORA	#2
   3915  24a1		       85 da		      STA	_Bit1_P0_Dir_Down
   3916  24a3				   .
   3917  24a3							;
   3918  24a3
   3919  24a3				   .__AP_Move_Down
   3920  24a3							; __AP_Move_Down
   3921  24a3
   3922  24a3				   .
   3923  24a3							;
   3924  24a3
   3925  24a3				   .
   3926  24a3							;
   3927  24a3
   3928  24a3				   .
   3929  24a3							;
   3930  24a3
   3931  24a3				   .
   3932  24a3							;
   3933  24a3
   3934  24a3				   .L0177		;  if player0y  >=  _P_Edge_Bottom then goto __Skip_Joy0_Down
   3935  24a3
   3936  24a3		       a5 85		      LDA	player0y
   3937  24a5		       c9 58		      CMP	#_P_Edge_Bottom
   3938  24a7		       90 03		      BCC	.skipL0177
   3939  24a9				   .condpart63
   3940  24a9		       4c 52 35 	      jmp	.__Skip_Joy0_Down
   3941  24ac
   3942  24ac				   .skipL0177
   3943  24ac				   .
   3944  24ac							;
   3945  24ac
   3946  24ac				   .
   3947  24ac							;
   3948  24ac
   3949  24ac				   .
   3950  24ac							;
   3951  24ac
   3952  24ac				   .
   3953  24ac							;
   3954  24ac
   3955  24ac				   .L0178		;  temp5  =   ( player0x - 10 )  / 4
   3956  24ac
   3957  24ac							; complex statement detected
   3958  24ac		       a5 80		      LDA	player0x
   3959  24ae		       38		      SEC
   3960  24af		       e9 0a		      SBC	#10
   3961  24b1		       4a		      lsr
   3962  24b2		       4a		      lsr
   3963  24b3		       85 a0		      STA	temp5
   3964  24b5				   .
   3965  24b5							;
   3966  24b5
   3967  24b5				   .L0179		;  temp4  =   ( player0x - 17 )  / 4
   3968  24b5
   3969  24b5							; complex statement detected
   3970  24b5		       a5 80		      LDA	player0x
   3971  24b7		       38		      SEC
   3972  24b8		       e9 11		      SBC	#17
   3973  24ba		       4a		      lsr
   3974  24bb		       4a		      lsr
   3975  24bc		       85 9f		      STA	temp4
   3976  24be				   .
   3977  24be							;
   3978  24be
   3979  24be				   .L0180		;  temp3  =  temp5  -	1
   3980  24be
   3981  24be		       a5 a0		      LDA	temp5
   3982  24c0		       38		      SEC
   3983  24c1		       e9 01		      SBC	#1
   3984  24c3		       85 9e		      STA	temp3
   3985  24c5				   .
   3986  24c5							;
   3987  24c5
   3988  24c5				   .L0181		;  temp6  =   ( player0y + 1 )  / 8
   3989  24c5
   3990  24c5							; complex statement detected
   3991  24c5		       a5 85		      LDA	player0y
   3992  24c7		       18		      CLC
   3993  24c8		       69 01		      ADC	#1
   3994  24ca		       4a		      lsr
   3995  24cb		       4a		      lsr
   3996  24cc		       4a		      lsr
   3997  24cd		       85 a1		      STA	temp6
   3998  24cf				   .
   3999  24cf							;
   4000  24cf
   4001  24cf				   .L0182		;  if temp5  <  34 then if pfread ( temp5 , temp6 )  then goto __Skip_Joy0_Down
   4002  24cf
   4003  24cf		       a5 a0		      LDA	temp5
   4004  24d1		       c9 22		      CMP	#34
   4005  24d3		       b0 21		      BCS	.skipL0182
   4006  24d5				   .condpart64
   4007  24d5		       a5 a0		      LDA	temp5
   4008  24d7		       a4 a1		      LDY	temp6
   4009  24d9		       85 ee		      sta	temp7
   4010  24db		       a9 34		      lda	#>(ret_point5-1)
   4011  24dd		       48		      pha
   4012  24de		       a9 f0		      lda	#<(ret_point5-1)
   4013  24e0		       48		      pha
   4014  24e1		       a9 f2		      lda	#>(pfread-1)
   4015  24e3		       48		      pha
   4016  24e4		       a9 ab		      lda	#<(pfread-1)
   4017  24e6		       48		      pha
   4018  24e7		       a5 ee		      lda	temp7
   4019  24e9		       48		      pha
   4020  24ea		       8a		      txa
   4021  24eb		       48		      pha
   4022  24ec		       a2 08		      ldx	#8
   4023  24ee		       4c eb ff 	      jmp	BS_jsr
   4024  24f1				   ret_point5
   4025  24f1		       d0 03		      BNE	.skip64then
   4026  24f3				   .condpart65
   4027  24f3		       4c 52 35 	      jmp	.__Skip_Joy0_Down
   4028  24f6
   4029  24f6				   .skip64then
   4030  24f6				   .skipL0182
   4031  24f6				   .
   4032  24f6							;
   4033  24f6
   4034  24f6				   .L0183		;  if temp4  <  34 then if pfread ( temp4 , temp6 )  then goto __Skip_Joy0_Down
   4035  24f6
   4036  24f6		       a5 9f		      LDA	temp4
   4037  24f8		       c9 22		      CMP	#34
   4038  24fa		       b0 21		      BCS	.skipL0183
   4039  24fc				   .condpart66
   4040  24fc		       a5 9f		      LDA	temp4
   4041  24fe		       a4 a1		      LDY	temp6
   4042  2500		       85 ee		      sta	temp7
   4043  2502		       a9 35		      lda	#>(ret_point6-1)
   4044  2504		       48		      pha
   4045  2505		       a9 17		      lda	#<(ret_point6-1)
   4046  2507		       48		      pha
   4047  2508		       a9 f2		      lda	#>(pfread-1)
   4048  250a		       48		      pha
   4049  250b		       a9 ab		      lda	#<(pfread-1)
   4050  250d		       48		      pha
   4051  250e		       a5 ee		      lda	temp7
   4052  2510		       48		      pha
   4053  2511		       8a		      txa
   4054  2512		       48		      pha
   4055  2513		       a2 08		      ldx	#8
   4056  2515		       4c eb ff 	      jmp	BS_jsr
   4057  2518				   ret_point6
   4058  2518		       d0 03		      BNE	.skip66then
   4059  251a				   .condpart67
   4060  251a		       4c 52 35 	      jmp	.__Skip_Joy0_Down
   4061  251d
   4062  251d				   .skip66then
   4063  251d				   .skipL0183
   4064  251d				   .
   4065  251d							;
   4066  251d
   4067  251d				   .L0184		;  if temp3  <  34 then if pfread ( temp3 , temp6 )  then goto __Skip_Joy0_Down
   4068  251d
   4069  251d		       a5 9e		      LDA	temp3
   4070  251f		       c9 22		      CMP	#34
   4071  2521		       b0 21		      BCS	.skipL0184
   4072  2523				   .condpart68
   4073  2523		       a5 9e		      LDA	temp3
   4074  2525		       a4 a1		      LDY	temp6
   4075  2527		       85 ee		      sta	temp7
   4076  2529		       a9 35		      lda	#>(ret_point7-1)
   4077  252b		       48		      pha
   4078  252c		       a9 3e		      lda	#<(ret_point7-1)
   4079  252e		       48		      pha
   4080  252f		       a9 f2		      lda	#>(pfread-1)
   4081  2531		       48		      pha
   4082  2532		       a9 ab		      lda	#<(pfread-1)
   4083  2534		       48		      pha
   4084  2535		       a5 ee		      lda	temp7
   4085  2537		       48		      pha
   4086  2538		       8a		      txa
   4087  2539		       48		      pha
   4088  253a		       a2 08		      ldx	#8
   4089  253c		       4c eb ff 	      jmp	BS_jsr
   4090  253f				   ret_point7
   4091  253f		       d0 03		      BNE	.skip68then
   4092  2541				   .condpart69
   4093  2541		       4c 52 35 	      jmp	.__Skip_Joy0_Down
   4094  2544
   4095  2544				   .skip68then
   4096  2544				   .skipL0184
   4097  2544				   .
   4098  2544							;
   4099  2544
   4100  2544				   .
   4101  2544							;
   4102  2544
   4103  2544				   .
   4104  2544							;
   4105  2544
   4106  2544				   .
   4107  2544							;
   4108  2544
   4109  2544				   .L0185		;  player0y  =  player0y  +  1
   4110  2544
   4111  2544		       e6 85		      INC	player0y
   4112  2546				   .
   4113  2546							;
   4114  2546
   4115  2546				   .L0186		;  _Player_Direction_Y  =  2
   4116  2546
   4117  2546		       a9 02		      LDA	#2
   4118  2548		       85 e2		      STA	_Player_Direction_Y
   4119  254a				   .
   4120  254a							;
   4121  254a
   4122  254a				   .L0187		;  if _Player_Acceleration_Y  <  30 then _Player_Acceleration_Y  =  _Player_Acceleration_Y  +	1
   4123  254a
   4124  254a		       a5 e4		      LDA	_Player_Acceleration_Y
   4125  254c		       c9 1e		      CMP	#30
   4126  254e		       b0 02		      BCS	.skipL0187
   4127  2550				   .condpart70
   4128  2550		       e6 e4		      INC	_Player_Acceleration_Y
   4129  2552				   .skipL0187
   4130  2552				   .
   4131  2552							;
   4132  2552
   4133  2552				   .
   4134  2552							;
   4135  2552
   4136  2552				   .__Skip_Joy0_Down
   4137  2552							; __Skip_Joy0_Down
   4138  2552
   4139  2552				   .
   4140  2552							;
   4141  2552
   4142  2552				   .
   4143  2552							;
   4144  2552
   4145  2552				   .
   4146  2552							;
   4147  2552
   4148  2552				   .
   4149  2552							;
   4150  2552
   4151  2552				   .
   4152  2552							;
   4153  2552
   4154  2552				   .
   4155  2552							;
   4156  2552
   4157  2552				   .
   4158  2552							;
   4159  2552
   4160  2552				   .
   4161  2552							;
   4162  2552
   4163  2552				   .
   4164  2552							;
   4165  2552
   4166  2552				   .
   4167  2552							;
   4168  2552
   4169  2552				   .L0188		;  if _Bit3_Auto_Play{3}  &&  _Bit2_P0_Dir_Left{2} then goto __AP_Move_Left
   4170  2552
   4171  2552		       a5 ec		      LDA	_Bit3_Auto_Play
   4172  2554		       29 08		      AND	#8
   4173  2556		       f0 09		      BEQ	.skipL0188
   4174  2558				   .condpart71
   4175  2558		       a5 da		      LDA	_Bit2_P0_Dir_Left
   4176  255a		       29 04		      AND	#4
   4177  255c		       f0 03		      BEQ	.skip71then
   4178  255e				   .condpart72
   4179  255e		       4c 6f 35 	      jmp	.__AP_Move_Left
   4180  2561
   4181  2561				   .skip71then
   4182  2561				   .skipL0188
   4183  2561				   .
   4184  2561							;
   4185  2561
   4186  2561				   .
   4187  2561							;
   4188  2561
   4189  2561				   .
   4190  2561							;
   4191  2561
   4192  2561				   .
   4193  2561							;
   4194  2561
   4195  2561				   .L0189		;  if !joy0left then goto __Skip_Joy0_Left
   4196  2561
   4197  2561		       2c 80 02 	      bit	SWCHA
   4198  2564		       50 03		      BVC	.skipL0189
   4199  2566				   .condpart73
   4200  2566		       4c ee 35 	      jmp	.__Skip_Joy0_Left
   4201  2569
   4202  2569				   .skipL0189
   4203  2569				   .
   4204  2569							;
   4205  2569
   4206  2569				   .
   4207  2569							;
   4208  2569
   4209  2569				   .
   4210  2569							;
   4211  2569
   4212  2569				   .
   4213  2569							;
   4214  2569
   4215  2569				   .L0190		;  _Bit2_P0_Dir_Left{2}  =  1
   4216  2569
   4217  2569		       a5 da		      LDA	_Bit2_P0_Dir_Left
   4218  256b		       09 04		      ORA	#4
   4219  256d		       85 da		      STA	_Bit2_P0_Dir_Left
   4220  256f				   .
   4221  256f							;
   4222  256f
   4223  256f				   .__AP_Move_Left
   4224  256f							; __AP_Move_Left
   4225  256f
   4226  256f				   .
   4227  256f							;
   4228  256f
   4229  256f				   .
   4230  256f							;
   4231  256f
   4232  256f				   .
   4233  256f							;
   4234  256f
   4235  256f				   .
   4236  256f							;
   4237  256f
   4238  256f				   .L0191		;  if player0x  <=  _P_Edge_Left then goto __Skip_Joy0_Left
   4239  256f
   4240  256f		       a9 01		      LDA	#_P_Edge_Left
   4241  2571		       c5 80		      CMP	player0x
   4242  2573		       90 03		      BCC	.skipL0191
   4243  2575				   .condpart74
   4244  2575		       4c ee 35 	      jmp	.__Skip_Joy0_Left
   4245  2578
   4246  2578				   .skipL0191
   4247  2578				   .
   4248  2578							;
   4249  2578
   4250  2578				   .
   4251  2578							;
   4252  2578
   4253  2578				   .
   4254  2578							;
   4255  2578
   4256  2578				   .
   4257  2578							;
   4258  2578
   4259  2578				   .L0192		;  temp5  =   ( player0y )  / 8
   4260  2578
   4261  2578							; complex statement detected
   4262  2578		       a5 85		      LDA	player0y
   4263  257a		       4a		      lsr
   4264  257b		       4a		      lsr
   4265  257c		       4a		      lsr
   4266  257d		       85 a0		      STA	temp5
   4267  257f				   .
   4268  257f							;
   4269  257f
   4270  257f				   .L0193		;  temp3  =   ( player0y - 8 )  / 8
   4271  257f
   4272  257f							; complex statement detected
   4273  257f		       a5 85		      LDA	player0y
   4274  2581		       38		      SEC
   4275  2582		       e9 08		      SBC	#8
   4276  2584		       4a		      lsr
   4277  2585		       4a		      lsr
   4278  2586		       4a		      lsr
   4279  2587		       85 9e		      STA	temp3
   4280  2589				   .
   4281  2589							;
   4282  2589
   4283  2589				   .L0194		;  temp6  =   ( player0x - 18 )  / 4
   4284  2589
   4285  2589							; complex statement detected
   4286  2589		       a5 80		      LDA	player0x
   4287  258b		       38		      SEC
   4288  258c		       e9 12		      SBC	#18
   4289  258e		       4a		      lsr
   4290  258f		       4a		      lsr
   4291  2590		       85 a1		      STA	temp6
   4292  2592				   .
   4293  2592							;
   4294  2592
   4295  2592				   .L0195		;  if temp6  <  34 then if pfread ( temp6 , temp5 )  then goto __Skip_Joy0_Left
   4296  2592
   4297  2592		       a5 a1		      LDA	temp6
   4298  2594		       c9 22		      CMP	#34
   4299  2596		       b0 21		      BCS	.skipL0195
   4300  2598				   .condpart75
   4301  2598		       a5 a1		      LDA	temp6
   4302  259a		       a4 a0		      LDY	temp5
   4303  259c		       85 ee		      sta	temp7
   4304  259e		       a9 35		      lda	#>(ret_point8-1)
   4305  25a0		       48		      pha
   4306  25a1		       a9 b3		      lda	#<(ret_point8-1)
   4307  25a3		       48		      pha
   4308  25a4		       a9 f2		      lda	#>(pfread-1)
   4309  25a6		       48		      pha
   4310  25a7		       a9 ab		      lda	#<(pfread-1)
   4311  25a9		       48		      pha
   4312  25aa		       a5 ee		      lda	temp7
   4313  25ac		       48		      pha
   4314  25ad		       8a		      txa
   4315  25ae		       48		      pha
   4316  25af		       a2 08		      ldx	#8
   4317  25b1		       4c eb ff 	      jmp	BS_jsr
   4318  25b4				   ret_point8
   4319  25b4		       d0 03		      BNE	.skip75then
   4320  25b6				   .condpart76
   4321  25b6		       4c ee 35 	      jmp	.__Skip_Joy0_Left
   4322  25b9
   4323  25b9				   .skip75then
   4324  25b9				   .skipL0195
   4325  25b9				   .
   4326  25b9							;
   4327  25b9
   4328  25b9				   .L0196		;  if temp6  <  34 then if pfread ( temp6 , temp3 )  then goto __Skip_Joy0_Left
   4329  25b9
   4330  25b9		       a5 a1		      LDA	temp6
   4331  25bb		       c9 22		      CMP	#34
   4332  25bd		       b0 21		      BCS	.skipL0196
   4333  25bf				   .condpart77
   4334  25bf		       a5 a1		      LDA	temp6
   4335  25c1		       a4 9e		      LDY	temp3
   4336  25c3		       85 ee		      sta	temp7
   4337  25c5		       a9 35		      lda	#>(ret_point9-1)
   4338  25c7		       48		      pha
   4339  25c8		       a9 da		      lda	#<(ret_point9-1)
   4340  25ca		       48		      pha
   4341  25cb		       a9 f2		      lda	#>(pfread-1)
   4342  25cd		       48		      pha
   4343  25ce		       a9 ab		      lda	#<(pfread-1)
   4344  25d0		       48		      pha
   4345  25d1		       a5 ee		      lda	temp7
   4346  25d3		       48		      pha
   4347  25d4		       8a		      txa
   4348  25d5		       48		      pha
   4349  25d6		       a2 08		      ldx	#8
   4350  25d8		       4c eb ff 	      jmp	BS_jsr
   4351  25db				   ret_point9
   4352  25db		       d0 03		      BNE	.skip77then
   4353  25dd				   .condpart78
   4354  25dd		       4c ee 35 	      jmp	.__Skip_Joy0_Left
   4355  25e0
   4356  25e0				   .skip77then
   4357  25e0				   .skipL0196
   4358  25e0				   .
   4359  25e0							;
   4360  25e0
   4361  25e0				   .
   4362  25e0							;
   4363  25e0
   4364  25e0				   .
   4365  25e0							;
   4366  25e0
   4367  25e0				   .
   4368  25e0							;
   4369  25e0
   4370  25e0				   .L0197		;  player0x  =  player0x  -  1
   4371  25e0
   4372  25e0		       c6 80		      DEC	player0x
   4373  25e2				   .
   4374  25e2							;
   4375  25e2
   4376  25e2				   .L0198		;  _Player_Direction_X  =  1
   4377  25e2
   4378  25e2		       a9 01		      LDA	#1
   4379  25e4		       85 e1		      STA	_Player_Direction_X
   4380  25e6				   .
   4381  25e6							;
   4382  25e6
   4383  25e6				   .L0199		;  if _Player_Acceleration_X  <  30 then _Player_Acceleration_X  =  _Player_Acceleration_X  +	1
   4384  25e6
   4385  25e6		       a5 e3		      LDA	_Player_Acceleration_X
   4386  25e8		       c9 1e		      CMP	#30
   4387  25ea		       b0 02		      BCS	.skipL0199
   4388  25ec				   .condpart79
   4389  25ec		       e6 e3		      INC	_Player_Acceleration_X
   4390  25ee				   .skipL0199
   4391  25ee				   .
   4392  25ee							;
   4393  25ee
   4394  25ee				   .__Skip_Joy0_Left
   4395  25ee							; __Skip_Joy0_Left
   4396  25ee
   4397  25ee				   .
   4398  25ee							;
   4399  25ee
   4400  25ee				   .
   4401  25ee							;
   4402  25ee
   4403  25ee				   .
   4404  25ee							;
   4405  25ee
   4406  25ee				   .
   4407  25ee							;
   4408  25ee
   4409  25ee				   .
   4410  25ee							;
   4411  25ee
   4412  25ee				   .
   4413  25ee							;
   4414  25ee
   4415  25ee				   .
   4416  25ee							;
   4417  25ee
   4418  25ee				   .
   4419  25ee							;
   4420  25ee
   4421  25ee				   .
   4422  25ee							;
   4423  25ee
   4424  25ee				   .
   4425  25ee							;
   4426  25ee
   4427  25ee				   .L0200		;  if _Bit3_Auto_Play{3}  &&  _Bit3_P0_Dir_Right{3} then goto __AP_Move_Right
   4428  25ee
   4429  25ee		       a5 ec		      LDA	_Bit3_Auto_Play
   4430  25f0		       29 08		      AND	#8
   4431  25f2		       f0 09		      BEQ	.skipL0200
   4432  25f4				   .condpart80
   4433  25f4		       a5 da		      LDA	_Bit3_P0_Dir_Right
   4434  25f6		       29 08		      AND	#8
   4435  25f8		       f0 03		      BEQ	.skip80then
   4436  25fa				   .condpart81
   4437  25fa		       4c 0b 36 	      jmp	.__AP_Move_Right
   4438  25fd
   4439  25fd				   .skip80then
   4440  25fd				   .skipL0200
   4441  25fd				   .
   4442  25fd							;
   4443  25fd
   4444  25fd				   .
   4445  25fd							;
   4446  25fd
   4447  25fd				   .
   4448  25fd							;
   4449  25fd
   4450  25fd				   .
   4451  25fd							;
   4452  25fd
   4453  25fd				   .L0201		;  if !joy0right then goto __Skip_Joy0_Right
   4454  25fd
   4455  25fd		       2c 80 02 	      bit	SWCHA
   4456  2600		       10 03		      BPL	.skipL0201
   4457  2602				   .condpart82
   4458  2602		       4c 8a 36 	      jmp	.__Skip_Joy0_Right
   4459  2605
   4460  2605				   .skipL0201
   4461  2605				   .
   4462  2605							;
   4463  2605
   4464  2605				   .
   4465  2605							;
   4466  2605
   4467  2605				   .
   4468  2605							;
   4469  2605
   4470  2605				   .
   4471  2605							;
   4472  2605
   4473  2605				   .L0202		;  _Bit3_P0_Dir_Right{3}  =  1
   4474  2605
   4475  2605		       a5 da		      LDA	_Bit3_P0_Dir_Right
   4476  2607		       09 08		      ORA	#8
   4477  2609		       85 da		      STA	_Bit3_P0_Dir_Right
   4478  260b				   .
   4479  260b							;
   4480  260b
   4481  260b				   .__AP_Move_Right
   4482  260b							; __AP_Move_Right
   4483  260b
   4484  260b				   .
   4485  260b							;
   4486  260b
   4487  260b				   .
   4488  260b							;
   4489  260b
   4490  260b				   .
   4491  260b							;
   4492  260b
   4493  260b				   .
   4494  260b							;
   4495  260b
   4496  260b				   .L0203		;  if player0x  >=  _P_Edge_Right then goto __Skip_Joy0_Right
   4497  260b
   4498  260b		       a5 80		      LDA	player0x
   4499  260d		       c9 98		      CMP	#_P_Edge_Right
   4500  260f		       90 03		      BCC	.skipL0203
   4501  2611				   .condpart83
   4502  2611		       4c 8a 36 	      jmp	.__Skip_Joy0_Right
   4503  2614
   4504  2614				   .skipL0203
   4505  2614				   .
   4506  2614							;
   4507  2614
   4508  2614				   .
   4509  2614							;
   4510  2614
   4511  2614				   .
   4512  2614							;
   4513  2614
   4514  2614				   .
   4515  2614							;
   4516  2614
   4517  2614				   .L0204		;  temp5  =   ( player0y )  / 8
   4518  2614
   4519  2614							; complex statement detected
   4520  2614		       a5 85		      LDA	player0y
   4521  2616		       4a		      lsr
   4522  2617		       4a		      lsr
   4523  2618		       4a		      lsr
   4524  2619		       85 a0		      STA	temp5
   4525  261b				   .
   4526  261b							;
   4527  261b
   4528  261b				   .L0205		;  temp3  =   ( player0y - 8 )  / 8
   4529  261b
   4530  261b							; complex statement detected
   4531  261b		       a5 85		      LDA	player0y
   4532  261d		       38		      SEC
   4533  261e		       e9 08		      SBC	#8
   4534  2620		       4a		      lsr
   4535  2621		       4a		      lsr
   4536  2622		       4a		      lsr
   4537  2623		       85 9e		      STA	temp3
   4538  2625				   .
   4539  2625							;
   4540  2625
   4541  2625				   .L0206		;  temp6  =   ( player0x - 9 )  / 4
   4542  2625
   4543  2625							; complex statement detected
   4544  2625		       a5 80		      LDA	player0x
   4545  2627		       38		      SEC
   4546  2628		       e9 09		      SBC	#9
   4547  262a		       4a		      lsr
   4548  262b		       4a		      lsr
   4549  262c		       85 a1		      STA	temp6
   4550  262e				   .
   4551  262e							;
   4552  262e
   4553  262e				   .L0207		;  if temp6  <  34 then if pfread ( temp6 , temp5 )  then goto __Skip_Joy0_Right
   4554  262e
   4555  262e		       a5 a1		      LDA	temp6
   4556  2630		       c9 22		      CMP	#34
   4557  2632		       b0 21		      BCS	.skipL0207
   4558  2634				   .condpart84
   4559  2634		       a5 a1		      LDA	temp6
   4560  2636		       a4 a0		      LDY	temp5
   4561  2638		       85 ee		      sta	temp7
   4562  263a		       a9 36		      lda	#>(ret_point10-1)
   4563  263c		       48		      pha
   4564  263d		       a9 4f		      lda	#<(ret_point10-1)
   4565  263f		       48		      pha
   4566  2640		       a9 f2		      lda	#>(pfread-1)
   4567  2642		       48		      pha
   4568  2643		       a9 ab		      lda	#<(pfread-1)
   4569  2645		       48		      pha
   4570  2646		       a5 ee		      lda	temp7
   4571  2648		       48		      pha
   4572  2649		       8a		      txa
   4573  264a		       48		      pha
   4574  264b		       a2 08		      ldx	#8
   4575  264d		       4c eb ff 	      jmp	BS_jsr
   4576  2650				   ret_point10
   4577  2650		       d0 03		      BNE	.skip84then
   4578  2652				   .condpart85
   4579  2652		       4c 8a 36 	      jmp	.__Skip_Joy0_Right
   4580  2655
   4581  2655				   .skip84then
   4582  2655				   .skipL0207
   4583  2655				   .
   4584  2655							;
   4585  2655
   4586  2655				   .L0208		;  if temp6  <  34 then if pfread ( temp6 , temp3 )  then goto __Skip_Joy0_Right
   4587  2655
   4588  2655		       a5 a1		      LDA	temp6
   4589  2657		       c9 22		      CMP	#34
   4590  2659		       b0 21		      BCS	.skipL0208
   4591  265b				   .condpart86
   4592  265b		       a5 a1		      LDA	temp6
   4593  265d		       a4 9e		      LDY	temp3
   4594  265f		       85 ee		      sta	temp7
   4595  2661		       a9 36		      lda	#>(ret_point11-1)
   4596  2663		       48		      pha
   4597  2664		       a9 76		      lda	#<(ret_point11-1)
   4598  2666		       48		      pha
   4599  2667		       a9 f2		      lda	#>(pfread-1)
   4600  2669		       48		      pha
   4601  266a		       a9 ab		      lda	#<(pfread-1)
   4602  266c		       48		      pha
   4603  266d		       a5 ee		      lda	temp7
   4604  266f		       48		      pha
   4605  2670		       8a		      txa
   4606  2671		       48		      pha
   4607  2672		       a2 08		      ldx	#8
   4608  2674		       4c eb ff 	      jmp	BS_jsr
   4609  2677				   ret_point11
   4610  2677		       d0 03		      BNE	.skip86then
   4611  2679				   .condpart87
   4612  2679		       4c 8a 36 	      jmp	.__Skip_Joy0_Right
   4613  267c
   4614  267c				   .skip86then
   4615  267c				   .skipL0208
   4616  267c				   .
   4617  267c							;
   4618  267c
   4619  267c				   .
   4620  267c							;
   4621  267c
   4622  267c				   .
   4623  267c							;
   4624  267c
   4625  267c				   .
   4626  267c							;
   4627  267c
   4628  267c				   .L0209		;  player0x  =  player0x  +  1
   4629  267c
   4630  267c		       e6 80		      INC	player0x
   4631  267e				   .
   4632  267e							;
   4633  267e
   4634  267e				   .L0210		;  _Player_Direction_X  =  2
   4635  267e
   4636  267e		       a9 02		      LDA	#2
   4637  2680		       85 e1		      STA	_Player_Direction_X
   4638  2682				   .
   4639  2682							;
   4640  2682
   4641  2682				   .L0211		;  if _Player_Acceleration_X  <  30 then _Player_Acceleration_X  =  _Player_Acceleration_X  +	1
   4642  2682
   4643  2682		       a5 e3		      LDA	_Player_Acceleration_X
   4644  2684		       c9 1e		      CMP	#30
   4645  2686		       b0 02		      BCS	.skipL0211
   4646  2688				   .condpart88
   4647  2688		       e6 e3		      INC	_Player_Acceleration_X
   4648  268a				   .skipL0211
   4649  268a				   .
   4650  268a							;
   4651  268a
   4652  268a				   .__Skip_Joy0_Right
   4653  268a							; __Skip_Joy0_Right
   4654  268a
   4655  268a				   .
   4656  268a							;
   4657  268a
   4658  268a				   .
   4659  268a							;
   4660  268a
   4661  268a				   .
   4662  268a							;
   4663  268a
   4664  268a				   .
   4665  268a							;
   4666  268a
   4667  268a				   .
   4668  268a							;
   4669  268a
   4670  268a				   .
   4671  268a							;
   4672  268a
   4673  268a				   .
   4674  268a							;
   4675  268a
   4676  268a				   .__Sound_Thrusters_On
   4677  268a							; __Sound_Thrusters_On
   4678  268a
   4679  268a				   .
   4680  268a							;
   4681  268a
   4682  268a				   .L0212		;  if !joy0left  &&  !joy0right  &&  !joy0up  &&  !joy0down then goto __Sound_Thrusters_Off
   4683  268a
   4684  268a		       2c 80 02 	      bit	SWCHA
   4685  268d		       50 16		      BVC	.skipL0212
   4686  268f				   .condpart89
   4687  268f		       2c 80 02 	      bit	SWCHA
   4688  2692		       10 11		      BPL	.skip89then
   4689  2694				   .condpart90
   4690  2694		       a9 10		      lda	#$10
   4691  2696		       2c 80 02 	      bit	SWCHA
   4692  2699		       f0 0a		      BEQ	.skip90then
   4693  269b				   .condpart91
   4694  269b		       a9 20		      lda	#$20
   4695  269d		       2c 80 02 	      bit	SWCHA
   4696  26a0		       f0 03		      BEQ	.skip91then
   4697  26a2				   .condpart92
   4698  26a2		       4c b4 36 	      jmp	.__Sound_Thrusters_Off
   4699  26a5
   4700  26a5				   .skip91then
   4701  26a5				   .skip90then
   4702  26a5				   .skip89then
   4703  26a5				   .skipL0212
   4704  26a5				   .
   4705  26a5							;
   4706  26a5
   4707  26a5				   .L0213		;  AUDC0  =  2
   4708  26a5
   4709  26a5		       a9 02		      LDA	#2
   4710  26a7		       85 15		      STA	AUDC0
   4711  26a9				   .L0214		;  AUDF0  =  15
   4712  26a9
   4713  26a9		       a9 0f		      LDA	#15
   4714  26ab		       85 17		      STA	AUDF0
   4715  26ad				   .L0215		;  AUDV0  =  10
   4716  26ad
   4717  26ad		       a9 0a		      LDA	#10
   4718  26af		       85 19		      STA	AUDV0
   4719  26b1				   .
   4720  26b1							;
   4721  26b1
   4722  26b1				   .L0216		;  goto __Autoplay_Inactivity
   4723  26b1
   4724  26b1		       4c b8 36 	      jmp	.__Autoplay_Inactivity
   4725  26b4
   4726  26b4				   .
   4727  26b4							;
   4728  26b4
   4729  26b4				   .__Sound_Thrusters_Off
   4730  26b4							; __Sound_Thrusters_Off
   4731  26b4
   4732  26b4				   .L0217		;  AUDV0  =  0
   4733  26b4
   4734  26b4		       a9 00		      LDA	#0
   4735  26b6		       85 19		      STA	AUDV0
   4736  26b8				   .
   4737  26b8							;
   4738  26b8
   4739  26b8				   .__Autoplay_Inactivity
   4740  26b8							; __Autoplay_Inactivity
   4741  26b8
   4742  26b8				   .
   4743  26b8							;
   4744  26b8
   4745  26b8				   .
   4746  26b8							;
   4747  26b8
   4748  26b8				   .
   4749  26b8							;
   4750  26b8
   4751  26b8				   .
   4752  26b8							;
   4753  26b8
   4754  26b8				   .
   4755  26b8							;
   4756  26b8
   4757  26b8				   .
   4758  26b8							;
   4759  26b8
   4760  26b8				   .
   4761  26b8							;
   4762  26b8
   4763  26b8				   .
   4764  26b8							;
   4765  26b8
   4766  26b8				   .L0218		;  if !_Bit3_Auto_Play{3} then goto __AP_Inactivity
   4767  26b8
   4768  26b8		       a5 ec		      LDA	_Bit3_Auto_Play
   4769  26ba		       29 08		      AND	#8
   4770  26bc		       d0 03		      BNE	.skipL0218
   4771  26be				   .condpart93
   4772  26be		       4c d9 36 	      jmp	.__AP_Inactivity
   4773  26c1
   4774  26c1				   .skipL0218
   4775  26c1				   .
   4776  26c1							;
   4777  26c1
   4778  26c1				   .
   4779  26c1							;
   4780  26c1
   4781  26c1				   .
   4782  26c1							;
   4783  26c1
   4784  26c1				   .
   4785  26c1							;
   4786  26c1
   4787  26c1				   .L0219		;  if _AP_Mem_P0x  =  player0x  &&  _AP_Mem_P0y  =  player0y then _AP_Dir_Counter  =  254
   4788  26c1
   4789  26c1		       a5 dc		      LDA	_AP_Mem_P0x
   4790  26c3		       c5 80		      CMP	player0x
   4791  26c5		       d0 0a		      BNE	.skipL0219
   4792  26c7				   .condpart94
   4793  26c7		       a5 dd		      LDA	_AP_Mem_P0y
   4794  26c9		       c5 85		      CMP	player0y
   4795  26cb		       d0 04		      BNE	.skip94then
   4796  26cd				   .condpart95
   4797  26cd		       a9 fe		      LDA	#254
   4798  26cf		       85 df		      STA	_AP_Dir_Counter
   4799  26d1				   .skip94then
   4800  26d1				   .skipL0219
   4801  26d1				   .
   4802  26d1							;
   4803  26d1
   4804  26d1				   .
   4805  26d1							;
   4806  26d1
   4807  26d1				   .
   4808  26d1							;
   4809  26d1
   4810  26d1				   .
   4811  26d1							;
   4812  26d1
   4813  26d1				   .L0220		;  _AP_Mem_P0x  =  player0x  :  _AP_Mem_P0y  =  player0y
   4814  26d1
   4815  26d1		       a5 80		      LDA	player0x
   4816  26d3		       85 dc		      STA	_AP_Mem_P0x
   4817  26d5		       a5 85		      LDA	player0y
   4818  26d7		       85 dd		      STA	_AP_Mem_P0y
   4819  26d9				   .
   4820  26d9							;
   4821  26d9
   4822  26d9				   .__AP_Inactivity
   4823  26d9							; __AP_Inactivity
   4824  26d9
   4825  26d9				   .
   4826  26d9							;
   4827  26d9
   4828  26d9				   .
   4829  26d9							;
   4830  26d9
   4831  26d9				   .
   4832  26d9							;
   4833  26d9
   4834  26d9				   .
   4835  26d9							;
   4836  26d9
   4837  26d9				   .
   4838  26d9							;
   4839  26d9
   4840  26d9				   .
   4841  26d9							;
   4842  26d9
   4843  26d9				   .
   4844  26d9							;
   4845  26d9
   4846  26d9				   .
   4847  26d9							;
   4848  26d9
   4849  26d9				   .
   4850  26d9							;
   4851  26d9
   4852  26d9				   .
   4853  26d9							;
   4854  26d9
   4855  26d9				   .
   4856  26d9							;
   4857  26d9
   4858  26d9				   .
   4859  26d9							;
   4860  26d9
   4861  26d9				   .
   4862  26d9							;
   4863  26d9
   4864  26d9				   .L0221		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Fire_Missile
   4865  26d9
   4866  26d9		       a5 ec		      LDA	_Bit3_Auto_Play
   4867  26db		       29 08		      AND	#8
   4868  26dd		       d0 03		      BNE	.skipL0221
   4869  26df				   .condpart96
   4870  26df		       4c fd 36 	      jmp	.__AP_Skip_Fire_Missile
   4871  26e2
   4872  26e2				   .skipL0221
   4873  26e2				   .
   4874  26e2							;
   4875  26e2
   4876  26e2				   .
   4877  26e2							;
   4878  26e2
   4879  26e2				   .
   4880  26e2							;
   4881  26e2
   4882  26e2				   .
   4883  26e2							;
   4884  26e2
   4885  26e2				   .
   4886  26e2							;
   4887  26e2
   4888  26e2				   .L0222		;  temp5  =  rand  :  if temp5  <  230 then goto __Skip_Fire
   4889  26e2
   4890  26e2		       a5 a2		      lda	rand
   4891  26e4		       4a		      lsr
   4892  26e5					      ifconst	rand16
   4893  26e5		       26 ed		      rol	rand16
   4894  26e7					      endif
   4895  26e7		       90 02		      bcc	*+4
   4896  26e9		       49 b4		      eor	#$B4
   4897  26eb		       85 a2		      sta	rand
   4898  26ed					      ifconst	rand16
   4899  26ed		       45 ed		      eor	rand16
   4900  26ef					      endif
   4901  26ef		       85 a0		      STA	temp5
   4902  26f1		       a5 a0		      LDA	temp5
   4903  26f3		       c9 e6		      CMP	#230
   4904  26f5		       b0 03		      BCS	.skipL0222
   4905  26f7				   .condpart97
   4906  26f7		       4c ac 37 	      jmp	.__Skip_Fire
   4907  26fa
   4908  26fa				   .skipL0222
   4909  26fa				   .
   4910  26fa							;
   4911  26fa
   4912  26fa				   .L0223		;  goto __AP_Fire
   4913  26fa
   4914  26fa		       4c 13 37 	      jmp	.__AP_Fire
   4915  26fd
   4916  26fd				   .
   4917  26fd							;
   4918  26fd
   4919  26fd				   .__AP_Skip_Fire_Missile
   4920  26fd							; __AP_Skip_Fire_Missile
   4921  26fd
   4922  26fd				   .
   4923  26fd							;
   4924  26fd
   4925  26fd				   .
   4926  26fd							;
   4927  26fd
   4928  26fd				   .
   4929  26fd							;
   4930  26fd
   4931  26fd				   .
   4932  26fd							;
   4933  26fd
   4934  26fd				   .
   4935  26fd							;
   4936  26fd
   4937  26fd				   .L0224		;  if !joy0fire then _Bit1_FireB_Restrainer{1}  =  0  :  goto __Skip_Fire
   4938  26fd
   4939  26fd		       24 0c		      bit	INPT4
   4940  26ff		       10 09		      BPL	.skipL0224
   4941  2701				   .condpart98
   4942  2701		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   4943  2703		       29 fd		      AND	#253
   4944  2705		       85 ec		      STA	_Bit1_FireB_Restrainer
   4945  2707		       4c ac 37 	      jmp	.__Skip_Fire
   4946  270a
   4947  270a				   .skipL0224
   4948  270a				   .
   4949  270a							;
   4950  270a
   4951  270a				   .
   4952  270a							;
   4953  270a
   4954  270a				   .
   4955  270a							;
   4956  270a
   4957  270a				   .
   4958  270a							;
   4959  270a
   4960  270a				   .
   4961  270a							;
   4962  270a
   4963  270a				   .L0225		;  if _Bit1_FireB_Restrainer{1} then goto __Skip_Fire
   4964  270a
   4965  270a		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   4966  270c		       29 02		      AND	#2
   4967  270e		       f0 03		      BEQ	.skipL0225
   4968  2710				   .condpart99
   4969  2710		       4c ac 37 	      jmp	.__Skip_Fire
   4970  2713
   4971  2713				   .skipL0225
   4972  2713				   .
   4973  2713							;
   4974  2713
   4975  2713				   .__AP_Fire
   4976  2713							; __AP_Fire
   4977  2713
   4978  2713				   .
   4979  2713							;
   4980  2713
   4981  2713				   .
   4982  2713							;
   4983  2713
   4984  2713				   .
   4985  2713							;
   4986  2713
   4987  2713				   .
   4988  2713							;
   4989  2713
   4990  2713				   .L0226		;  if _Bit7_M1_Moving{7} then goto __Skip_Fire
   4991  2713
   4992  2713		       24 ec		      BIT	_Bit7_M1_Moving
   4993  2715		       10 03		      BPL	.skipL0226
   4994  2717				   .condpart100
   4995  2717		       4c ac 37 	      jmp	.__Skip_Fire
   4996  271a
   4997  271a				   .skipL0226
   4998  271a				   .
   4999  271a							;
   5000  271a
   5001  271a				   .
   5002  271a							;
   5003  271a
   5004  271a				   .
   5005  271a							;
   5006  271a
   5007  271a				   .
   5008  271a							;
   5009  271a
   5010  271a				   .L0227		;  _Bit7_M1_Moving{7}	=  1
   5011  271a
   5012  271a		       a5 ec		      LDA	_Bit7_M1_Moving
   5013  271c		       09 80		      ORA	#128
   5014  271e		       85 ec		      STA	_Bit7_M1_Moving
   5015  2720				   .
   5016  2720							;
   5017  2720
   5018  2720				   .
   5019  2720							;
   5020  2720
   5021  2720				   .
   5022  2720							;
   5023  2720
   5024  2720				   .
   5025  2720							;
   5026  2720
   5027  2720				   .
   5028  2720							;
   5029  2720
   5030  2720				   .L0228		;  _Bit4_M1_Dir_Up{4}	=  _Bit0_P0_Dir_Up{0}
   5031  2720
   5032  2720		       a5 da		      LDA	_Bit0_P0_Dir_Up
   5033  2722		       29 01		      AND	#1
   5034  2724		       08		      PHP
   5035  2725		       a5 da		      LDA	_Bit4_M1_Dir_Up
   5036  2727		       29 ef		      AND	#239
   5037  2729		       28		      PLP
   5038  272a		       f0 02		      .byte.b	$F0, $02
   5039  272c		       09 10		      ORA	#16
   5040  272e		       85 da		      STA	_Bit4_M1_Dir_Up
   5041  2730				   .L0229		;  _Bit5_M1_Dir_Down{5}  =  _Bit1_P0_Dir_Down{1}
   5042  2730
   5043  2730		       a5 da		      LDA	_Bit1_P0_Dir_Down
   5044  2732		       29 02		      AND	#2
   5045  2734		       08		      PHP
   5046  2735		       a5 da		      LDA	_Bit5_M1_Dir_Down
   5047  2737		       29 df		      AND	#223
   5048  2739		       28		      PLP
   5049  273a		       f0 02		      .byte.b	$F0, $02
   5050  273c		       09 20		      ORA	#32
   5051  273e		       85 da		      STA	_Bit5_M1_Dir_Down
   5052  2740				   .L0230		;  _Bit6_M1_Dir_Left{6}  =  _Bit2_P0_Dir_Left{2}
   5053  2740
   5054  2740		       a5 da		      LDA	_Bit2_P0_Dir_Left
   5055  2742		       29 04		      AND	#4
   5056  2744		       08		      PHP
   5057  2745		       a5 da		      LDA	_Bit6_M1_Dir_Left
   5058  2747		       29 bf		      AND	#191
   5059  2749		       28		      PLP
   5060  274a		       f0 02		      .byte.b	$F0, $02
   5061  274c		       09 40		      ORA	#64
   5062  274e		       85 da		      STA	_Bit6_M1_Dir_Left
   5063  2750				   .L0231		;  _Bit7_M1_Dir_Right{7}  =  _Bit3_P0_Dir_Right{3}
   5064  2750
   5065  2750		       a5 da		      LDA	_Bit3_P0_Dir_Right
   5066  2752		       29 08		      AND	#8
   5067  2754		       08		      PHP
   5068  2755		       a5 da		      LDA	_Bit7_M1_Dir_Right
   5069  2757		       29 7f		      AND	#127
   5070  2759		       28		      PLP
   5071  275a		       f0 02		      .byte.b	$F0, $02
   5072  275c		       09 80		      ORA	#128
   5073  275e		       85 da		      STA	_Bit7_M1_Dir_Right
   5074  2760				   .
   5075  2760							;
   5076  2760
   5077  2760				   .
   5078  2760							;
   5079  2760
   5080  2760				   .
   5081  2760							;
   5082  2760
   5083  2760				   .
   5084  2760							;
   5085  2760
   5086  2760				   .L0232		;  if _Bit4_M1_Dir_Up{4} then missile1x  =  player0x  +  4  :	missile1y  =  player0y	-  5
   5087  2760
   5088  2760		       a5 da		      LDA	_Bit4_M1_Dir_Up
   5089  2762		       29 10		      AND	#16
   5090  2764		       f0 0e		      BEQ	.skipL0232
   5091  2766				   .condpart101
   5092  2766		       a5 80		      LDA	player0x
   5093  2768		       18		      CLC
   5094  2769		       69 04		      ADC	#4
   5095  276b		       85 83		      STA	missile1x
   5096  276d		       a5 85		      LDA	player0y
   5097  276f		       38		      SEC
   5098  2770		       e9 05		      SBC	#5
   5099  2772		       85 88		      STA	missile1y
   5100  2774				   .skipL0232
   5101  2774				   .L0233		;  if _Bit5_M1_Dir_Down{5} then missile1x  =  player0x  +  4  :  missile1y  =	player0y  -  1
   5102  2774
   5103  2774		       a5 da		      LDA	_Bit5_M1_Dir_Down
   5104  2776		       29 20		      AND	#32
   5105  2778		       f0 0e		      BEQ	.skipL0233
   5106  277a				   .condpart102
   5107  277a		       a5 80		      LDA	player0x
   5108  277c		       18		      CLC
   5109  277d		       69 04		      ADC	#4
   5110  277f		       85 83		      STA	missile1x
   5111  2781		       a5 85		      LDA	player0y
   5112  2783		       38		      SEC
   5113  2784		       e9 01		      SBC	#1
   5114  2786		       85 88		      STA	missile1y
   5115  2788				   .skipL0233
   5116  2788				   .L0234		;  if _Bit6_M1_Dir_Left{6} then missile1x  =  player0x  +  2  :  missile1y  =	player0y  -  3
   5117  2788
   5118  2788		       24 da		      BIT	_Bit6_M1_Dir_Left
   5119  278a		       50 0e		      BVC	.skipL0234
   5120  278c				   .condpart103
   5121  278c		       a5 80		      LDA	player0x
   5122  278e		       18		      CLC
   5123  278f		       69 02		      ADC	#2
   5124  2791		       85 83		      STA	missile1x
   5125  2793		       a5 85		      LDA	player0y
   5126  2795		       38		      SEC
   5127  2796		       e9 03		      SBC	#3
   5128  2798		       85 88		      STA	missile1y
   5129  279a				   .skipL0234
   5130  279a				   .L0235		;  if _Bit7_M1_Dir_Right{7} then missile1x  =	player0x  +  6	:  missile1y  =  player0y  -  3
   5131  279a
   5132  279a		       24 da		      BIT	_Bit7_M1_Dir_Right
   5133  279c		       10 0e		      BPL	.skipL0235
   5134  279e				   .condpart104
   5135  279e		       a5 80		      LDA	player0x
   5136  27a0		       18		      CLC
   5137  27a1		       69 06		      ADC	#6
   5138  27a3		       85 83		      STA	missile1x
   5139  27a5		       a5 85		      LDA	player0y
   5140  27a7		       38		      SEC
   5141  27a8		       e9 03		      SBC	#3
   5142  27aa		       85 88		      STA	missile1y
   5143  27ac				   .skipL0235
   5144  27ac				   .
   5145  27ac							;
   5146  27ac
   5147  27ac				   .__Skip_Fire
   5148  27ac							; __Skip_Fire
   5149  27ac
   5150  27ac				   .
   5151  27ac							;
   5152  27ac
   5153  27ac				   .
   5154  27ac							;
   5155  27ac
   5156  27ac				   .
   5157  27ac							;
   5158  27ac
   5159  27ac				   .
   5160  27ac							;
   5161  27ac
   5162  27ac				   .
   5163  27ac							;
   5164  27ac
   5165  27ac				   .
   5166  27ac							;
   5167  27ac
   5168  27ac				   .
   5169  27ac							;
   5170  27ac
   5171  27ac				   .
   5172  27ac							;
   5173  27ac
   5174  27ac				   .
   5175  27ac							;
   5176  27ac
   5177  27ac				   .
   5178  27ac							;
   5179  27ac
   5180  27ac				   .L0236		;  if !_Bit7_M1_Moving{7} then goto __Skip_Missile
   5181  27ac
   5182  27ac		       24 ec		      BIT	_Bit7_M1_Moving
   5183  27ae		       30 03		      BMI	.skipL0236
   5184  27b0				   .condpart105
   5185  27b0		       4c 38 38 	      jmp	.__Skip_Missile
   5186  27b3
   5187  27b3				   .skipL0236
   5188  27b3				   .
   5189  27b3							;
   5190  27b3
   5191  27b3				   .
   5192  27b3							;
   5193  27b3
   5194  27b3				   .
   5195  27b3							;
   5196  27b3
   5197  27b3				   .
   5198  27b3							;
   5199  27b3
   5200  27b3				   .L0237		;  if _Bit4_M1_Dir_Up{4} then missile1y  =  missile1y	-  2
   5201  27b3
   5202  27b3		       a5 da		      LDA	_Bit4_M1_Dir_Up
   5203  27b5		       29 10		      AND	#16
   5204  27b7		       f0 07		      BEQ	.skipL0237
   5205  27b9				   .condpart106
   5206  27b9		       a5 88		      LDA	missile1y
   5207  27bb		       38		      SEC
   5208  27bc		       e9 02		      SBC	#2
   5209  27be		       85 88		      STA	missile1y
   5210  27c0				   .skipL0237
   5211  27c0				   .L0238		;  if _Bit5_M1_Dir_Down{5} then missile1y  =  missile1y  +  2
   5212  27c0
   5213  27c0		       a5 da		      LDA	_Bit5_M1_Dir_Down
   5214  27c2		       29 20		      AND	#32
   5215  27c4		       f0 07		      BEQ	.skipL0238
   5216  27c6				   .condpart107
   5217  27c6		       a5 88		      LDA	missile1y
   5218  27c8		       18		      CLC
   5219  27c9		       69 02		      ADC	#2
   5220  27cb		       85 88		      STA	missile1y
   5221  27cd				   .skipL0238
   5222  27cd				   .L0239		;  if _Bit6_M1_Dir_Left{6} then missile1x  =  missile1x  -  2
   5223  27cd
   5224  27cd		       24 da		      BIT	_Bit6_M1_Dir_Left
   5225  27cf		       50 07		      BVC	.skipL0239
   5226  27d1				   .condpart108
   5227  27d1		       a5 83		      LDA	missile1x
   5228  27d3		       38		      SEC
   5229  27d4		       e9 02		      SBC	#2
   5230  27d6		       85 83		      STA	missile1x
   5231  27d8				   .skipL0239
   5232  27d8				   .L0240		;  if _Bit7_M1_Dir_Right{7} then missile1x  =	missile1x  +  2
   5233  27d8
   5234  27d8		       24 da		      BIT	_Bit7_M1_Dir_Right
   5235  27da		       10 07		      BPL	.skipL0240
   5236  27dc				   .condpart109
   5237  27dc		       a5 83		      LDA	missile1x
   5238  27de		       18		      CLC
   5239  27df		       69 02		      ADC	#2
   5240  27e1		       85 83		      STA	missile1x
   5241  27e3				   .skipL0240
   5242  27e3				   .
   5243  27e3							;
   5244  27e3
   5245  27e3				   .
   5246  27e3							;
   5247  27e3
   5248  27e3				   .
   5249  27e3							;
   5250  27e3
   5251  27e3				   .
   5252  27e3							;
   5253  27e3
   5254  27e3				   .L0241		;  if missile1y  <  _M_Edge_Top then goto __Delete_Missile
   5255  27e3
   5256  27e3		       a5 88		      LDA	missile1y
   5257  27e5		       c9 02		      CMP	#_M_Edge_Top
   5258  27e7		       b0 03		      BCS	.skipL0241
   5259  27e9				   .condpart110
   5260  27e9		       4c 2c 38 	      jmp	.__Delete_Missile
   5261  27ec
   5262  27ec				   .skipL0241
   5263  27ec				   .L0242		;  if missile1y  >  _M_Edge_Bottom then goto __Delete_Missile
   5264  27ec
   5265  27ec		       a9 58		      LDA	#_M_Edge_Bottom
   5266  27ee		       c5 88		      CMP	missile1y
   5267  27f0		       b0 03		      BCS	.skipL0242
   5268  27f2				   .condpart111
   5269  27f2		       4c 2c 38 	      jmp	.__Delete_Missile
   5270  27f5
   5271  27f5				   .skipL0242
   5272  27f5				   .L0243		;  if missile1x  <  _M_Edge_Left then goto __Delete_Missile
   5273  27f5
   5274  27f5		       a5 83		      LDA	missile1x
   5275  27f7		       c9 02		      CMP	#_M_Edge_Left
   5276  27f9		       b0 03		      BCS	.skipL0243
   5277  27fb				   .condpart112
   5278  27fb		       4c 2c 38 	      jmp	.__Delete_Missile
   5279  27fe
   5280  27fe				   .skipL0243
   5281  27fe				   .L0244		;  if missile1x  >  _M_Edge_Right then goto __Delete_Missile
   5282  27fe
   5283  27fe		       a9 9f		      LDA	#_M_Edge_Right
   5284  2800		       c5 83		      CMP	missile1x
   5285  2802		       b0 03		      BCS	.skipL0244
   5286  2804				   .condpart113
   5287  2804		       4c 2c 38 	      jmp	.__Delete_Missile
   5288  2807
   5289  2807				   .skipL0244
   5290  2807				   .
   5291  2807							;
   5292  2807
   5293  2807				   .
   5294  2807							;
   5295  2807
   5296  2807				   .
   5297  2807							;
   5298  2807
   5299  2807				   .
   5300  2807							;
   5301  2807
   5302  2807				   .L0245		;  if !collision(playfield,missile1) then goto __Skip_Missile
   5303  2807
   5304  2807		       24 05		      bit	CXM1FB
   5305  2809		       30 03		      BMI	.skipL0245
   5306  280b				   .condpart114
   5307  280b		       4c 38 38 	      jmp	.__Skip_Missile
   5308  280e
   5309  280e				   .skipL0245
   5310  280e				   .
   5311  280e							;
   5312  280e
   5313  280e				   .
   5314  280e							;
   5315  280e
   5316  280e				   .
   5317  280e							;
   5318  280e
   5319  280e				   .
   5320  280e							;
   5321  280e
   5322  280e				   .L0246		;  if _Bit3_Auto_Play{3} then goto __Delete_Missile
   5323  280e
   5324  280e		       a5 ec		      LDA	_Bit3_Auto_Play
   5325  2810		       29 08		      AND	#8
   5326  2812		       f0 03		      BEQ	.skipL0246
   5327  2814				   .condpart115
   5328  2814		       4c 2c 38 	      jmp	.__Delete_Missile
   5329  2817
   5330  2817				   .skipL0246
   5331  2817				   .
   5332  2817							;
   5333  2817
   5334  2817				   .
   5335  2817							;
   5336  2817
   5337  2817				   .
   5338  2817							;
   5339  2817
   5340  2817				   .
   5341  2817							;
   5342  2817
   5343  2817				   .L0247		;  score  =  score  +	1
   5344  2817
   5345  2817		       f8		      SED
   5346  2818		       18		      CLC
   5347  2819		       a5 95		      LDA	score+2
   5348  281b		       69 01		      ADC	#$01
   5349  281d		       85 95		      STA	score+2
   5350  281f		       a5 94		      LDA	score+1
   5351  2821		       69 00		      ADC	#$00
   5352  2823		       85 94		      STA	score+1
   5353  2825		       a5 93		      LDA	score
   5354  2827		       69 00		      ADC	#$00
   5355  2829		       85 93		      STA	score
   5356  282b		       d8		      CLD
   5357  282c				   .
   5358  282c							;
   5359  282c
   5360  282c				   .__Delete_Missile
   5361  282c							; __Delete_Missile
   5362  282c
   5363  282c				   .
   5364  282c							;
   5365  282c
   5366  282c				   .
   5367  282c							;
   5368  282c
   5369  282c				   .
   5370  282c							;
   5371  282c
   5372  282c				   .
   5373  282c							;
   5374  282c
   5375  282c				   .L0248		;  _Bit7_M1_Moving{7}	=  0  :  missile1x  =  200  :  missile1y  =  200
   5376  282c
   5377  282c		       a5 ec		      LDA	_Bit7_M1_Moving
   5378  282e		       29 7f		      AND	#127
   5379  2830		       85 ec		      STA	_Bit7_M1_Moving
   5380  2832		       a9 c8		      LDA	#200
   5381  2834		       85 83		      STA	missile1x
   5382  2836		       85 88		      STA	missile1y
   5383  2838				   .
   5384  2838							;
   5385  2838
   5386  2838				   .__Skip_Missile
   5387  2838							; __Skip_Missile
   5388  2838
   5389  2838				   .
   5390  2838							;
   5391  2838
   5392  2838				   .
   5393  2838							;
   5394  2838
   5395  2838				   .
   5396  2838							;
   5397  2838
   5398  2838				   .
   5399  2838							;
   5400  2838
   5401  2838				   .
   5402  2838							;
   5403  2838
   5404  2838				   .
   5405  2838							;
   5406  2838
   5407  2838				   .
   5408  2838							;
   5409  2838
   5410  2838				   .L0249		;  if collision(player0,player1) then _Bit2_Game_Control{2}  =  1
   5411  2838
   5412  2838		       24 07		      bit	CXPPMM
   5413  283a		       10 06		      BPL	.skipL0249
   5414  283c				   .condpart116
   5415  283c		       a5 ec		      LDA	_Bit2_Game_Control
   5416  283e		       09 04		      ORA	#4
   5417  2840		       85 ec		      STA	_Bit2_Game_Control
   5418  2842				   .skipL0249
   5419  2842				   .
   5420  2842							;
   5421  2842
   5422  2842				   .
   5423  2842							;
   5424  2842
   5425  2842				   .
   5426  2842							;
   5427  2842
   5428  2842				   .
   5429  2842							;
   5430  2842
   5431  2842				   .
   5432  2842							;
   5433  2842
   5434  2842				   .
   5435  2842							;
   5436  2842
   5437  2842				   .
   5438  2842							;
   5439  2842
   5440  2842				   .
   5441  2842							;
   5442  2842
   5443  2842				   .
   5444  2842							;
   5445  2842
   5446  2842				   .
   5447  2842							;
   5448  2842
   5449  2842				   .L0250		;  if !collision(player1,missile1) then goto __Skip_Shot_Enemy
   5450  2842
   5451  2842		       24 01		      bit	CXM1P
   5452  2844		       70 03		      BVS	.skipL0250
   5453  2846				   .condpart117
   5454  2846		       4c b8 38 	      jmp	.__Skip_Shot_Enemy
   5455  2849
   5456  2849				   .skipL0250
   5457  2849				   .
   5458  2849							;
   5459  2849
   5460  2849				   .
   5461  2849							;
   5462  2849
   5463  2849				   .
   5464  2849							;
   5465  2849
   5466  2849				   .
   5467  2849							;
   5468  2849
   5469  2849				   .L0251		;  _Bit7_M1_Moving{7}	=  0  :  missile1x  =  200  :  missile1y  =  200
   5470  2849
   5471  2849		       a5 ec		      LDA	_Bit7_M1_Moving
   5472  284b		       29 7f		      AND	#127
   5473  284d		       85 ec		      STA	_Bit7_M1_Moving
   5474  284f		       a9 c8		      LDA	#200
   5475  2851		       85 83		      STA	missile1x
   5476  2853		       85 88		      STA	missile1y
   5477  2855				   .
   5478  2855							;
   5479  2855
   5480  2855				   .
   5481  2855							;
   5482  2855
   5483  2855				   .
   5484  2855							;
   5485  2855
   5486  2855				   .
   5487  2855							;
   5488  2855
   5489  2855				   .L0252		;  if _Bit3_Auto_Play{3} then goto __AP_Skip_Enemy_Points
   5490  2855
   5491  2855		       a5 ec		      LDA	_Bit3_Auto_Play
   5492  2857		       29 08		      AND	#8
   5493  2859		       f0 03		      BEQ	.skipL0252
   5494  285b				   .condpart118
   5495  285b		       4c 73 38 	      jmp	.__AP_Skip_Enemy_Points
   5496  285e
   5497  285e				   .skipL0252
   5498  285e				   .
   5499  285e							;
   5500  285e
   5501  285e				   .
   5502  285e							;
   5503  285e
   5504  285e				   .
   5505  285e							;
   5506  285e
   5507  285e				   .
   5508  285e							;
   5509  285e
   5510  285e				   .L0253		;  score  =  score  +	20
   5511  285e
   5512  285e		       f8		      SED
   5513  285f		       18		      CLC
   5514  2860		       a5 95		      LDA	score+2
   5515  2862		       69 20		      ADC	#$20
   5516  2864		       85 95		      STA	score+2
   5517  2866		       a5 94		      LDA	score+1
   5518  2868		       69 00		      ADC	#$00
   5519  286a		       85 94		      STA	score+1
   5520  286c		       a5 93		      LDA	score
   5521  286e		       69 00		      ADC	#$00
   5522  2870		       85 93		      STA	score
   5523  2872		       d8		      CLD
   5524  2873				   .
   5525  2873							;
   5526  2873
   5527  2873				   .__AP_Skip_Enemy_Points
   5528  2873							; __AP_Skip_Enemy_Points
   5529  2873
   5530  2873				   .
   5531  2873							;
   5532  2873
   5533  2873				   .
   5534  2873							;
   5535  2873
   5536  2873				   .
   5537  2873							;
   5538  2873
   5539  2873				   .
   5540  2873							;
   5541  2873
   5542  2873				   .L0254		;  player1y  =   ( rand & 63 )   +  15
   5543  2873
   5544  2873							; complex statement detected
   5545  2873		       a5 a2		      lda	rand
   5546  2875		       4a		      lsr
   5547  2876					      ifconst	rand16
   5548  2876		       26 ed		      rol	rand16
   5549  2878					      endif
   5550  2878		       90 02		      bcc	*+4
   5551  287a		       49 b4		      eor	#$B4
   5552  287c		       85 a2		      sta	rand
   5553  287e					      ifconst	rand16
   5554  287e		       45 ed		      eor	rand16
   5555  2880					      endif
   5556  2880		       29 3f		      AND	#63
   5557  2882		       18		      CLC
   5558  2883		       69 0f		      ADC	#15
   5559  2885		       85 86		      STA	player1y
   5560  2887				   .
   5561  2887							;
   5562  2887
   5563  2887				   .L0255		;  if player0x  >=  77 then player1x  =   ( rand & 7 )   +  5	:  goto __Skip_Shot_Enemy
   5564  2887
   5565  2887		       a5 80		      LDA	player0x
   5566  2889		       c9 4d		      CMP	#77
   5567  288b		       90 17		      BCC	.skipL0255
   5568  288d				   .condpart119
   5569  288d							; complex statement detected
   5570  288d		       a5 a2		      lda	rand
   5571  288f		       4a		      lsr
   5572  2890					      ifconst	rand16
   5573  2890		       26 ed		      rol	rand16
   5574  2892					      endif
   5575  2892		       90 02		      bcc	*+4
   5576  2894		       49 b4		      eor	#$B4
   5577  2896		       85 a2		      sta	rand
   5578  2898					      ifconst	rand16
   5579  2898		       45 ed		      eor	rand16
   5580  289a					      endif
   5581  289a		       29 07		      AND	#7
   5582  289c		       18		      CLC
   5583  289d		       69 05		      ADC	#5
   5584  289f		       85 81		      STA	player1x
   5585  28a1		       4c b8 38 	      jmp	.__Skip_Shot_Enemy
   5586  28a4
   5587  28a4				   .skipL0255
   5588  28a4				   .
   5589  28a4							;
   5590  28a4
   5591  28a4				   .L0256		;  player1x  =   ( rand & 7 )	 +  140
   5592  28a4
   5593  28a4							; complex statement detected
   5594  28a4		       a5 a2		      lda	rand
   5595  28a6		       4a		      lsr
   5596  28a7					      ifconst	rand16
   5597  28a7		       26 ed		      rol	rand16
   5598  28a9					      endif
   5599  28a9		       90 02		      bcc	*+4
   5600  28ab		       49 b4		      eor	#$B4
   5601  28ad		       85 a2		      sta	rand
   5602  28af					      ifconst	rand16
   5603  28af		       45 ed		      eor	rand16
   5604  28b1					      endif
   5605  28b1		       29 07		      AND	#7
   5606  28b3		       18		      CLC
   5607  28b4		       69 8c		      ADC	#140
   5608  28b6		       85 81		      STA	player1x
   5609  28b8				   .
   5610  28b8							;
   5611  28b8
   5612  28b8				   .__Skip_Shot_Enemy
   5613  28b8							; __Skip_Shot_Enemy
   5614  28b8
   5615  28b8				   .
   5616  28b8							;
   5617  28b8
   5618  28b8				   .
   5619  28b8							;
   5620  28b8
   5621  28b8				   .
   5622  28b8							;
   5623  28b8
   5624  28b8				   .
   5625  28b8							;
   5626  28b8
   5627  28b8				   .
   5628  28b8							;
   5629  28b8
   5630  28b8				   .
   5631  28b8							;
   5632  28b8
   5633  28b8				   .
   5634  28b8							;
   5635  28b8
   5636  28b8				   .
   5637  28b8							;
   5638  28b8
   5639  28b8				   .
   5640  28b8							;
   5641  28b8
   5642  28b8				   .
   5643  28b8							;
   5644  28b8
   5645  28b8				   .
   5646  28b8							;
   5647  28b8
   5648  28b8				   .
   5649  28b8							;
   5650  28b8
   5651  28b8				   .L0257		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Flip
   5652  28b8
   5653  28b8		       a5 ec		      LDA	_Bit3_Auto_Play
   5654  28ba		       29 08		      AND	#8
   5655  28bc		       d0 03		      BNE	.skipL0257
   5656  28be				   .condpart120
   5657  28be		       4c 12 39 	      jmp	.__AP_Skip_Flip
   5658  28c1
   5659  28c1				   .skipL0257
   5660  28c1				   .
   5661  28c1							;
   5662  28c1
   5663  28c1				   .
   5664  28c1							;
   5665  28c1
   5666  28c1				   .
   5667  28c1							;
   5668  28c1
   5669  28c1				   .
   5670  28c1							;
   5671  28c1
   5672  28c1				   .L0258		;  _AP_2_Sec_Score_Flip  =  _AP_2_Sec_Score_Flip  +  1
   5673  28c1
   5674  28c1		       e6 de		      INC	_AP_2_Sec_Score_Flip
   5675  28c3				   .
   5676  28c3							;
   5677  28c3
   5678  28c3				   .
   5679  28c3							;
   5680  28c3
   5681  28c3				   .
   5682  28c3							;
   5683  28c3
   5684  28c3				   .
   5685  28c3							;
   5686  28c3
   5687  28c3				   .
   5688  28c3							;
   5689  28c3
   5690  28c3				   .L0259		;  if _AP_2_Sec_Score_Flip  <	120 then goto __AP_Skip_Flip
   5691  28c3
   5692  28c3		       a5 de		      LDA	_AP_2_Sec_Score_Flip
   5693  28c5		       c9 78		      CMP	#120
   5694  28c7		       b0 03		      BCS	.skipL0259
   5695  28c9				   .condpart121
   5696  28c9		       4c 12 39 	      jmp	.__AP_Skip_Flip
   5697  28cc
   5698  28cc				   .skipL0259
   5699  28cc				   .
   5700  28cc							;
   5701  28cc
   5702  28cc				   .
   5703  28cc							;
   5704  28cc
   5705  28cc				   .
   5706  28cc							;
   5707  28cc
   5708  28cc				   .
   5709  28cc							;
   5710  28cc
   5711  28cc				   .L0260		;  _AP_2_Sec_Score_Flip  =  0	:  _Bit6_Swap_Scores{6}  =  !_Bit6_Swap_Scores{6}
   5712  28cc
   5713  28cc		       a9 00		      LDA	#0
   5714  28ce		       85 de		      STA	_AP_2_Sec_Score_Flip
   5715  28d0		       a5 ec		      LDA	_Bit6_Swap_Scores
   5716  28d2		       29 40		      AND	#64
   5717  28d4		       08		      PHP
   5718  28d5		       a5 ec		      LDA	_Bit6_Swap_Scores
   5719  28d7		       29 bf		      AND	#191
   5720  28d9		       28		      PLP
   5721  28da		       d0 02		      .byte.b	$D0, $02
   5722  28dc		       09 40		      ORA	#64
   5723  28de		       85 ec		      STA	_Bit6_Swap_Scores
   5724  28e0				   .
   5725  28e0							;
   5726  28e0
   5727  28e0				   .
   5728  28e0							;
   5729  28e0
   5730  28e0				   .
   5731  28e0							;
   5732  28e0
   5733  28e0				   .
   5734  28e0							;
   5735  28e0
   5736  28e0				   .L0261		;  if !_Bit6_Swap_Scores{6} then goto __AP_Skip_HiScore_Swap
   5737  28e0
   5738  28e0		       24 ec		      BIT	_Bit6_Swap_Scores
   5739  28e2		       70 03		      BVS	.skipL0261
   5740  28e4				   .condpart122
   5741  28e4		       4c fe 38 	      jmp	.__AP_Skip_HiScore_Swap
   5742  28e7
   5743  28e7				   .skipL0261
   5744  28e7				   .
   5745  28e7							;
   5746  28e7
   5747  28e7				   .
   5748  28e7							;
   5749  28e7
   5750  28e7				   .
   5751  28e7							;
   5752  28e7
   5753  28e7				   .
   5754  28e7							;
   5755  28e7
   5756  28e7				   .L0262		;  scorecolor	=  $AE
   5757  28e7
   5758  28e7		       a9 ae		      LDA	#$AE
   5759  28e9		       85 a3		      STA	scorecolor
   5760  28eb				   .L0263		;  pfscorecolor  =  $AE
   5761  28eb
   5762  28eb		       a9 ae		      LDA	#$AE
   5763  28ed		       85 f4		      STA	pfscorecolor
   5764  28ef				   .
   5765  28ef							;
   5766  28ef
   5767  28ef				   .L0264		;  _sc1  =  _High_Score1  :  _sc2  =  _High_Score2  :	_sc3  =  _High_Score3
   5768  28ef
   5769  28ef		       a5 e9		      LDA	_High_Score1
   5770  28f1		       85 93		      STA	_sc1
   5771  28f3		       a5 ea		      LDA	_High_Score2
   5772  28f5		       85 94		      STA	_sc2
   5773  28f7		       a5 eb		      LDA	_High_Score3
   5774  28f9		       85 95		      STA	_sc3
   5775  28fb				   .
   5776  28fb							;
   5777  28fb
   5778  28fb				   .L0265		;  goto __AP_Skip_Flip
   5779  28fb
   5780  28fb		       4c 12 39 	      jmp	.__AP_Skip_Flip
   5781  28fe
   5782  28fe				   .
   5783  28fe							;
   5784  28fe
   5785  28fe				   .__AP_Skip_HiScore_Swap
   5786  28fe							; __AP_Skip_HiScore_Swap
   5787  28fe
   5788  28fe				   .
   5789  28fe							;
   5790  28fe
   5791  28fe				   .
   5792  28fe							;
   5793  28fe
   5794  28fe				   .
   5795  28fe							;
   5796  28fe
   5797  28fe				   .
   5798  28fe							;
   5799  28fe
   5800  28fe				   .L0266		;  scorecolor	=  $1C
   5801  28fe
   5802  28fe		       a9 1c		      LDA	#$1C
   5803  2900		       85 a3		      STA	scorecolor
   5804  2902				   .L0267		;  pfscorecolor  =  $1C
   5805  2902
   5806  2902		       a9 1c		      LDA	#$1C
   5807  2904		       85 f4		      STA	pfscorecolor
   5808  2906				   .
   5809  2906							;
   5810  2906
   5811  2906				   .L0268		;  _sc1  =  _Score1_Mem  :  _sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem
   5812  2906
   5813  2906		       a5 e6		      LDA	_Score1_Mem
   5814  2908		       85 93		      STA	_sc1
   5815  290a		       a5 e7		      LDA	_Score2_Mem
   5816  290c		       85 94		      STA	_sc2
   5817  290e		       a5 e8		      LDA	_Score3_Mem
   5818  2910		       85 95		      STA	_sc3
   5819  2912				   .
   5820  2912							;
   5821  2912
   5822  2912				   .__AP_Skip_Flip
   5823  2912							; __AP_Skip_Flip
   5824  2912
   5825  2912				   .
   5826  2912							;
   5827  2912
   5828  2912				   .
   5829  2912							;
   5830  2912
   5831  2912				   .
   5832  2912							;
   5833  2912
   5834  2912				   .
   5835  2912							;
   5836  2912
   5837  2912				   .
   5838  2912							;
   5839  2912
   5840  2912				   .
   5841  2912							;
   5842  2912
   5843  2912				   .
   5844  2912							;
   5845  2912
   5846  2912				   .
   5847  2912							;
   5848  2912
   5849  2912				   .
   5850  2912							;
   5851  2912
   5852  2912				   .
   5853  2912							;
   5854  2912
   5855  2912				   .L0269		;  if _Bit3_Auto_Play{3} then goto __AP_Skip_Pause
   5856  2912
   5857  2912		       a5 ec		      LDA	_Bit3_Auto_Play
   5858  2914		       29 08		      AND	#8
   5859  2916		       f0 03		      BEQ	.skipL0269
   5860  2918				   .condpart123
   5861  2918		       4c 84 39 	      jmp	.__AP_Skip_Pause
   5862  291b
   5863  291b				   .skipL0269
   5864  291b				   .
   5865  291b							;
   5866  291b
   5867  291b				   .
   5868  291b							;
   5869  291b
   5870  291b				   .
   5871  291b							;
   5872  291b
   5873  291b				   .
   5874  291b							;
   5875  291b
   5876  291b				   .L0270		;  _Bit1_BW_Check{1}  =  0
   5877  291b
   5878  291b		       a5 e5		      LDA	_Bit1_BW_Check
   5879  291d		       29 fd		      AND	#253
   5880  291f		       85 e5		      STA	_Bit1_BW_Check
   5881  2921				   .
   5882  2921							;
   5883  2921
   5884  2921				   .L0271		;  if switchbw then _Bit1_BW_Check{1}	=  1
   5885  2921
   5886  2921		       a9 08		      lda	#8
   5887  2923		       2c 82 02 	      bit	SWCHB
   5888  2926		       d0 06		      BNE	.skipL0271
   5889  2928				   .condpart124
   5890  2928		       a5 e5		      LDA	_Bit1_BW_Check
   5891  292a		       09 02		      ORA	#2
   5892  292c		       85 e5		      STA	_Bit1_BW_Check
   5893  292e				   .skipL0271
   5894  292e				   .
   5895  292e							;
   5896  292e
   5897  292e				   .
   5898  292e							;
   5899  292e
   5900  292e				   .
   5901  292e							;
   5902  292e
   5903  292e				   .
   5904  292e							;
   5905  292e
   5906  292e				   .
   5907  292e							;
   5908  292e
   5909  292e				   .L0272		;  if _Bit0_BW_Mem{0} then if !_Bit1_BW_Check{1} then goto __Pause_Setup bank3
   5910  292e
   5911  292e		       a5 e5		      LDA	_Bit0_BW_Mem
   5912  2930		       4a		      LSR
   5913  2931		       90 18		      BCC	.skipL0272
   5914  2933				   .condpart125
   5915  2933		       a5 e5		      LDA	_Bit1_BW_Check
   5916  2935		       29 02		      AND	#2
   5917  2937		       d0 12		      BNE	.skip125then
   5918  2939				   .condpart126
   5919  2939		       85 ee		      sta	temp7
   5920  293b		       a9 51		      lda	#>(.__Pause_Setup-1)
   5921  293d		       48		      pha
   5922  293e		       a9 ab		      lda	#<(.__Pause_Setup-1)
   5923  2940		       48		      pha
   5924  2941		       a5 ee		      lda	temp7
   5925  2943		       48		      pha
   5926  2944		       8a		      txa
   5927  2945		       48		      pha
   5928  2946		       a2 03		      ldx	#3
   5929  2948		       4c eb ff 	      jmp	BS_jsr
   5930  294b				   .skip125then
   5931  294b				   .skipL0272
   5932  294b				   .
   5933  294b							;
   5934  294b
   5935  294b				   .L0273		;  if !_Bit0_BW_Mem{0} then if _Bit1_BW_Check{1} then goto __Pause_Setup bank3
   5936  294b
   5937  294b		       a5 e5		      LDA	_Bit0_BW_Mem
   5938  294d		       4a		      LSR
   5939  294e		       b0 18		      BCS	.skipL0273
   5940  2950				   .condpart127
   5941  2950		       a5 e5		      LDA	_Bit1_BW_Check
   5942  2952		       29 02		      AND	#2
   5943  2954		       f0 12		      BEQ	.skip127then
   5944  2956				   .condpart128
   5945  2956		       85 ee		      sta	temp7
   5946  2958		       a9 51		      lda	#>(.__Pause_Setup-1)
   5947  295a		       48		      pha
   5948  295b		       a9 ab		      lda	#<(.__Pause_Setup-1)
   5949  295d		       48		      pha
   5950  295e		       a5 ee		      lda	temp7
   5951  2960		       48		      pha
   5952  2961		       8a		      txa
   5953  2962		       48		      pha
   5954  2963		       a2 03		      ldx	#3
   5955  2965		       4c eb ff 	      jmp	BS_jsr
   5956  2968				   .skip127then
   5957  2968				   .skipL0273
   5958  2968				   .
   5959  2968							;
   5960  2968
   5961  2968				   .
   5962  2968							;
   5963  2968
   5964  2968				   .
   5965  2968							;
   5966  2968
   5967  2968				   .
   5968  2968							;
   5969  2968
   5970  2968				   .L0274		;  if joy1fire  &&  !_Bit1_FireB_Restrainer{1} then goto __Pause_Setup bank3
   5971  2968
   5972  2968		       24 0d		      bit	INPT5
   5973  296a		       30 18		      BMI	.skipL0274
   5974  296c				   .condpart129
   5975  296c		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   5976  296e		       29 02		      AND	#2
   5977  2970		       d0 12		      BNE	.skip129then
   5978  2972				   .condpart130
   5979  2972		       85 ee		      sta	temp7
   5980  2974		       a9 51		      lda	#>(.__Pause_Setup-1)
   5981  2976		       48		      pha
   5982  2977		       a9 ab		      lda	#<(.__Pause_Setup-1)
   5983  2979		       48		      pha
   5984  297a		       a5 ee		      lda	temp7
   5985  297c		       48		      pha
   5986  297d		       8a		      txa
   5987  297e		       48		      pha
   5988  297f		       a2 03		      ldx	#3
   5989  2981		       4c eb ff 	      jmp	BS_jsr
   5990  2984				   .skip129then
   5991  2984				   .skipL0274
   5992  2984				   .
   5993  2984							;
   5994  2984
   5995  2984				   .__AP_Skip_Pause
   5996  2984							; __AP_Skip_Pause
   5997  2984
   5998  2984				   .
   5999  2984							;
   6000  2984
   6001  2984				   .
   6002  2984							;
   6003  2984
   6004  2984				   .
   6005  2984							;
   6006  2984
   6007  2984				   .
   6008  2984							;
   6009  2984
   6010  2984				   .
   6011  2984							;
   6012  2984
   6013  2984				   .
   6014  2984							;
   6015  2984
   6016  2984				   .
   6017  2984							;
   6018  2984
   6019  2984				   .L0275		;  drawscreen
   6020  2984
   6021  2984		       85 ee		      sta	temp7
   6022  2986		       a9 39		      lda	#>(ret_point12-1)
   6023  2988		       48		      pha
   6024  2989		       a9 9b		      lda	#<(ret_point12-1)
   6025  298b		       48		      pha
   6026  298c		       a9 f4		      lda	#>(drawscreen-1)
   6027  298e		       48		      pha
   6028  298f		       a9 3b		      lda	#<(drawscreen-1)
   6029  2991		       48		      pha
   6030  2992		       a5 ee		      lda	temp7
   6031  2994		       48		      pha
   6032  2995		       8a		      txa
   6033  2996		       48		      pha
   6034  2997		       a2 08		      ldx	#8
   6035  2999		       4c eb ff 	      jmp	BS_jsr
   6036  299c				   ret_point12
   6037  299c				   .
   6038  299c							;
   6039  299c
   6040  299c				   .
   6041  299c							;
   6042  299c
   6043  299c				   .
   6044  299c							;
   6045  299c
   6046  299c				   .
   6047  299c							;
   6048  299c
   6049  299c				   .
   6050  299c							;
   6051  299c
   6052  299c				   .
   6053  299c							;
   6054  299c
   6055  299c				   .
   6056  299c							;
   6057  299c
   6058  299c				   .
   6059  299c							;
   6060  299c
   6061  299c				   .
   6062  299c							;
   6063  299c
   6064  299c				   .
   6065  299c							;
   6066  299c
   6067  299c				   .
   6068  299c							;
   6069  299c
   6070  299c				   .
   6071  299c							;
   6072  299c
   6073  299c				   .
   6074  299c							;
   6075  299c
   6076  299c				   .
   6077  299c							;
   6078  299c
   6079  299c				   .
   6080  299c							;
   6081  299c
   6082  299c				   .L0276		;  if !_Bit2_Game_Control{2} then goto __Skip_Check_G_Over
   6083  299c
   6084  299c		       a5 ec		      LDA	_Bit2_Game_Control
   6085  299e		       29 04		      AND	#4
   6086  29a0		       d0 03		      BNE	.skipL0276
   6087  29a2				   .condpart131
   6088  29a2		       4c e1 39 	      jmp	.__Skip_Check_G_Over
   6089  29a5
   6090  29a5				   .skipL0276
   6091  29a5				   .
   6092  29a5							;
   6093  29a5
   6094  29a5				   .
   6095  29a5							;
   6096  29a5
   6097  29a5				   .
   6098  29a5							;
   6099  29a5
   6100  29a5				   .
   6101  29a5							;
   6102  29a5
   6103  29a5				   .
   6104  29a5							;
   6105  29a5
   6106  29a5				   .L0277		;  if _Bit3_Auto_Play{3} then _Bit2_Game_Control{2}  =  0  :  _sc1  =	_Score1_Mem  :	_sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem  :  goto __Start_Restart bank1
   6107  29a5
   6108  29a5		       a5 ec		      LDA	_Bit3_Auto_Play
   6109  29a7		       29 08		      AND	#8
   6110  29a9		       f0 24		      BEQ	.skipL0277
   6111  29ab				   .condpart132
   6112  29ab		       a5 ec		      LDA	_Bit2_Game_Control
   6113  29ad		       29 fb		      AND	#251
   6114  29af		       85 ec		      STA	_Bit2_Game_Control
   6115  29b1		       a5 e6		      LDA	_Score1_Mem
   6116  29b3		       85 93		      STA	_sc1
   6117  29b5		       a5 e7		      LDA	_Score2_Mem
   6118  29b7		       85 94		      STA	_sc2
   6119  29b9		       a5 e8		      LDA	_Score3_Mem
   6120  29bb		       85 95		      STA	_sc3
   6121  29bd		       85 ee		      sta	temp7
   6122  29bf		       a9 10		      lda	#>(.__Start_Restart-1)
   6123  29c1		       48		      pha
   6124  29c2		       a9 0b		      lda	#<(.__Start_Restart-1)
   6125  29c4		       48		      pha
   6126  29c5		       a5 ee		      lda	temp7
   6127  29c7		       48		      pha
   6128  29c8		       8a		      txa
   6129  29c9		       48		      pha
   6130  29ca		       a2 01		      ldx	#1
   6131  29cc		       4c eb ff 	      jmp	BS_jsr
   6132  29cf				   .skipL0277
   6133  29cf				   .
   6134  29cf							;
   6135  29cf
   6136  29cf				   .
   6137  29cf							;
   6138  29cf
   6139  29cf				   .
   6140  29cf							;
   6141  29cf
   6142  29cf				   .
   6143  29cf							;
   6144  29cf
   6145  29cf				   .L0278		;  goto __Game_Over_Setup bank3
   6146  29cf
   6147  29cf		       85 ee		      sta	temp7
   6148  29d1		       a9 4f		      lda	#>(.__Game_Over_Setup-1)
   6149  29d3		       48		      pha
   6150  29d4		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
   6151  29d6		       48		      pha
   6152  29d7		       a5 ee		      lda	temp7
   6153  29d9		       48		      pha
   6154  29da		       8a		      txa
   6155  29db		       48		      pha
   6156  29dc		       a2 03		      ldx	#3
   6157  29de		       4c eb ff 	      jmp	BS_jsr
   6158  29e1				   .
   6159  29e1							;
   6160  29e1
   6161  29e1				   .__Skip_Check_G_Over
   6162  29e1							; __Skip_Check_G_Over
   6163  29e1
   6164  29e1				   .
   6165  29e1							;
   6166  29e1
   6167  29e1				   .
   6168  29e1							;
   6169  29e1
   6170  29e1				   .
   6171  29e1							;
   6172  29e1
   6173  29e1				   .
   6174  29e1							;
   6175  29e1
   6176  29e1				   .
   6177  29e1							;
   6178  29e1
   6179  29e1				   .
   6180  29e1							;
   6181  29e1
   6182  29e1				   .
   6183  29e1							;
   6184  29e1
   6185  29e1				   .
   6186  29e1							;
   6187  29e1
   6188  29e1				   .
   6189  29e1							;
   6190  29e1
   6191  29e1				   .
   6192  29e1							;
   6193  29e1
   6194  29e1				   .
   6195  29e1							;
   6196  29e1
   6197  29e1				   .
   6198  29e1							;
   6199  29e1
   6200  29e1				   .
   6201  29e1							;
   6202  29e1
   6203  29e1				   .
   6204  29e1							;
   6205  29e1
   6206  29e1				   .L0279		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Reset
   6207  29e1
   6208  29e1		       a5 ec		      LDA	_Bit3_Auto_Play
   6209  29e3		       29 08		      AND	#8
   6210  29e5		       d0 03		      BNE	.skipL0279
   6211  29e7				   .condpart133
   6212  29e7		       4c 16 3a 	      jmp	.__AP_Skip_Reset
   6213  29ea
   6214  29ea				   .skipL0279
   6215  29ea				   .
   6216  29ea							;
   6217  29ea
   6218  29ea				   .
   6219  29ea							;
   6220  29ea
   6221  29ea				   .
   6222  29ea							;
   6223  29ea
   6224  29ea				   .
   6225  29ea							;
   6226  29ea
   6227  29ea				   .
   6228  29ea							;
   6229  29ea
   6230  29ea				   .
   6231  29ea							;
   6232  29ea
   6233  29ea				   .L0280		;  if switchreset  ||	joy0fire then _Bit3_Auto_Play{3}  =  0	:  _Bit2_Game_Control{2}  =  1	:  goto __Start_Restart bank1
   6234  29ea
   6235  29ea		       a9 01		      lda	#1
   6236  29ec		       2c 82 02 	      bit	SWCHB
   6237  29ef		       d0 03		      BNE	.skipL0280
   6238  29f1				   .condpart134
   6239  29f1		       4c f8 39 	      jmp	.condpart135
   6240  29f4				   .skipL0280
   6241  29f4		       24 0c		      bit	INPT4
   6242  29f6		       30 1e		      BMI	.skip13OR
   6243  29f8				   .condpart135
   6244  29f8		       a5 ec		      LDA	_Bit3_Auto_Play
   6245  29fa		       29 f7		      AND	#247
   6246  29fc		       85 ec		      STA	_Bit3_Auto_Play
   6247  29fe		       a5 ec		      LDA	_Bit2_Game_Control
   6248  2a00		       09 04		      ORA	#4
   6249  2a02		       85 ec		      STA	_Bit2_Game_Control
   6250  2a04		       85 ee		      sta	temp7
   6251  2a06		       a9 10		      lda	#>(.__Start_Restart-1)
   6252  2a08		       48		      pha
   6253  2a09		       a9 0b		      lda	#<(.__Start_Restart-1)
   6254  2a0b		       48		      pha
   6255  2a0c		       a5 ee		      lda	temp7
   6256  2a0e		       48		      pha
   6257  2a0f		       8a		      txa
   6258  2a10		       48		      pha
   6259  2a11		       a2 01		      ldx	#1
   6260  2a13		       4c eb ff 	      jmp	BS_jsr
   6261  2a16				   .skip13OR
   6262  2a16				   .
   6263  2a16							;
   6264  2a16
   6265  2a16				   .__AP_Skip_Reset
   6266  2a16							; __AP_Skip_Reset
   6267  2a16
   6268  2a16				   .
   6269  2a16							;
   6270  2a16
   6271  2a16				   .
   6272  2a16							;
   6273  2a16
   6274  2a16				   .
   6275  2a16							;
   6276  2a16
   6277  2a16				   .
   6278  2a16							;
   6279  2a16
   6280  2a16				   .
   6281  2a16							;
   6282  2a16
   6283  2a16				   .L0281		;  if !switchreset then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Main_Loop
   6284  2a16
   6285  2a16		       a9 01		      lda	#1
   6286  2a18		       2c 82 02 	      bit	SWCHB
   6287  2a1b		       f0 09		      BEQ	.skipL0281
   6288  2a1d				   .condpart136
   6289  2a1d		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6290  2a1f		       29 fe		      AND	#254
   6291  2a21		       85 ec		      STA	_Bit0_Reset_Restrainer
   6292  2a23		       4c 1b 31 	      jmp	.__Main_Loop
   6293  2a26
   6294  2a26				   .skipL0281
   6295  2a26				   .
   6296  2a26							;
   6297  2a26
   6298  2a26				   .
   6299  2a26							;
   6300  2a26
   6301  2a26				   .
   6302  2a26							;
   6303  2a26
   6304  2a26				   .
   6305  2a26							;
   6306  2a26
   6307  2a26				   .
   6308  2a26							;
   6309  2a26
   6310  2a26				   .L0282		;  if _Bit0_Reset_Restrainer{0} then goto __Main_Loop
   6311  2a26
   6312  2a26		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6313  2a28		       4a		      LSR
   6314  2a29		       90 03		      BCC	.skipL0282
   6315  2a2b				   .condpart137
   6316  2a2b		       4c 1b 31 	      jmp	.__Main_Loop
   6317  2a2e
   6318  2a2e				   .skipL0282
   6319  2a2e				   .
   6320  2a2e							;
   6321  2a2e
   6322  2a2e				   .
   6323  2a2e							;
   6324  2a2e
   6325  2a2e				   .
   6326  2a2e							;
   6327  2a2e
   6328  2a2e				   .
   6329  2a2e							;
   6330  2a2e
   6331  2a2e				   .L0283		;  _Bit2_Game_Control{2}  =  0
   6332  2a2e
   6333  2a2e		       a5 ec		      LDA	_Bit2_Game_Control
   6334  2a30		       29 fb		      AND	#251
   6335  2a32		       85 ec		      STA	_Bit2_Game_Control
   6336  2a34				   .
   6337  2a34							;
   6338  2a34
   6339  2a34				   .
   6340  2a34							;
   6341  2a34
   6342  2a34				   .
   6343  2a34							;
   6344  2a34
   6345  2a34				   .
   6346  2a34							;
   6347  2a34
   6348  2a34				   .
   6349  2a34							;
   6350  2a34
   6351  2a34				   .L0284		;  goto __Game_Over_Setup bank3
   6352  2a34
   6353  2a34		       85 ee		      sta	temp7
   6354  2a36		       a9 4f		      lda	#>(.__Game_Over_Setup-1)
   6355  2a38		       48		      pha
   6356  2a39		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
   6357  2a3b		       48		      pha
   6358  2a3c		       a5 ee		      lda	temp7
   6359  2a3e		       48		      pha
   6360  2a3f		       8a		      txa
   6361  2a40		       48		      pha
   6362  2a41		       a2 03		      ldx	#3
   6363  2a43		       4c eb ff 	      jmp	BS_jsr
   6364  2a46				   .
   6365  2a46							;
   6366  2a46
   6367  2a46				   .
   6368  2a46							;
   6369  2a46
   6370  2a46				   .
   6371  2a46							;
   6372  2a46
   6373  2a46				   .
   6374  2a46							;
   6375  2a46
   6376  2a46				   .
   6377  2a46							;
   6378  2a46
   6379  2a46				   .
   6380  2a46							;
   6381  2a46
   6382  2a46				   .
   6383  2a46							;
   6384  2a46
   6385  2a46				   .
   6386  2a46							;
   6387  2a46
   6388  2a46				   .
   6389  2a46							;
   6390  2a46
   6391  2a46				   .
   6392  2a46							;
   6393  2a46
   6394  2a46				   .
   6395  2a46							;
   6396  2a46
   6397  2a46				   .
   6398  2a46							;
   6399  2a46
   6400  2a46				   .
   6401  2a46							;
   6402  2a46
   6403  2a46				   .
   6404  2a46							;
   6405  2a46
   6406  2a46				   .
   6407  2a46							;
   6408  2a46
   6409  2a46				   .
   6410  2a46							;
   6411  2a46
   6412  2a46				   .
   6413  2a46							;
   6414  2a46
   6415  2a46				   .L0285		;  bank 3
   6416  2a46
   6417  2a46					      if	ECHO2
      1422 bytes of ROM space left in bank 2
   6418  2a46					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   6419  2a46					      endif
   6420  2a46		       00 01	   ECHO2      =	1
   6421  2fd4					      ORG	$2FF4-bscode_length
   6422  2fd4					      RORG	$3FF4-bscode_length
   6423  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   6424  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   6425  2fd6				  -	      stx	FASTFETCH
   6426  2fd6					      endif
   6427  2fd6		       9a		      txs
   6428  2fd7				  -	      if	bankswitch == 64
   6429  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   6430  2fd7					      else
   6431  2fd7		       a9 f2		      lda	#>(start-1)
   6432  2fd9					      endif
   6433  2fd9		       48		      pha
   6434  2fda		       a9 51		      lda	#<(start-1)
   6435  2fdc		       48		      pha
   6436  2fdd		       48		      pha
   6437  2fde		       8a		      txa
   6438  2fdf		       48		      pha
   6439  2fe0		       ba		      tsx
   6440  2fe1					      if	bankswitch != 64
   6441  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   6442  2fe3		       2a		      rol
   6443  2fe4		       2a		      rol
   6444  2fe5		       2a		      rol
   6445  2fe6		       2a		      rol
   6446  2fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   6447  2fe9		       aa		      tax
   6448  2fea		       e8		      inx
   6449  2feb				  -	      else
   6450  2feb				  -	      lda	4,x	; get high byte of return address
   6451  2feb				  -	      tay
   6452  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   6453  2feb				  -	      sta	4,x
   6454  2feb				  -	      tya
   6455  2feb				  -	      lsr
   6456  2feb				  -	      lsr
   6457  2feb				  -	      lsr
   6458  2feb				  -	      lsr
   6459  2feb				  -	      tax
   6460  2feb				  -	      inx
   6461  2feb					      endif
   6462  2feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   6463  2fee		       68		      pla
   6464  2fef		       aa		      tax
   6465  2ff0		       68		      pla
   6466  2ff1		       60		      rts
   6467  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   6468  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   6469  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   6470  2ff2					      endif
   6471  2ffc					      ORG	$2FFC
   6472  2ffc					      RORG	$3FFC
   6473  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   6474  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   6475  3000					      ORG	$3000
   6476  3000					      RORG	$5000
   6477  3000				   .
   6478  3000							;
   6479  3000
   6480  3000				   .
   6481  3000							;
   6482  3000
   6483  3000				   .
   6484  3000							;
   6485  3000
   6486  3000				   .
   6487  3000							;
   6488  3000
   6489  3000				   .
   6490  3000							;
   6491  3000
   6492  3000				   .
   6493  3000							;
   6494  3000
   6495  3000				   .
   6496  3000							;
   6497  3000
   6498  3000				   .
   6499  3000							;
   6500  3000
   6501  3000				   .
   6502  3000							;
   6503  3000
   6504  3000				   .
   6505  3000							;
   6506  3000
   6507  3000				   .
   6508  3000							;
   6509  3000
   6510  3000				   .__Game_Over_Setup
   6511  3000							; __Game_Over_Setup
   6512  3000
   6513  3000				   .
   6514  3000							;
   6515  3000
   6516  3000				   .
   6517  3000							;
   6518  3000
   6519  3000				   .
   6520  3000							;
   6521  3000
   6522  3000				   .
   6523  3000							;
   6524  3000
   6525  3000				   .
   6526  3000							;
   6527  3000
   6528  3000				   .
   6529  3000							;
   6530  3000
   6531  3000				   .
   6532  3000							;
   6533  3000
   6534  3000				   .
   6535  3000							;
   6536  3000
   6537  3000				   .
   6538  3000							;
   6539  3000
   6540  3000				   .
   6541  3000							;
   6542  3000
   6543  3000				   .
   6544  3000							;
   6545  3000
   6546  3000				   .L0286		;  if _sc1  >	_High_Score1 then goto __New_High_Score
   6547  3000
   6548  3000		       a5 e9		      LDA	_High_Score1
   6549  3002		       c5 93		      CMP	_sc1
   6550  3004		       b0 03		      BCS	.skipL0286
   6551  3006				   .condpart138
   6552  3006		       4c 39 50 	      jmp	.__New_High_Score
   6553  3009
   6554  3009				   .skipL0286
   6555  3009				   .L0287		;  if _sc1  <	_High_Score1 then goto __Skip_High_Score
   6556  3009
   6557  3009		       a5 93		      LDA	_sc1
   6558  300b		       c5 e9		      CMP	_High_Score1
   6559  300d		       b0 03		      BCS	.skipL0287
   6560  300f				   .condpart139
   6561  300f		       4c 45 50 	      jmp	.__Skip_High_Score
   6562  3012
   6563  3012				   .skipL0287
   6564  3012				   .
   6565  3012							;
   6566  3012
   6567  3012				   .
   6568  3012							;
   6569  3012
   6570  3012				   .
   6571  3012							;
   6572  3012
   6573  3012				   .
   6574  3012							;
   6575  3012
   6576  3012				   .L0288		;  if _sc2  >	_High_Score2 then goto __New_High_Score
   6577  3012
   6578  3012		       a5 ea		      LDA	_High_Score2
   6579  3014		       c5 94		      CMP	_sc2
   6580  3016		       b0 03		      BCS	.skipL0288
   6581  3018				   .condpart140
   6582  3018		       4c 39 50 	      jmp	.__New_High_Score
   6583  301b
   6584  301b				   .skipL0288
   6585  301b				   .L0289		;  if _sc2  <	_High_Score2 then goto __Skip_High_Score
   6586  301b
   6587  301b		       a5 94		      LDA	_sc2
   6588  301d		       c5 ea		      CMP	_High_Score2
   6589  301f		       b0 03		      BCS	.skipL0289
   6590  3021				   .condpart141
   6591  3021		       4c 45 50 	      jmp	.__Skip_High_Score
   6592  3024
   6593  3024				   .skipL0289
   6594  3024				   .
   6595  3024							;
   6596  3024
   6597  3024				   .
   6598  3024							;
   6599  3024
   6600  3024				   .
   6601  3024							;
   6602  3024
   6603  3024				   .
   6604  3024							;
   6605  3024
   6606  3024				   .L0290		;  if _sc3  >	_High_Score3 then goto __New_High_Score
   6607  3024
   6608  3024		       a5 eb		      LDA	_High_Score3
   6609  3026		       c5 95		      CMP	_sc3
   6610  3028		       b0 03		      BCS	.skipL0290
   6611  302a				   .condpart142
   6612  302a		       4c 39 50 	      jmp	.__New_High_Score
   6613  302d
   6614  302d				   .skipL0290
   6615  302d				   .L0291		;  if _sc3  <	_High_Score3 then goto __Skip_High_Score
   6616  302d
   6617  302d		       a5 95		      LDA	_sc3
   6618  302f		       c5 eb		      CMP	_High_Score3
   6619  3031		       b0 03		      BCS	.skipL0291
   6620  3033				   .condpart143
   6621  3033		       4c 45 50 	      jmp	.__Skip_High_Score
   6622  3036
   6623  3036				   .skipL0291
   6624  3036				   .
   6625  3036							;
   6626  3036
   6627  3036				   .
   6628  3036							;
   6629  3036
   6630  3036				   .
   6631  3036							;
   6632  3036
   6633  3036				   .
   6634  3036							;
   6635  3036
   6636  3036				   .L0292		;  goto __Skip_High_Score
   6637  3036
   6638  3036		       4c 45 50 	      jmp	.__Skip_High_Score
   6639  3039
   6640  3039				   .
   6641  3039							;
   6642  3039
   6643  3039				   .
   6644  3039							;
   6645  3039
   6646  3039				   .
   6647  3039							;
   6648  3039
   6649  3039				   .
   6650  3039							;
   6651  3039
   6652  3039				   .__New_High_Score
   6653  3039							; __New_High_Score
   6654  3039
   6655  3039				   .
   6656  3039							;
   6657  3039
   6658  3039				   .L0293		;  _High_Score1  =  _sc1  :  _High_Score2  =  _sc2  :	_High_Score3  =  _sc3
   6659  3039
   6660  3039		       a5 93		      LDA	_sc1
   6661  303b		       85 e9		      STA	_High_Score1
   6662  303d		       a5 94		      LDA	_sc2
   6663  303f		       85 ea		      STA	_High_Score2
   6664  3041		       a5 95		      LDA	_sc3
   6665  3043		       85 eb		      STA	_High_Score3
   6666  3045				   .
   6667  3045							;
   6668  3045
   6669  3045				   .__Skip_High_Score
   6670  3045							; __Skip_High_Score
   6671  3045
   6672  3045				   .
   6673  3045							;
   6674  3045
   6675  3045				   .
   6676  3045							;
   6677  3045
   6678  3045				   .
   6679  3045							;
   6680  3045
   6681  3045				   .
   6682  3045							;
   6683  3045
   6684  3045				   .
   6685  3045							;
   6686  3045
   6687  3045				   .L0294		;  if !_Bit2_Game_Control{2} then goto __Start_Restart bank1
   6688  3045
   6689  3045		       a5 ec		      LDA	_Bit2_Game_Control
   6690  3047		       29 04		      AND	#4
   6691  3049		       d0 12		      BNE	.skipL0294
   6692  304b				   .condpart144
   6693  304b		       85 ee		      sta	temp7
   6694  304d		       a9 10		      lda	#>(.__Start_Restart-1)
   6695  304f		       48		      pha
   6696  3050		       a9 0b		      lda	#<(.__Start_Restart-1)
   6697  3052		       48		      pha
   6698  3053		       a5 ee		      lda	temp7
   6699  3055		       48		      pha
   6700  3056		       8a		      txa
   6701  3057		       48		      pha
   6702  3058		       a2 01		      ldx	#1
   6703  305a		       4c eb ff 	      jmp	BS_jsr
   6704  305d				   .skipL0294
   6705  305d				   .
   6706  305d							;
   6707  305d
   6708  305d				   .
   6709  305d							;
   6710  305d
   6711  305d				   .
   6712  305d							;
   6713  305d
   6714  305d				   .
   6715  305d							;
   6716  305d
   6717  305d				   .
   6718  305d							;
   6719  305d
   6720  305d				   .
   6721  305d							;
   6722  305d
   6723  305d				   .L0295		;  _Score1_Mem  =  _sc1  :  _Score2_Mem  =  _sc2  :  _Score3_Mem  =  _sc3
   6724  305d
   6725  305d		       a5 93		      LDA	_sc1
   6726  305f		       85 e6		      STA	_Score1_Mem
   6727  3061		       a5 94		      LDA	_sc2
   6728  3063		       85 e7		      STA	_Score2_Mem
   6729  3065		       a5 95		      LDA	_sc3
   6730  3067		       85 e8		      STA	_Score3_Mem
   6731  3069				   .
   6732  3069							;
   6733  3069
   6734  3069				   .
   6735  3069							;
   6736  3069
   6737  3069				   .
   6738  3069							;
   6739  3069
   6740  3069				   .
   6741  3069							;
   6742  3069
   6743  3069				   .
   6744  3069							;
   6745  3069
   6746  3069				   .
   6747  3069							;
   6748  3069
   6749  3069				   .L0296		;  _Master_Counter  =	0  :  _Frame_Counter  =  0
   6750  3069
   6751  3069		       a9 00		      LDA	#0
   6752  306b		       85 d8		      STA	_Master_Counter
   6753  306d		       85 d9		      STA	_Frame_Counter
   6754  306f				   .
   6755  306f							;
   6756  306f
   6757  306f				   .
   6758  306f							;
   6759  306f
   6760  306f				   .
   6761  306f							;
   6762  306f
   6763  306f				   .
   6764  306f							;
   6765  306f
   6766  306f				   .
   6767  306f							;
   6768  306f
   6769  306f				   .
   6770  306f							;
   6771  306f
   6772  306f				   .L0297		;  player0y  =  200  :  player1y  =  200  :  missile1y  =  200
   6773  306f
   6774  306f		       a9 c8		      LDA	#200
   6775  3071		       85 85		      STA	player0y
   6776  3073		       85 86		      STA	player1y
   6777  3075		       85 88		      STA	missile1y
   6778  3077				   .
   6779  3077							;
   6780  3077
   6781  3077				   .
   6782  3077							;
   6783  3077
   6784  3077				   .
   6785  3077							;
   6786  3077
   6787  3077				   .
   6788  3077							;
   6789  3077
   6790  3077				   .
   6791  3077							;
   6792  3077
   6793  3077				   .
   6794  3077							;
   6795  3077
   6796  3077				   .
   6797  3077							;
   6798  3077
   6799  3077				   .
   6800  3077							;
   6801  3077
   6802  3077				   .
   6803  3077							;
   6804  3077
   6805  3077				   .
   6806  3077							;
   6807  3077
   6808  3077				   .
   6809  3077							;
   6810  3077
   6811  3077				   .L0298		;  _Bit0_Reset_Restrainer{0}  =  1
   6812  3077
   6813  3077		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6814  3079		       09 01		      ORA	#1
   6815  307b		       85 ec		      STA	_Bit0_Reset_Restrainer
   6816  307d				   .
   6817  307d							;
   6818  307d
   6819  307d				   .
   6820  307d							;
   6821  307d
   6822  307d				   .
   6823  307d							;
   6824  307d
   6825  307d				   .
   6826  307d							;
   6827  307d
   6828  307d				   .
   6829  307d							;
   6830  307d
   6831  307d				   .
   6832  307d							;
   6833  307d
   6834  307d				   .L0299		;  playfield:
   6835  307d
   6836  307d				  -	      ifconst	pfres
   6837  307d				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   6838  307d					      else
   6839  307d		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   6840  307f					      endif
   6841  307f		       4c ae 50 	      jmp	pflabel2
   6842  3082				   PF_data2
   6843  3082		       7e bf		      .byte.b	%01111110, %10111111
   6844  3084					      if	(pfwidth>2)
   6845  3084		       ff 7d		      .byte.b	%11111111, %01111101
   6846  3086					      endif
   6847  3086		       60 b3		      .byte.b	%01100000, %10110011
   6848  3088					      if	(pfwidth>2)
   6849  3088		       99 0d		      .byte.b	%10011001, %00001101
   6850  308a					      endif
   6851  308a		       6e bf		      .byte.b	%01101110, %10111111
   6852  308c					      if	(pfwidth>2)
   6853  308c		       99 3d		      .byte.b	%10011001, %00111101
   6854  308e					      endif
   6855  308e		       66 b3		      .byte.b	%01100110, %10110011
   6856  3090					      if	(pfwidth>2)
   6857  3090		       99 0d		      .byte.b	%10011001, %00001101
   6858  3092					      endif
   6859  3092		       7e b3		      .byte.b	%01111110, %10110011
   6860  3094					      if	(pfwidth>2)
   6861  3094		       99 7d		      .byte.b	%10011001, %01111101
   6862  3096					      endif
   6863  3096		       00 00		      .byte.b	%00000000, %00000000
   6864  3098					      if	(pfwidth>2)
   6865  3098		       00 00		      .byte.b	%00000000, %00000000
   6866  309a					      endif
   6867  309a		       1f cd		      .byte.b	%00011111, %11001101
   6868  309c					      if	(pfwidth>2)
   6869  309c		       7d 1f		      .byte.b	%01111101, %00011111
   6870  309e					      endif
   6871  309e		       19 cd		      .byte.b	%00011001, %11001101
   6872  30a0					      if	(pfwidth>2)
   6873  30a0		       61 19		      .byte.b	%01100001, %00011001
   6874  30a2					      endif
   6875  30a2		       19 cd		      .byte.b	%00011001, %11001101
   6876  30a4					      if	(pfwidth>2)
   6877  30a4		       79 0f		      .byte.b	%01111001, %00001111
   6878  30a6					      endif
   6879  30a6		       19 cd		      .byte.b	%00011001, %11001101
   6880  30a8					      if	(pfwidth>2)
   6881  30a8		       61 19		      .byte.b	%01100001, %00011001
   6882  30aa					      endif
   6883  30aa		       1f 31		      .byte.b	%00011111, %00110001
   6884  30ac					      if	(pfwidth>2)
   6885  30ac		       7d 19		      .byte.b	%01111101, %00011001
   6886  30ae					      endif
   6887  30ae				   pflabel2
   6888  30ae		       bd 82 50 	      lda	PF_data2,x
   6889  30b1		       95 a4		      sta	playfield,x
   6890  30b3		       ca		      dex
   6891  30b4		       10 f8		      bpl	pflabel2
   6892  30b6				   .
   6893  30b6							;
   6894  30b6
   6895  30b6				   .
   6896  30b6							;
   6897  30b6
   6898  30b6				   .
   6899  30b6							;
   6900  30b6
   6901  30b6				   .
   6902  30b6							;
   6903  30b6
   6904  30b6				   .
   6905  30b6							;
   6906  30b6
   6907  30b6				   .
   6908  30b6							;
   6909  30b6
   6910  30b6				   .
   6911  30b6							;
   6912  30b6
   6913  30b6				   .
   6914  30b6							;
   6915  30b6
   6916  30b6				   .
   6917  30b6							;
   6918  30b6
   6919  30b6				   .
   6920  30b6							;
   6921  30b6
   6922  30b6				   .
   6923  30b6							;
   6924  30b6
   6925  30b6				   .__Game_Over_Loop
   6926  30b6							; __Game_Over_Loop
   6927  30b6
   6928  30b6				   .
   6929  30b6							;
   6930  30b6
   6931  30b6				   .
   6932  30b6							;
   6933  30b6
   6934  30b6				   .
   6935  30b6							;
   6936  30b6
   6937  30b6				   .
   6938  30b6							;
   6939  30b6
   6940  30b6				   .
   6941  30b6							;
   6942  30b6
   6943  30b6				   .
   6944  30b6							;
   6945  30b6
   6946  30b6				   .
   6947  30b6							;
   6948  30b6
   6949  30b6				   .
   6950  30b6							;
   6951  30b6
   6952  30b6				   .
   6953  30b6							;
   6954  30b6
   6955  30b6				   .
   6956  30b6							;
   6957  30b6
   6958  30b6				   .
   6959  30b6							;
   6960  30b6
   6961  30b6				   .
   6962  30b6							;
   6963  30b6
   6964  30b6				   .
   6965  30b6							;
   6966  30b6
   6967  30b6				   .
   6968  30b6							;
   6969  30b6
   6970  30b6				   .
   6971  30b6							;
   6972  30b6
   6973  30b6				   .
   6974  30b6							;
   6975  30b6
   6976  30b6				   .
   6977  30b6							;
   6978  30b6
   6979  30b6				   .
   6980  30b6							;
   6981  30b6
   6982  30b6				   .
   6983  30b6							;
   6984  30b6
   6985  30b6				   .L0300		;  _Master_Counter  =	_Master_Counter  +  1
   6986  30b6
   6987  30b6		       e6 d8		      INC	_Master_Counter
   6988  30b8				   .
   6989  30b8							;
   6990  30b8
   6991  30b8				   .
   6992  30b8							;
   6993  30b8
   6994  30b8				   .
   6995  30b8							;
   6996  30b8
   6997  30b8				   .
   6998  30b8							;
   6999  30b8
   7000  30b8				   .
   7001  30b8							;
   7002  30b8
   7003  30b8				   .L0301		;  if _Master_Counter	<  120 then goto __Skip_20_Second_Counter
   7004  30b8
   7005  30b8		       a5 d8		      LDA	_Master_Counter
   7006  30ba		       c9 78		      CMP	#120
   7007  30bc		       b0 03		      BCS	.skipL0301
   7008  30be				   .condpart145
   7009  30be		       4c 33 51 	      jmp	.__Skip_20_Second_Counter
   7010  30c1
   7011  30c1				   .skipL0301
   7012  30c1				   .
   7013  30c1							;
   7014  30c1
   7015  30c1				   .
   7016  30c1							;
   7017  30c1
   7018  30c1				   .
   7019  30c1							;
   7020  30c1
   7021  30c1				   .
   7022  30c1							;
   7023  30c1
   7024  30c1				   .
   7025  30c1							;
   7026  30c1
   7027  30c1				   .L0302		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
   7028  30c1
   7029  30c1		       e6 d9		      INC	_Frame_Counter
   7030  30c3		       a9 00		      LDA	#0
   7031  30c5		       85 d8		      STA	_Master_Counter
   7032  30c7				   .
   7033  30c7							;
   7034  30c7
   7035  30c7				   .
   7036  30c7							;
   7037  30c7
   7038  30c7				   .
   7039  30c7							;
   7040  30c7
   7041  30c7				   .
   7042  30c7							;
   7043  30c7
   7044  30c7				   .
   7045  30c7							;
   7046  30c7
   7047  30c7				   .
   7048  30c7							;
   7049  30c7
   7050  30c7				   .
   7051  30c7							;
   7052  30c7
   7053  30c7				   .
   7054  30c7							;
   7055  30c7
   7056  30c7				   .L0303		;  if _Frame_Counter  >  9 then _Bit2_Game_Control{2}	=  0  :  _sc1 = _Score1_Mem  :	_sc2 = _Score2_Mem  :  _sc3 = _Score3_Mem :  goto __Start_Restart bank1
   7057  30c7
   7058  30c7		       a9 09		      LDA	#9
   7059  30c9		       c5 d9		      CMP	_Frame_Counter
   7060  30cb		       b0 24		      BCS	.skipL0303
   7061  30cd				   .condpart146
   7062  30cd		       a5 ec		      LDA	_Bit2_Game_Control
   7063  30cf		       29 fb		      AND	#251
   7064  30d1		       85 ec		      STA	_Bit2_Game_Control
   7065  30d3		       a5 e6		      LDA	_Score1_Mem
   7066  30d5		       85 93		      STA	_sc1
   7067  30d7		       a5 e7		      LDA	_Score2_Mem
   7068  30d9		       85 94		      STA	_sc2
   7069  30db		       a5 e8		      LDA	_Score3_Mem
   7070  30dd		       85 95		      STA	_sc3
   7071  30df		       85 ee		      sta	temp7
   7072  30e1		       a9 10		      lda	#>(.__Start_Restart-1)
   7073  30e3		       48		      pha
   7074  30e4		       a9 0b		      lda	#<(.__Start_Restart-1)
   7075  30e6		       48		      pha
   7076  30e7		       a5 ee		      lda	temp7
   7077  30e9		       48		      pha
   7078  30ea		       8a		      txa
   7079  30eb		       48		      pha
   7080  30ec		       a2 01		      ldx	#1
   7081  30ee		       4c eb ff 	      jmp	BS_jsr
   7082  30f1				   .skipL0303
   7083  30f1				   .
   7084  30f1							;
   7085  30f1
   7086  30f1				   .
   7087  30f1							;
   7088  30f1
   7089  30f1				   .
   7090  30f1							;
   7091  30f1
   7092  30f1				   .
   7093  30f1							;
   7094  30f1
   7095  30f1				   .L0304		;  _Bit6_Swap_Scores{6}  =  !_Bit6_Swap_Scores{6}
   7096  30f1
   7097  30f1		       a5 ec		      LDA	_Bit6_Swap_Scores
   7098  30f3		       29 40		      AND	#64
   7099  30f5		       08		      PHP
   7100  30f6		       a5 ec		      LDA	_Bit6_Swap_Scores
   7101  30f8		       29 bf		      AND	#191
   7102  30fa		       28		      PLP
   7103  30fb		       d0 02		      .byte.b	$D0, $02
   7104  30fd		       09 40		      ORA	#64
   7105  30ff		       85 ec		      STA	_Bit6_Swap_Scores
   7106  3101				   .
   7107  3101							;
   7108  3101
   7109  3101				   .
   7110  3101							;
   7111  3101
   7112  3101				   .
   7113  3101							;
   7114  3101
   7115  3101				   .
   7116  3101							;
   7117  3101
   7118  3101				   .L0305		;  if !_Bit6_Swap_Scores{6} then goto __GO_Current_Score
   7119  3101
   7120  3101		       24 ec		      BIT	_Bit6_Swap_Scores
   7121  3103		       70 03		      BVS	.skipL0305
   7122  3105				   .condpart147
   7123  3105		       4c 1f 51 	      jmp	.__GO_Current_Score
   7124  3108
   7125  3108				   .skipL0305
   7126  3108				   .
   7127  3108							;
   7128  3108
   7129  3108				   .
   7130  3108							;
   7131  3108
   7132  3108				   .
   7133  3108							;
   7134  3108
   7135  3108				   .
   7136  3108							;
   7137  3108
   7138  3108				   .L0306		;  scorecolor	=  $AE
   7139  3108
   7140  3108		       a9 ae		      LDA	#$AE
   7141  310a		       85 a3		      STA	scorecolor
   7142  310c				   .L0307		;  pfscorecolor  =  $AE
   7143  310c
   7144  310c		       a9 ae		      LDA	#$AE
   7145  310e		       85 f4		      STA	pfscorecolor
   7146  3110				   .
   7147  3110							;
   7148  3110
   7149  3110				   .L0308		;  _sc1  =  _High_Score1  :  _sc2  =  _High_Score2  :	_sc3  =  _High_Score3
   7150  3110
   7151  3110		       a5 e9		      LDA	_High_Score1
   7152  3112		       85 93		      STA	_sc1
   7153  3114		       a5 ea		      LDA	_High_Score2
   7154  3116		       85 94		      STA	_sc2
   7155  3118		       a5 eb		      LDA	_High_Score3
   7156  311a		       85 95		      STA	_sc3
   7157  311c				   .
   7158  311c							;
   7159  311c
   7160  311c				   .L0309		;  goto __Skip_20_Second_Counter
   7161  311c
   7162  311c		       4c 33 51 	      jmp	.__Skip_20_Second_Counter
   7163  311f
   7164  311f				   .
   7165  311f							;
   7166  311f
   7167  311f				   .
   7168  311f							;
   7169  311f
   7170  311f				   .
   7171  311f							;
   7172  311f
   7173  311f				   .
   7174  311f							;
   7175  311f
   7176  311f				   .__GO_Current_Score
   7177  311f							; __GO_Current_Score
   7178  311f
   7179  311f				   .
   7180  311f							;
   7181  311f
   7182  311f				   .L0310		;  scorecolor	=  $1C
   7183  311f
   7184  311f		       a9 1c		      LDA	#$1C
   7185  3121		       85 a3		      STA	scorecolor
   7186  3123				   .L0311		;  pfscorecolor  =  $1C
   7187  3123
   7188  3123		       a9 1c		      LDA	#$1C
   7189  3125		       85 f4		      STA	pfscorecolor
   7190  3127				   .
   7191  3127							;
   7192  3127
   7193  3127				   .L0312		;  _sc1  =  _Score1_Mem  :  _sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem
   7194  3127
   7195  3127		       a5 e6		      LDA	_Score1_Mem
   7196  3129		       85 93		      STA	_sc1
   7197  312b		       a5 e7		      LDA	_Score2_Mem
   7198  312d		       85 94		      STA	_sc2
   7199  312f		       a5 e8		      LDA	_Score3_Mem
   7200  3131		       85 95		      STA	_sc3
   7201  3133				   .
   7202  3133							;
   7203  3133
   7204  3133				   .__Skip_20_Second_Counter
   7205  3133							; __Skip_20_Second_Counter
   7206  3133
   7207  3133				   .
   7208  3133							;
   7209  3133
   7210  3133				   .
   7211  3133							;
   7212  3133
   7213  3133				   .
   7214  3133							;
   7215  3133
   7216  3133				   .
   7217  3133							;
   7218  3133
   7219  3133				   .
   7220  3133							;
   7221  3133
   7222  3133				   .
   7223  3133							;
   7224  3133
   7225  3133				   .
   7226  3133							;
   7227  3133
   7228  3133				   .
   7229  3133							;
   7230  3133
   7231  3133				   .
   7232  3133							;
   7233  3133
   7234  3133				   .
   7235  3133							;
   7236  3133
   7237  3133				   .
   7238  3133							;
   7239  3133
   7240  3133				   .
   7241  3133							;
   7242  3133
   7243  3133				   .
   7244  3133							;
   7245  3133
   7246  3133				   .
   7247  3133							;
   7248  3133
   7249  3133				   .L0313		;  if _Frame_Counter then goto __Skip_First_Colors
   7250  3133
   7251  3133		       a5 d9		      LDA	_Frame_Counter
   7252  3135		       f0 03		      BEQ	.skipL0313
   7253  3137				   .condpart148
   7254  3137		       4c 4d 51 	      jmp	.__Skip_First_Colors
   7255  313a
   7256  313a				   .skipL0313
   7257  313a				   .
   7258  313a							;
   7259  313a
   7260  313a				   .
   7261  313a							;
   7262  313a
   7263  313a				   .
   7264  313a							;
   7265  313a
   7266  313a				   .
   7267  313a							;
   7268  313a
   7269  313a				   .L0314		;  COLUBK  =  $44
   7270  313a
   7271  313a		       a9 44		      LDA	#$44
   7272  313c		       85 09		      STA	COLUBK
   7273  313e				   .
   7274  313e							;
   7275  313e
   7276  313e				   .
   7277  313e							;
   7278  313e
   7279  313e				   .
   7280  313e							;
   7281  313e
   7282  313e				   .
   7283  313e							;
   7284  313e
   7285  313e				   .L0315		;  pfcolors:
   7286  313e
   7287  313e		       a9 2e		      lda	# $2E
   7288  3140		       85 08		      sta	COLUPF
   7289  3142				  -	      ifconst	pfres
   7290  3142				  -	      lda	#>(pfcolorlabel13-130+pfres*pfwidth)
   7291  3142					      else
   7292  3142		       a9 f5		      lda	#>(pfcolorlabel13-82)
   7293  3144					      endif
   7294  3144		       85 f1		      sta	pfcolortable+1
   7295  3146				  -	      ifconst	pfres
   7296  3146				  -	      lda	#<(pfcolorlabel13-130+pfres*pfwidth)
   7297  3146					      else
   7298  3146		       a9 06		      lda	#<(pfcolorlabel13-82)
   7299  3148					      endif
   7300  3148		       85 f0		      sta	pfcolortable
   7301  314a				   .
   7302  314a							;
   7303  314a
   7304  314a				   .L0316		;  goto __Skip_Second_Colors
   7305  314a
   7306  314a		       4c 5d 51 	      jmp	.__Skip_Second_Colors
   7307  314d
   7308  314d				   .
   7309  314d							;
   7310  314d
   7311  314d				   .__Skip_First_Colors
   7312  314d							; __Skip_First_Colors
   7313  314d
   7314  314d				   .
   7315  314d							;
   7316  314d
   7317  314d				   .
   7318  314d							;
   7319  314d
   7320  314d				   .
   7321  314d							;
   7322  314d
   7323  314d				   .
   7324  314d							;
   7325  314d
   7326  314d				   .L0317		;  COLUBK  =  $D2
   7327  314d
   7328  314d		       a9 d2		      LDA	#$D2
   7329  314f		       85 09		      STA	COLUBK
   7330  3151				   .
   7331  3151							;
   7332  3151
   7333  3151				   .
   7334  3151							;
   7335  3151
   7336  3151				   .
   7337  3151							;
   7338  3151
   7339  3151				   .
   7340  3151							;
   7341  3151
   7342  3151				   .L0318		;  pfcolors:
   7343  3151
   7344  3151		       a9 de		      lda	# $DE
   7345  3153		       85 08		      sta	COLUPF
   7346  3155				  -	      ifconst	pfres
   7347  3155				  -	      lda	#>(pfcolorlabel13-129+pfres*pfwidth)
   7348  3155					      else
   7349  3155		       a9 f5		      lda	#>(pfcolorlabel13-81)
   7350  3157					      endif
   7351  3157		       85 f1		      sta	pfcolortable+1
   7352  3159				  -	      ifconst	pfres
   7353  3159				  -	      lda	#<(pfcolorlabel13-129+pfres*pfwidth)
   7354  3159					      else
   7355  3159		       a9 07		      lda	#<(pfcolorlabel13-81)
   7356  315b					      endif
   7357  315b		       85 f0		      sta	pfcolortable
   7358  315d				   .
   7359  315d							;
   7360  315d
   7361  315d				   .__Skip_Second_Colors
   7362  315d							; __Skip_Second_Colors
   7363  315d
   7364  315d				   .
   7365  315d							;
   7366  315d
   7367  315d				   .
   7368  315d							;
   7369  315d
   7370  315d				   .
   7371  315d							;
   7372  315d
   7373  315d				   .
   7374  315d							;
   7375  315d
   7376  315d				   .
   7377  315d							;
   7378  315d
   7379  315d				   .
   7380  315d							;
   7381  315d
   7382  315d				   .
   7383  315d							;
   7384  315d
   7385  315d				   .L0319		;  drawscreen
   7386  315d
   7387  315d		       85 ee		      sta	temp7
   7388  315f		       a9 51		      lda	#>(ret_point13-1)
   7389  3161		       48		      pha
   7390  3162		       a9 74		      lda	#<(ret_point13-1)
   7391  3164		       48		      pha
   7392  3165		       a9 f4		      lda	#>(drawscreen-1)
   7393  3167		       48		      pha
   7394  3168		       a9 3b		      lda	#<(drawscreen-1)
   7395  316a		       48		      pha
   7396  316b		       a5 ee		      lda	temp7
   7397  316d		       48		      pha
   7398  316e		       8a		      txa
   7399  316f		       48		      pha
   7400  3170		       a2 08		      ldx	#8
   7401  3172		       4c eb ff 	      jmp	BS_jsr
   7402  3175				   ret_point13
   7403  3175				   .
   7404  3175							;
   7405  3175
   7406  3175				   .
   7407  3175							;
   7408  3175
   7409  3175				   .
   7410  3175							;
   7411  3175
   7412  3175				   .
   7413  3175							;
   7414  3175
   7415  3175				   .
   7416  3175							;
   7417  3175
   7418  3175				   .
   7419  3175							;
   7420  3175
   7421  3175				   .
   7422  3175							;
   7423  3175
   7424  3175				   .
   7425  3175							;
   7426  3175
   7427  3175				   .
   7428  3175							;
   7429  3175
   7430  3175				   .
   7431  3175							;
   7432  3175
   7433  3175				   .
   7434  3175							;
   7435  3175
   7436  3175				   .
   7437  3175							;
   7438  3175
   7439  3175				   .
   7440  3175							;
   7441  3175
   7442  3175				   .
   7443  3175							;
   7444  3175
   7445  3175				   .L0320		;  if _Frame_Counter  =  0 then goto __Game_Over_Loop
   7446  3175
   7447  3175		       a5 d9		      LDA	_Frame_Counter
   7448  3177		       c9 00		      CMP	#0
   7449  3179		       d0 03		      BNE	.skipL0320
   7450  317b				   .condpart149
   7451  317b		       4c b6 50 	      jmp	.__Game_Over_Loop
   7452  317e
   7453  317e				   .skipL0320
   7454  317e				   .
   7455  317e							;
   7456  317e
   7457  317e				   .
   7458  317e							;
   7459  317e
   7460  317e				   .
   7461  317e							;
   7462  317e
   7463  317e				   .
   7464  317e							;
   7465  317e
   7466  317e				   .
   7467  317e							;
   7468  317e
   7469  317e				   .L0321		;  if !switchreset  &&  !joy0fire then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Game_Over_Loop
   7470  317e
   7471  317e		       a9 01		      lda	#1
   7472  3180		       2c 82 02 	      bit	SWCHB
   7473  3183		       f0 0d		      BEQ	.skipL0321
   7474  3185				   .condpart150
   7475  3185		       24 0c		      bit	INPT4
   7476  3187		       10 09		      BPL	.skip150then
   7477  3189				   .condpart151
   7478  3189		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   7479  318b		       29 fe		      AND	#254
   7480  318d		       85 ec		      STA	_Bit0_Reset_Restrainer
   7481  318f		       4c b6 50 	      jmp	.__Game_Over_Loop
   7482  3192
   7483  3192				   .skip150then
   7484  3192				   .skipL0321
   7485  3192				   .
   7486  3192							;
   7487  3192
   7488  3192				   .
   7489  3192							;
   7490  3192
   7491  3192				   .
   7492  3192							;
   7493  3192
   7494  3192				   .
   7495  3192							;
   7496  3192
   7497  3192				   .
   7498  3192							;
   7499  3192
   7500  3192				   .L0322		;  if _Bit0_Reset_Restrainer{0} then goto __Game_Over_Loop
   7501  3192
   7502  3192		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   7503  3194		       4a		      LSR
   7504  3195		       90 03		      BCC	.skipL0322
   7505  3197				   .condpart152
   7506  3197		       4c b6 50 	      jmp	.__Game_Over_Loop
   7507  319a
   7508  319a				   .skipL0322
   7509  319a				   .
   7510  319a							;
   7511  319a
   7512  319a				   .
   7513  319a							;
   7514  319a
   7515  319a				   .
   7516  319a							;
   7517  319a
   7518  319a				   .
   7519  319a							;
   7520  319a
   7521  319a				   .L0323		;  goto __Start_Restart bank1
   7522  319a
   7523  319a		       85 ee		      sta	temp7
   7524  319c		       a9 10		      lda	#>(.__Start_Restart-1)
   7525  319e		       48		      pha
   7526  319f		       a9 0b		      lda	#<(.__Start_Restart-1)
   7527  31a1		       48		      pha
   7528  31a2		       a5 ee		      lda	temp7
   7529  31a4		       48		      pha
   7530  31a5		       8a		      txa
   7531  31a6		       48		      pha
   7532  31a7		       a2 01		      ldx	#1
   7533  31a9		       4c eb ff 	      jmp	BS_jsr
   7534  31ac				   .
   7535  31ac							;
   7536  31ac
   7537  31ac				   .
   7538  31ac							;
   7539  31ac
   7540  31ac				   .
   7541  31ac							;
   7542  31ac
   7543  31ac				   .
   7544  31ac							;
   7545  31ac
   7546  31ac				   .
   7547  31ac							;
   7548  31ac
   7549  31ac				   .
   7550  31ac							;
   7551  31ac
   7552  31ac				   .
   7553  31ac							;
   7554  31ac
   7555  31ac				   .
   7556  31ac							;
   7557  31ac
   7558  31ac				   .
   7559  31ac							;
   7560  31ac
   7561  31ac				   .
   7562  31ac							;
   7563  31ac
   7564  31ac				   .
   7565  31ac							;
   7566  31ac
   7567  31ac				   .
   7568  31ac							;
   7569  31ac
   7570  31ac				   .
   7571  31ac							;
   7572  31ac
   7573  31ac				   .
   7574  31ac							;
   7575  31ac
   7576  31ac				   .
   7577  31ac							;
   7578  31ac
   7579  31ac				   .
   7580  31ac							;
   7581  31ac
   7582  31ac				   .
   7583  31ac							;
   7584  31ac
   7585  31ac				   .
   7586  31ac							;
   7587  31ac
   7588  31ac				   .
   7589  31ac							;
   7590  31ac
   7591  31ac				   .
   7592  31ac							;
   7593  31ac
   7594  31ac				   .
   7595  31ac							;
   7596  31ac
   7597  31ac				   .
   7598  31ac							;
   7599  31ac
   7600  31ac				   .__Pause_Setup
   7601  31ac							; __Pause_Setup
   7602  31ac
   7603  31ac				   .
   7604  31ac							;
   7605  31ac
   7606  31ac				   .
   7607  31ac							;
   7608  31ac
   7609  31ac				   .
   7610  31ac							;
   7611  31ac
   7612  31ac				   .
   7613  31ac							;
   7614  31ac
   7615  31ac				   .
   7616  31ac							;
   7617  31ac
   7618  31ac				   .
   7619  31ac							;
   7620  31ac
   7621  31ac				   .L0324		;  AUDV0  =  0  :  AUDV1  =  0
   7622  31ac
   7623  31ac		       a9 00		      LDA	#0
   7624  31ae		       85 19		      STA	AUDV0
   7625  31b0		       85 1a		      STA	AUDV1
   7626  31b2				   .
   7627  31b2							;
   7628  31b2
   7629  31b2				   .
   7630  31b2							;
   7631  31b2
   7632  31b2				   .
   7633  31b2							;
   7634  31b2
   7635  31b2				   .
   7636  31b2							;
   7637  31b2
   7638  31b2				   .
   7639  31b2							;
   7640  31b2
   7641  31b2				   .
   7642  31b2							;
   7643  31b2
   7644  31b2				   .L0325		;  _Bit1_FireB_Restrainer{1}  =  1
   7645  31b2
   7646  31b2		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   7647  31b4		       09 02		      ORA	#2
   7648  31b6		       85 ec		      STA	_Bit1_FireB_Restrainer
   7649  31b8				   .
   7650  31b8							;
   7651  31b8
   7652  31b8				   .
   7653  31b8							;
   7654  31b8
   7655  31b8				   .
   7656  31b8							;
   7657  31b8
   7658  31b8				   .
   7659  31b8							;
   7660  31b8
   7661  31b8				   .
   7662  31b8							;
   7663  31b8
   7664  31b8				   .
   7665  31b8							;
   7666  31b8
   7667  31b8				   .L0326		;  _Pause_Counter_Tmp	=  0
   7668  31b8
   7669  31b8		       a9 00		      LDA	#0
   7670  31ba		       85 db		      STA	_Pause_Counter_Tmp
   7671  31bc				   .
   7672  31bc							;
   7673  31bc
   7674  31bc				   .
   7675  31bc							;
   7676  31bc
   7677  31bc				   .
   7678  31bc							;
   7679  31bc
   7680  31bc				   .
   7681  31bc							;
   7682  31bc
   7683  31bc				   .
   7684  31bc							;
   7685  31bc
   7686  31bc				   .
   7687  31bc							;
   7688  31bc
   7689  31bc				   .L0327		;  _Pause_Color_Tmp  =   ( rand & 7 )
   7690  31bc
   7691  31bc							; complex statement detected
   7692  31bc		       a5 a2		      lda	rand
   7693  31be		       4a		      lsr
   7694  31bf					      ifconst	rand16
   7695  31bf		       26 ed		      rol	rand16
   7696  31c1					      endif
   7697  31c1		       90 02		      bcc	*+4
   7698  31c3		       49 b4		      eor	#$B4
   7699  31c5		       85 a2		      sta	rand
   7700  31c7					      ifconst	rand16
   7701  31c7		       45 ed		      eor	rand16
   7702  31c9					      endif
   7703  31c9		       29 07		      AND	#7
   7704  31cb		       85 df		      STA	_Pause_Color_Tmp
   7705  31cd				   .
   7706  31cd							;
   7707  31cd
   7708  31cd				   .L0328		;  _Pause_Mem_Color_Tmp  =  _Pause_Color_Tmp
   7709  31cd
   7710  31cd		       a5 df		      LDA	_Pause_Color_Tmp
   7711  31cf		       85 de		      STA	_Pause_Mem_Color_Tmp
   7712  31d1				   .
   7713  31d1							;
   7714  31d1
   7715  31d1				   .
   7716  31d1							;
   7717  31d1
   7718  31d1				   .
   7719  31d1							;
   7720  31d1
   7721  31d1				   .
   7722  31d1							;
   7723  31d1
   7724  31d1				   .
   7725  31d1							;
   7726  31d1
   7727  31d1				   .
   7728  31d1							;
   7729  31d1
   7730  31d1				   .
   7731  31d1							;
   7732  31d1
   7733  31d1				   .
   7734  31d1							;
   7735  31d1
   7736  31d1				   .
   7737  31d1							;
   7738  31d1
   7739  31d1				   .
   7740  31d1							;
   7741  31d1
   7742  31d1				   .__Pause_Game
   7743  31d1							; __Pause_Game
   7744  31d1
   7745  31d1				   .
   7746  31d1							;
   7747  31d1
   7748  31d1				   .
   7749  31d1							;
   7750  31d1
   7751  31d1				   .
   7752  31d1							;
   7753  31d1
   7754  31d1				   .
   7755  31d1							;
   7756  31d1
   7757  31d1				   .
   7758  31d1							;
   7759  31d1
   7760  31d1				   .
   7761  31d1							;
   7762  31d1
   7763  31d1				   .
   7764  31d1							;
   7765  31d1
   7766  31d1				   .L0329		;  NUSIZ1  =  $10
   7767  31d1
   7768  31d1		       a9 10		      LDA	#$10
   7769  31d3		       85 05		      STA	NUSIZ1
   7770  31d5				   .
   7771  31d5							;
   7772  31d5
   7773  31d5				   .
   7774  31d5							;
   7775  31d5
   7776  31d5				   .
   7777  31d5							;
   7778  31d5
   7779  31d5				   .
   7780  31d5							;
   7781  31d5
   7782  31d5				   .
   7783  31d5							;
   7784  31d5
   7785  31d5				   .
   7786  31d5							;
   7787  31d5
   7788  31d5				   .
   7789  31d5							;
   7790  31d5
   7791  31d5				   .
   7792  31d5							;
   7793  31d5
   7794  31d5				   .
   7795  31d5							;
   7796  31d5
   7797  31d5				   .
   7798  31d5							;
   7799  31d5
   7800  31d5				   .L0330		;  _Pause_Counter_Tmp	=  _Pause_Counter_Tmp  +  1
   7801  31d5
   7802  31d5		       e6 db		      INC	_Pause_Counter_Tmp
   7803  31d7				   .
   7804  31d7							;
   7805  31d7
   7806  31d7				   .
   7807  31d7							;
   7808  31d7
   7809  31d7				   .
   7810  31d7							;
   7811  31d7
   7812  31d7				   .
   7813  31d7							;
   7814  31d7
   7815  31d7				   .L0331		;  if _Pause_Counter_Tmp  <  240 then goto __Skip_Pause_Counter
   7816  31d7
   7817  31d7		       a5 db		      LDA	_Pause_Counter_Tmp
   7818  31d9		       c9 f0		      CMP	#240
   7819  31db		       b0 03		      BCS	.skipL0331
   7820  31dd				   .condpart153
   7821  31dd		       4c 4a 52 	      jmp	.__Skip_Pause_Counter
   7822  31e0
   7823  31e0				   .skipL0331
   7824  31e0				   .
   7825  31e0							;
   7826  31e0
   7827  31e0				   .
   7828  31e0							;
   7829  31e0
   7830  31e0				   .
   7831  31e0							;
   7832  31e0
   7833  31e0				   .
   7834  31e0							;
   7835  31e0
   7836  31e0				   .L0332		;  _Pause_Counter_Tmp	=  0
   7837  31e0
   7838  31e0		       a9 00		      LDA	#0
   7839  31e2		       85 db		      STA	_Pause_Counter_Tmp
   7840  31e4				   .
   7841  31e4							;
   7842  31e4
   7843  31e4				   .
   7844  31e4							;
   7845  31e4
   7846  31e4				   .
   7847  31e4							;
   7848  31e4
   7849  31e4				   .
   7850  31e4							;
   7851  31e4
   7852  31e4				   .L0333		;  _Pause_Color_Tmp  =   ( rand & 7 )
   7853  31e4
   7854  31e4							; complex statement detected
   7855  31e4		       a5 a2		      lda	rand
   7856  31e6		       4a		      lsr
   7857  31e7					      ifconst	rand16
   7858  31e7		       26 ed		      rol	rand16
   7859  31e9					      endif
   7860  31e9		       90 02		      bcc	*+4
   7861  31eb		       49 b4		      eor	#$B4
   7862  31ed		       85 a2		      sta	rand
   7863  31ef					      ifconst	rand16
   7864  31ef		       45 ed		      eor	rand16
   7865  31f1					      endif
   7866  31f1		       29 07		      AND	#7
   7867  31f3		       85 df		      STA	_Pause_Color_Tmp
   7868  31f5				   .
   7869  31f5							;
   7870  31f5
   7871  31f5				   .
   7872  31f5							;
   7873  31f5
   7874  31f5				   .
   7875  31f5							;
   7876  31f5
   7877  31f5				   .
   7878  31f5							;
   7879  31f5
   7880  31f5				   .
   7881  31f5							;
   7882  31f5
   7883  31f5				   .L0334		;  if _Pause_Color_Tmp  =  _Pause_Mem_Color_Tmp then _Pause_Color_Tmp	=  _Pause_Color_Tmp  +	 ( rand & 3 )	+  1  :  if _Pause_Color_Tmp  >  7 then _Pause_Color_Tmp  =  _Pause_Color_Tmp  -  8
   7884  31f5
   7885  31f5		       a5 df		      LDA	_Pause_Color_Tmp
   7886  31f7		       c5 de		      CMP	_Pause_Mem_Color_Tmp
   7887  31f9		       d0 2a		      BNE	.skipL0334
   7888  31fb				   .condpart154
   7889  31fb							; complex statement detected
   7890  31fb		       a5 df		      LDA	_Pause_Color_Tmp
   7891  31fd		       48		      PHA
   7892  31fe		       a5 a2		      lda	rand
   7893  3200		       4a		      lsr
   7894  3201					      ifconst	rand16
   7895  3201		       26 ed		      rol	rand16
   7896  3203					      endif
   7897  3203		       90 02		      bcc	*+4
   7898  3205		       49 b4		      eor	#$B4
   7899  3207		       85 a2		      sta	rand
   7900  3209					      ifconst	rand16
   7901  3209		       45 ed		      eor	rand16
   7902  320b					      endif
   7903  320b		       29 03		      AND	#3
   7904  320d		       ba		      TSX
   7905  320e		       e8		      INX
   7906  320f		       9a		      TXS
   7907  3210		       18		      CLC
   7908  3211		       75 00		      ADC	$00,x
   7909  3213		       18		      CLC
   7910  3214		       69 01		      ADC	#1
   7911  3216		       85 df		      STA	_Pause_Color_Tmp
   7912  3218		       a9 07		      LDA	#7
   7913  321a		       c5 df		      CMP	_Pause_Color_Tmp
   7914  321c		       b0 07		      BCS	.skip154then
   7915  321e				   .condpart155
   7916  321e		       a5 df		      LDA	_Pause_Color_Tmp
   7917  3220		       38		      SEC
   7918  3221		       e9 08		      SBC	#8
   7919  3223		       85 df		      STA	_Pause_Color_Tmp
   7920  3225				   .skip154then
   7921  3225				   .skipL0334
   7922  3225				   .
   7923  3225							;
   7924  3225
   7925  3225				   .
   7926  3225							;
   7927  3225
   7928  3225				   .
   7929  3225							;
   7930  3225
   7931  3225				   .
   7932  3225							;
   7933  3225
   7934  3225				   .L0335		;  _Pause_Mem_Color_Tmp  =  _Pause_Color_Tmp
   7935  3225
   7936  3225		       a5 df		      LDA	_Pause_Color_Tmp
   7937  3227		       85 de		      STA	_Pause_Mem_Color_Tmp
   7938  3229				   .
   7939  3229							;
   7940  3229
   7941  3229				   .
   7942  3229							;
   7943  3229
   7944  3229				   .
   7945  3229							;
   7946  3229
   7947  3229				   .
   7948  3229							;
   7949  3229
   7950  3229				   .L0336		;  _Bit2_Pause_Clr_Scheme{2}  =  0
   7951  3229
   7952  3229		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7953  322b		       29 fb		      AND	#251
   7954  322d		       85 e5		      STA	_Bit2_Pause_Clr_Scheme
   7955  322f				   .
   7956  322f							;
   7957  322f
   7958  322f				   .L0337		;  temp5  =  rand  :  if temp5  <  128 then _Bit2_Pause_Clr_Scheme{2}	=  1
   7959  322f
   7960  322f		       a5 a2		      lda	rand
   7961  3231		       4a		      lsr
   7962  3232					      ifconst	rand16
   7963  3232		       26 ed		      rol	rand16
   7964  3234					      endif
   7965  3234		       90 02		      bcc	*+4
   7966  3236		       49 b4		      eor	#$B4
   7967  3238		       85 a2		      sta	rand
   7968  323a					      ifconst	rand16
   7969  323a		       45 ed		      eor	rand16
   7970  323c					      endif
   7971  323c		       85 a0		      STA	temp5
   7972  323e		       a5 a0		      LDA	temp5
   7973  3240		       c9 80		      CMP	#128
   7974  3242		       b0 06		      BCS	.skipL0337
   7975  3244				   .condpart156
   7976  3244		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7977  3246		       09 04		      ORA	#4
   7978  3248		       85 e5		      STA	_Bit2_Pause_Clr_Scheme
   7979  324a				   .skipL0337
   7980  324a				   .
   7981  324a							;
   7982  324a
   7983  324a				   .__Skip_Pause_Counter
   7984  324a							; __Skip_Pause_Counter
   7985  324a
   7986  324a				   .
   7987  324a							;
   7988  324a
   7989  324a				   .
   7990  324a							;
   7991  324a
   7992  324a				   .
   7993  324a							;
   7994  324a
   7995  324a				   .
   7996  324a							;
   7997  324a
   7998  324a				   .
   7999  324a							;
   8000  324a
   8001  324a				   .
   8002  324a							;
   8003  324a
   8004  324a				   .
   8005  324a							;
   8006  324a
   8007  324a				   .L0338		;  on _Pause_Color_Tmp goto __Ps0 __Ps1 __Ps2 __Ps3 __Ps4 __Ps5 __Ps6 __Ps7
   8008  324a
   8009  324a		       a6 df		      LDX	_Pause_Color_Tmp
   8010  324c		       bd 55 52 	      LDA	.L0338jumptablehi,x
   8011  324f		       48		      PHA
   8012  3250		       bd 5d 52 	      LDA	.L0338jumptablelo,x
   8013  3253		       48		      PHA
   8014  3254		       60		      RTS
   8015  3255				   .L0338jumptablehi
   8016  3255		       52		      .byte.b	>(.__Ps0-1)
   8017  3256		       53		      .byte.b	>(.__Ps1-1)
   8018  3257		       53		      .byte.b	>(.__Ps2-1)
   8019  3258		       53		      .byte.b	>(.__Ps3-1)
   8020  3259		       53		      .byte.b	>(.__Ps4-1)
   8021  325a		       54		      .byte.b	>(.__Ps5-1)
   8022  325b		       54		      .byte.b	>(.__Ps6-1)
   8023  325c		       54		      .byte.b	>(.__Ps7-1)
   8024  325d				   .L0338jumptablelo
   8025  325d		       c5		      .byte.b	<(.__Ps0-1)
   8026  325e		       10		      .byte.b	<(.__Ps1-1)
   8027  325f		       5b		      .byte.b	<(.__Ps2-1)
   8028  3260		       a6		      .byte.b	<(.__Ps3-1)
   8029  3261		       f1		      .byte.b	<(.__Ps4-1)
   8030  3262		       38		      .byte.b	<(.__Ps5-1)
   8031  3263		       7b		      .byte.b	<(.__Ps6-1)
   8032  3264		       c6		      .byte.b	<(.__Ps7-1)
   8033  3265				   .
   8034  3265							;
   8035  3265
   8036  3265				   .__Got_Pause_Colors
   8037  3265							; __Got_Pause_Colors
   8038  3265
   8039  3265				   .
   8040  3265							;
   8041  3265
   8042  3265				   .
   8043  3265							;
   8044  3265
   8045  3265				   .
   8046  3265							;
   8047  3265
   8048  3265				   .
   8049  3265							;
   8050  3265
   8051  3265				   .
   8052  3265							;
   8053  3265
   8054  3265				   .
   8055  3265							;
   8056  3265
   8057  3265				   .
   8058  3265							;
   8059  3265
   8060  3265				   .L0339		;  drawscreen
   8061  3265
   8062  3265		       85 ee		      sta	temp7
   8063  3267		       a9 52		      lda	#>(ret_point14-1)
   8064  3269		       48		      pha
   8065  326a		       a9 7c		      lda	#<(ret_point14-1)
   8066  326c		       48		      pha
   8067  326d		       a9 f4		      lda	#>(drawscreen-1)
   8068  326f		       48		      pha
   8069  3270		       a9 3b		      lda	#<(drawscreen-1)
   8070  3272		       48		      pha
   8071  3273		       a5 ee		      lda	temp7
   8072  3275		       48		      pha
   8073  3276		       8a		      txa
   8074  3277		       48		      pha
   8075  3278		       a2 08		      ldx	#8
   8076  327a		       4c eb ff 	      jmp	BS_jsr
   8077  327d				   ret_point14
   8078  327d				   .
   8079  327d							;
   8080  327d
   8081  327d				   .
   8082  327d							;
   8083  327d
   8084  327d				   .
   8085  327d							;
   8086  327d
   8087  327d				   .
   8088  327d							;
   8089  327d
   8090  327d				   .
   8091  327d							;
   8092  327d
   8093  327d				   .
   8094  327d							;
   8095  327d
   8096  327d				   .
   8097  327d							;
   8098  327d
   8099  327d				   .
   8100  327d							;
   8101  327d
   8102  327d				   .
   8103  327d							;
   8104  327d
   8105  327d				   .
   8106  327d							;
   8107  327d
   8108  327d				   .
   8109  327d							;
   8110  327d
   8111  327d				   .L0340		;  if !joy0fire then _Bit1_FireB_Restrainer{1}  =  0  :  goto __Pause_Game
   8112  327d
   8113  327d		       24 0c		      bit	INPT4
   8114  327f		       10 09		      BPL	.skipL0340
   8115  3281				   .condpart157
   8116  3281		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   8117  3283		       29 fd		      AND	#253
   8118  3285		       85 ec		      STA	_Bit1_FireB_Restrainer
   8119  3287		       4c d1 51 	      jmp	.__Pause_Game
   8120  328a
   8121  328a				   .skipL0340
   8122  328a				   .
   8123  328a							;
   8124  328a
   8125  328a				   .
   8126  328a							;
   8127  328a
   8128  328a				   .
   8129  328a							;
   8130  328a
   8131  328a				   .
   8132  328a							;
   8133  328a
   8134  328a				   .
   8135  328a							;
   8136  328a
   8137  328a				   .L0341		;  if _Bit1_FireB_Restrainer{1} then goto __Pause_Game
   8138  328a
   8139  328a		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   8140  328c		       29 02		      AND	#2
   8141  328e		       f0 03		      BEQ	.skipL0341
   8142  3290				   .condpart158
   8143  3290		       4c d1 51 	      jmp	.__Pause_Game
   8144  3293
   8145  3293				   .skipL0341
   8146  3293				   .
   8147  3293							;
   8148  3293
   8149  3293				   .
   8150  3293							;
   8151  3293
   8152  3293				   .
   8153  3293							;
   8154  3293
   8155  3293				   .
   8156  3293							;
   8157  3293
   8158  3293				   .L0342		;  _Bit0_BW_Mem{0}  =	0  :  if switchbw then _Bit0_BW_Mem{0}	=  1
   8159  3293
   8160  3293		       a5 e5		      LDA	_Bit0_BW_Mem
   8161  3295		       29 fe		      AND	#254
   8162  3297		       85 e5		      STA	_Bit0_BW_Mem
   8163  3299		       a9 08		      lda	#8
   8164  329b		       2c 82 02 	      bit	SWCHB
   8165  329e		       d0 06		      BNE	.skipL0342
   8166  32a0				   .condpart159
   8167  32a0		       a5 e5		      LDA	_Bit0_BW_Mem
   8168  32a2		       09 01		      ORA	#1
   8169  32a4		       85 e5		      STA	_Bit0_BW_Mem
   8170  32a6				   .skipL0342
   8171  32a6				   .
   8172  32a6							;
   8173  32a6
   8174  32a6				   .
   8175  32a6							;
   8176  32a6
   8177  32a6				   .
   8178  32a6							;
   8179  32a6
   8180  32a6				   .
   8181  32a6							;
   8182  32a6
   8183  32a6				   .
   8184  32a6							;
   8185  32a6
   8186  32a6				   .
   8187  32a6							;
   8188  32a6
   8189  32a6				   .
   8190  32a6							;
   8191  32a6
   8192  32a6				   .
   8193  32a6							;
   8194  32a6
   8195  32a6				   .
   8196  32a6							;
   8197  32a6
   8198  32a6				   .
   8199  32a6							;
   8200  32a6
   8201  32a6				   .
   8202  32a6							;
   8203  32a6
   8204  32a6				   .
   8205  32a6							;
   8206  32a6
   8207  32a6				   .
   8208  32a6							;
   8209  32a6
   8210  32a6				   .
   8211  32a6							;
   8212  32a6
   8213  32a6				   .
   8214  32a6							;
   8215  32a6
   8216  32a6				   .
   8217  32a6							;
   8218  32a6
   8219  32a6				   .
   8220  32a6							;
   8221  32a6
   8222  32a6				   .
   8223  32a6							;
   8224  32a6
   8225  32a6				   .
   8226  32a6							;
   8227  32a6
   8228  32a6				   .
   8229  32a6							;
   8230  32a6
   8231  32a6				   .
   8232  32a6							;
   8233  32a6
   8234  32a6				   .
   8235  32a6							;
   8236  32a6
   8237  32a6				   .
   8238  32a6							;
   8239  32a6
   8240  32a6				   .
   8241  32a6							;
   8242  32a6
   8243  32a6				   .__Restore_Game_from_Pause
   8244  32a6							; __Restore_Game_from_Pause
   8245  32a6
   8246  32a6				   .
   8247  32a6							;
   8248  32a6
   8249  32a6				   .
   8250  32a6							;
   8251  32a6
   8252  32a6				   .
   8253  32a6							;
   8254  32a6
   8255  32a6				   .
   8256  32a6							;
   8257  32a6
   8258  32a6				   .
   8259  32a6							;
   8260  32a6
   8261  32a6				   .
   8262  32a6							;
   8263  32a6
   8264  32a6				   .L0343		;  _Bit1_FireB_Restrainer{1}  =  1
   8265  32a6
   8266  32a6		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   8267  32a8		       09 02		      ORA	#2
   8268  32aa		       85 ec		      STA	_Bit1_FireB_Restrainer
   8269  32ac				   .
   8270  32ac							;
   8271  32ac
   8272  32ac				   .
   8273  32ac							;
   8274  32ac
   8275  32ac				   .
   8276  32ac							;
   8277  32ac
   8278  32ac				   .
   8279  32ac							;
   8280  32ac
   8281  32ac				   .
   8282  32ac							;
   8283  32ac
   8284  32ac				   .
   8285  32ac							;
   8286  32ac
   8287  32ac				   .L0344		;  scorecolor	=  $1C
   8288  32ac
   8289  32ac		       a9 1c		      LDA	#$1C
   8290  32ae		       85 a3		      STA	scorecolor
   8291  32b0				   .L0345		;  pfscorecolor  =  $1C
   8292  32b0
   8293  32b0		       a9 1c		      LDA	#$1C
   8294  32b2		       85 f4		      STA	pfscorecolor
   8295  32b4				   .
   8296  32b4							;
   8297  32b4
   8298  32b4				   .
   8299  32b4							;
   8300  32b4
   8301  32b4				   .L0346		;  goto __Main_Loop bank2
   8302  32b4
   8303  32b4		       85 ee		      sta	temp7
   8304  32b6		       a9 31		      lda	#>(.__Main_Loop-1)
   8305  32b8		       48		      pha
   8306  32b9		       a9 1a		      lda	#<(.__Main_Loop-1)
   8307  32bb		       48		      pha
   8308  32bc		       a5 ee		      lda	temp7
   8309  32be		       48		      pha
   8310  32bf		       8a		      txa
   8311  32c0		       48		      pha
   8312  32c1		       a2 02		      ldx	#2
   8313  32c3		       4c eb ff 	      jmp	BS_jsr
   8314  32c6				   .
   8315  32c6							;
   8316  32c6
   8317  32c6				   .
   8318  32c6							;
   8319  32c6
   8320  32c6				   .
   8321  32c6							;
   8322  32c6
   8323  32c6				   .
   8324  32c6							;
   8325  32c6
   8326  32c6				   .
   8327  32c6							;
   8328  32c6
   8329  32c6				   .
   8330  32c6							;
   8331  32c6
   8332  32c6				   .
   8333  32c6							;
   8334  32c6
   8335  32c6				   .
   8336  32c6							;
   8337  32c6
   8338  32c6				   .
   8339  32c6							;
   8340  32c6
   8341  32c6				   .__Ps0
   8342  32c6							; __Ps0
   8343  32c6
   8344  32c6				   .
   8345  32c6							;
   8346  32c6
   8347  32c6				   .L0347		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps0B
   8348  32c6
   8349  32c6		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8350  32c8		       29 04		      AND	#4
   8351  32ca		       f0 03		      BEQ	.skipL0347
   8352  32cc				   .condpart160
   8353  32cc		       4c f0 52 	      jmp	.__Ps0B
   8354  32cf
   8355  32cf				   .skipL0347
   8356  32cf				   .
   8357  32cf							;
   8358  32cf
   8359  32cf				   .L0348		;  pfcolors:
   8360  32cf
   8361  32cf		       a9 0c		      lda	# $0C
   8362  32d1		       85 08		      sta	COLUPF
   8363  32d3				  -	      ifconst	pfres
   8364  32d3				  -	      lda	#>(pfcolorlabel55-132+pfres*pfwidth)
   8365  32d3					      else
   8366  32d3		       a9 f5		      lda	#>(pfcolorlabel55-84)
   8367  32d5					      endif
   8368  32d5		       85 f1		      sta	pfcolortable+1
   8369  32d7				  -	      ifconst	pfres
   8370  32d7				  -	      lda	#<(pfcolorlabel55-132+pfres*pfwidth)
   8371  32d7					      else
   8372  32d7		       a9 39		      lda	#<(pfcolorlabel55-84)
   8373  32d9					      endif
   8374  32d9		       85 f0		      sta	pfcolortable
   8375  32db				   .
   8376  32db							;
   8377  32db
   8378  32db				   .L0349		;  COLUP0  =  $0C  :  COLUP1  =  $0C
   8379  32db
   8380  32db		       a9 0c		      LDA	#$0C
   8381  32dd		       85 06		      STA	COLUP0
   8382  32df		       85 07		      STA	COLUP1
   8383  32e1				   .
   8384  32e1							;
   8385  32e1
   8386  32e1				   .L0350		;  COLUBK  =  $0A
   8387  32e1
   8388  32e1		       a9 0a		      LDA	#$0A
   8389  32e3		       85 09		      STA	COLUBK
   8390  32e5				   .
   8391  32e5							;
   8392  32e5
   8393  32e5				   .L0351		;  scorecolor	=  $0C
   8394  32e5
   8395  32e5		       a9 0c		      LDA	#$0C
   8396  32e7		       85 a3		      STA	scorecolor
   8397  32e9				   .L0352		;  pfscorecolor  =  $0C
   8398  32e9
   8399  32e9		       a9 0c		      LDA	#$0C
   8400  32eb		       85 f4		      STA	pfscorecolor
   8401  32ed				   .
   8402  32ed							;
   8403  32ed
   8404  32ed				   .L0353		;  goto __Got_Pause_Colors
   8405  32ed
   8406  32ed		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8407  32f0
   8408  32f0				   .
   8409  32f0							;
   8410  32f0
   8411  32f0				   .
   8412  32f0							;
   8413  32f0
   8414  32f0				   .
   8415  32f0							;
   8416  32f0
   8417  32f0				   .
   8418  32f0							;
   8419  32f0
   8420  32f0				   .
   8421  32f0							;
   8422  32f0
   8423  32f0				   .
   8424  32f0							;
   8425  32f0
   8426  32f0				   .
   8427  32f0							;
   8428  32f0
   8429  32f0				   .__Ps0B
   8430  32f0							; __Ps0B
   8431  32f0
   8432  32f0				   .
   8433  32f0							;
   8434  32f0
   8435  32f0				   .L0354		;  pfcolors:
   8436  32f0
   8437  32f0		       a9 0a		      lda	# $0A
   8438  32f2		       85 08		      sta	COLUPF
   8439  32f4				  -	      ifconst	pfres
   8440  32f4				  -	      lda	#>(pfcolorlabel55-131+pfres*pfwidth)
   8441  32f4					      else
   8442  32f4		       a9 f5		      lda	#>(pfcolorlabel55-83)
   8443  32f6					      endif
   8444  32f6		       85 f1		      sta	pfcolortable+1
   8445  32f8				  -	      ifconst	pfres
   8446  32f8				  -	      lda	#<(pfcolorlabel55-131+pfres*pfwidth)
   8447  32f8					      else
   8448  32f8		       a9 3a		      lda	#<(pfcolorlabel55-83)
   8449  32fa					      endif
   8450  32fa		       85 f0		      sta	pfcolortable
   8451  32fc				   .
   8452  32fc							;
   8453  32fc
   8454  32fc				   .L0355		;  COLUP0  =  $0A  :  COLUP1  =  $0A
   8455  32fc
   8456  32fc		       a9 0a		      LDA	#$0A
   8457  32fe		       85 06		      STA	COLUP0
   8458  3300		       85 07		      STA	COLUP1
   8459  3302				   .
   8460  3302							;
   8461  3302
   8462  3302				   .L0356		;  COLUBK  =  $0C
   8463  3302
   8464  3302		       a9 0c		      LDA	#$0C
   8465  3304		       85 09		      STA	COLUBK
   8466  3306				   .
   8467  3306							;
   8468  3306
   8469  3306				   .L0357		;  scorecolor	=  $0A
   8470  3306
   8471  3306		       a9 0a		      LDA	#$0A
   8472  3308		       85 a3		      STA	scorecolor
   8473  330a				   .L0358		;  pfscorecolor  =  $0A
   8474  330a
   8475  330a		       a9 0a		      LDA	#$0A
   8476  330c		       85 f4		      STA	pfscorecolor
   8477  330e				   .
   8478  330e							;
   8479  330e
   8480  330e				   .L0359		;  goto __Got_Pause_Colors
   8481  330e
   8482  330e		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8483  3311
   8484  3311				   .
   8485  3311							;
   8486  3311
   8487  3311				   .
   8488  3311							;
   8489  3311
   8490  3311				   .
   8491  3311							;
   8492  3311
   8493  3311				   .
   8494  3311							;
   8495  3311
   8496  3311				   .
   8497  3311							;
   8498  3311
   8499  3311				   .
   8500  3311							;
   8501  3311
   8502  3311				   .
   8503  3311							;
   8504  3311
   8505  3311				   .__Ps1
   8506  3311							; __Ps1
   8507  3311
   8508  3311				   .
   8509  3311							;
   8510  3311
   8511  3311				   .L0360		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps1B
   8512  3311
   8513  3311		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8514  3313		       29 04		      AND	#4
   8515  3315		       f0 03		      BEQ	.skipL0360
   8516  3317				   .condpart161
   8517  3317		       4c 3b 53 	      jmp	.__Ps1B
   8518  331a
   8519  331a				   .skipL0360
   8520  331a				   .
   8521  331a							;
   8522  331a
   8523  331a				   .L0361		;  pfcolors:
   8524  331a
   8525  331a		       a9 3c		      lda	# $3C
   8526  331c		       85 08		      sta	COLUPF
   8527  331e				  -	      ifconst	pfres
   8528  331e				  -	      lda	#>(pfcolorlabel55-130+pfres*pfwidth)
   8529  331e					      else
   8530  331e		       a9 f5		      lda	#>(pfcolorlabel55-82)
   8531  3320					      endif
   8532  3320		       85 f1		      sta	pfcolortable+1
   8533  3322				  -	      ifconst	pfres
   8534  3322				  -	      lda	#<(pfcolorlabel55-130+pfres*pfwidth)
   8535  3322					      else
   8536  3322		       a9 3b		      lda	#<(pfcolorlabel55-82)
   8537  3324					      endif
   8538  3324		       85 f0		      sta	pfcolortable
   8539  3326				   .
   8540  3326							;
   8541  3326
   8542  3326				   .L0362		;  COLUP0  =  $3C  :  COLUP1  =  $3C
   8543  3326
   8544  3326		       a9 3c		      LDA	#$3C
   8545  3328		       85 06		      STA	COLUP0
   8546  332a		       85 07		      STA	COLUP1
   8547  332c				   .
   8548  332c							;
   8549  332c
   8550  332c				   .L0363		;  COLUBK  =  $3A
   8551  332c
   8552  332c		       a9 3a		      LDA	#$3A
   8553  332e		       85 09		      STA	COLUBK
   8554  3330				   .
   8555  3330							;
   8556  3330
   8557  3330				   .L0364		;  scorecolor	=  $3C
   8558  3330
   8559  3330		       a9 3c		      LDA	#$3C
   8560  3332		       85 a3		      STA	scorecolor
   8561  3334				   .L0365		;  pfscorecolor  =  $3C
   8562  3334
   8563  3334		       a9 3c		      LDA	#$3C
   8564  3336		       85 f4		      STA	pfscorecolor
   8565  3338				   .
   8566  3338							;
   8567  3338
   8568  3338				   .L0366		;  goto __Got_Pause_Colors
   8569  3338
   8570  3338		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8571  333b
   8572  333b				   .
   8573  333b							;
   8574  333b
   8575  333b				   .
   8576  333b							;
   8577  333b
   8578  333b				   .
   8579  333b							;
   8580  333b
   8581  333b				   .
   8582  333b							;
   8583  333b
   8584  333b				   .
   8585  333b							;
   8586  333b
   8587  333b				   .
   8588  333b							;
   8589  333b
   8590  333b				   .
   8591  333b							;
   8592  333b
   8593  333b				   .__Ps1B
   8594  333b							; __Ps1B
   8595  333b
   8596  333b				   .
   8597  333b							;
   8598  333b
   8599  333b				   .L0367		;  pfcolors:
   8600  333b
   8601  333b		       a9 3a		      lda	# $3A
   8602  333d		       85 08		      sta	COLUPF
   8603  333f				  -	      ifconst	pfres
   8604  333f				  -	      lda	#>(pfcolorlabel55-129+pfres*pfwidth)
   8605  333f					      else
   8606  333f		       a9 f5		      lda	#>(pfcolorlabel55-81)
   8607  3341					      endif
   8608  3341		       85 f1		      sta	pfcolortable+1
   8609  3343				  -	      ifconst	pfres
   8610  3343				  -	      lda	#<(pfcolorlabel55-129+pfres*pfwidth)
   8611  3343					      else
   8612  3343		       a9 3c		      lda	#<(pfcolorlabel55-81)
   8613  3345					      endif
   8614  3345		       85 f0		      sta	pfcolortable
   8615  3347				   .
   8616  3347							;
   8617  3347
   8618  3347				   .L0368		;  COLUP0  =  $3A  :  COLUP1  =  $3A
   8619  3347
   8620  3347		       a9 3a		      LDA	#$3A
   8621  3349		       85 06		      STA	COLUP0
   8622  334b		       85 07		      STA	COLUP1
   8623  334d				   .
   8624  334d							;
   8625  334d
   8626  334d				   .L0369		;  COLUBK  =  $3C
   8627  334d
   8628  334d		       a9 3c		      LDA	#$3C
   8629  334f		       85 09		      STA	COLUBK
   8630  3351				   .
   8631  3351							;
   8632  3351
   8633  3351				   .L0370		;  scorecolor	=  $3A
   8634  3351
   8635  3351		       a9 3a		      LDA	#$3A
   8636  3353		       85 a3		      STA	scorecolor
   8637  3355				   .L0371		;  pfscorecolor  =  $3A
   8638  3355
   8639  3355		       a9 3a		      LDA	#$3A
   8640  3357		       85 f4		      STA	pfscorecolor
   8641  3359				   .
   8642  3359							;
   8643  3359
   8644  3359				   .L0372		;  goto __Got_Pause_Colors
   8645  3359
   8646  3359		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8647  335c
   8648  335c				   .
   8649  335c							;
   8650  335c
   8651  335c				   .
   8652  335c							;
   8653  335c
   8654  335c				   .
   8655  335c							;
   8656  335c
   8657  335c				   .
   8658  335c							;
   8659  335c
   8660  335c				   .
   8661  335c							;
   8662  335c
   8663  335c				   .
   8664  335c							;
   8665  335c
   8666  335c				   .
   8667  335c							;
   8668  335c
   8669  335c				   .__Ps2
   8670  335c							; __Ps2
   8671  335c
   8672  335c				   .
   8673  335c							;
   8674  335c
   8675  335c				   .L0373		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps2B
   8676  335c
   8677  335c		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8678  335e		       29 04		      AND	#4
   8679  3360		       f0 03		      BEQ	.skipL0373
   8680  3362				   .condpart162
   8681  3362		       4c 86 53 	      jmp	.__Ps2B
   8682  3365
   8683  3365				   .skipL0373
   8684  3365				   .
   8685  3365							;
   8686  3365
   8687  3365				   .L0374		;  pfcolors:
   8688  3365
   8689  3365		       a9 6c		      lda	# $6C
   8690  3367		       85 08		      sta	COLUPF
   8691  3369				  -	      ifconst	pfres
   8692  3369				  -	      lda	#>(pfcolorlabel80-132+pfres*pfwidth)
   8693  3369					      else
   8694  3369		       a9 f5		      lda	#>(pfcolorlabel80-84)
   8695  336b					      endif
   8696  336b		       85 f1		      sta	pfcolortable+1
   8697  336d				  -	      ifconst	pfres
   8698  336d				  -	      lda	#<(pfcolorlabel80-132+pfres*pfwidth)
   8699  336d					      else
   8700  336d		       a9 65		      lda	#<(pfcolorlabel80-84)
   8701  336f					      endif
   8702  336f		       85 f0		      sta	pfcolortable
   8703  3371				   .
   8704  3371							;
   8705  3371
   8706  3371				   .L0375		;  COLUP0  =  $6C  :  COLUP1  =  $6C
   8707  3371
   8708  3371		       a9 6c		      LDA	#$6C
   8709  3373		       85 06		      STA	COLUP0
   8710  3375		       85 07		      STA	COLUP1
   8711  3377				   .
   8712  3377							;
   8713  3377
   8714  3377				   .L0376		;  COLUBK  =  $6A
   8715  3377
   8716  3377		       a9 6a		      LDA	#$6A
   8717  3379		       85 09		      STA	COLUBK
   8718  337b				   .
   8719  337b							;
   8720  337b
   8721  337b				   .L0377		;  scorecolor	=  $6C
   8722  337b
   8723  337b		       a9 6c		      LDA	#$6C
   8724  337d		       85 a3		      STA	scorecolor
   8725  337f				   .L0378		;  pfscorecolor  =  $6C
   8726  337f
   8727  337f		       a9 6c		      LDA	#$6C
   8728  3381		       85 f4		      STA	pfscorecolor
   8729  3383				   .
   8730  3383							;
   8731  3383
   8732  3383				   .L0379		;  goto __Got_Pause_Colors
   8733  3383
   8734  3383		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8735  3386
   8736  3386				   .
   8737  3386							;
   8738  3386
   8739  3386				   .
   8740  3386							;
   8741  3386
   8742  3386				   .
   8743  3386							;
   8744  3386
   8745  3386				   .
   8746  3386							;
   8747  3386
   8748  3386				   .
   8749  3386							;
   8750  3386
   8751  3386				   .
   8752  3386							;
   8753  3386
   8754  3386				   .
   8755  3386							;
   8756  3386
   8757  3386				   .__Ps2B
   8758  3386							; __Ps2B
   8759  3386
   8760  3386				   .
   8761  3386							;
   8762  3386
   8763  3386				   .L0380		;  pfcolors:
   8764  3386
   8765  3386		       a9 6a		      lda	# $6A
   8766  3388		       85 08		      sta	COLUPF
   8767  338a				  -	      ifconst	pfres
   8768  338a				  -	      lda	#>(pfcolorlabel80-131+pfres*pfwidth)
   8769  338a					      else
   8770  338a		       a9 f5		      lda	#>(pfcolorlabel80-83)
   8771  338c					      endif
   8772  338c		       85 f1		      sta	pfcolortable+1
   8773  338e				  -	      ifconst	pfres
   8774  338e				  -	      lda	#<(pfcolorlabel80-131+pfres*pfwidth)
   8775  338e					      else
   8776  338e		       a9 66		      lda	#<(pfcolorlabel80-83)
   8777  3390					      endif
   8778  3390		       85 f0		      sta	pfcolortable
   8779  3392				   .
   8780  3392							;
   8781  3392
   8782  3392				   .L0381		;  COLUP0  =  $6A  :  COLUP1  =  $6A
   8783  3392
   8784  3392		       a9 6a		      LDA	#$6A
   8785  3394		       85 06		      STA	COLUP0
   8786  3396		       85 07		      STA	COLUP1
   8787  3398				   .
   8788  3398							;
   8789  3398
   8790  3398				   .L0382		;  COLUBK  =  $6C
   8791  3398
   8792  3398		       a9 6c		      LDA	#$6C
   8793  339a		       85 09		      STA	COLUBK
   8794  339c				   .
   8795  339c							;
   8796  339c
   8797  339c				   .L0383		;  scorecolor	=  $6A
   8798  339c
   8799  339c		       a9 6a		      LDA	#$6A
   8800  339e		       85 a3		      STA	scorecolor
   8801  33a0				   .L0384		;  pfscorecolor  =  $6A
   8802  33a0
   8803  33a0		       a9 6a		      LDA	#$6A
   8804  33a2		       85 f4		      STA	pfscorecolor
   8805  33a4				   .
   8806  33a4							;
   8807  33a4
   8808  33a4				   .L0385		;  goto __Got_Pause_Colors
   8809  33a4
   8810  33a4		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8811  33a7
   8812  33a7				   .
   8813  33a7							;
   8814  33a7
   8815  33a7				   .
   8816  33a7							;
   8817  33a7
   8818  33a7				   .
   8819  33a7							;
   8820  33a7
   8821  33a7				   .
   8822  33a7							;
   8823  33a7
   8824  33a7				   .
   8825  33a7							;
   8826  33a7
   8827  33a7				   .
   8828  33a7							;
   8829  33a7
   8830  33a7				   .
   8831  33a7							;
   8832  33a7
   8833  33a7				   .__Ps3
   8834  33a7							; __Ps3
   8835  33a7
   8836  33a7				   .
   8837  33a7							;
   8838  33a7
   8839  33a7				   .L0386		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps3B
   8840  33a7
   8841  33a7		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8842  33a9		       29 04		      AND	#4
   8843  33ab		       f0 03		      BEQ	.skipL0386
   8844  33ad				   .condpart163
   8845  33ad		       4c d1 53 	      jmp	.__Ps3B
   8846  33b0
   8847  33b0				   .skipL0386
   8848  33b0				   .
   8849  33b0							;
   8850  33b0
   8851  33b0				   .L0387		;  pfcolors:
   8852  33b0
   8853  33b0		       a9 9c		      lda	# $9C
   8854  33b2		       85 08		      sta	COLUPF
   8855  33b4				  -	      ifconst	pfres
   8856  33b4				  -	      lda	#>(pfcolorlabel80-130+pfres*pfwidth)
   8857  33b4					      else
   8858  33b4		       a9 f5		      lda	#>(pfcolorlabel80-82)
   8859  33b6					      endif
   8860  33b6		       85 f1		      sta	pfcolortable+1
   8861  33b8				  -	      ifconst	pfres
   8862  33b8				  -	      lda	#<(pfcolorlabel80-130+pfres*pfwidth)
   8863  33b8					      else
   8864  33b8		       a9 67		      lda	#<(pfcolorlabel80-82)
   8865  33ba					      endif
   8866  33ba		       85 f0		      sta	pfcolortable
   8867  33bc				   .
   8868  33bc							;
   8869  33bc
   8870  33bc				   .L0388		;  COLUP0  =  $9C  :  COLUP1  =  $9C
   8871  33bc
   8872  33bc		       a9 9c		      LDA	#$9C
   8873  33be		       85 06		      STA	COLUP0
   8874  33c0		       85 07		      STA	COLUP1
   8875  33c2				   .
   8876  33c2							;
   8877  33c2
   8878  33c2				   .L0389		;  COLUBK  =  $9A
   8879  33c2
   8880  33c2		       a9 9a		      LDA	#$9A
   8881  33c4		       85 09		      STA	COLUBK
   8882  33c6				   .
   8883  33c6							;
   8884  33c6
   8885  33c6				   .L0390		;  scorecolor	=  $9C
   8886  33c6
   8887  33c6		       a9 9c		      LDA	#$9C
   8888  33c8		       85 a3		      STA	scorecolor
   8889  33ca				   .L0391		;  pfscorecolor  =  $9C
   8890  33ca
   8891  33ca		       a9 9c		      LDA	#$9C
   8892  33cc		       85 f4		      STA	pfscorecolor
   8893  33ce				   .
   8894  33ce							;
   8895  33ce
   8896  33ce				   .L0392		;  goto __Got_Pause_Colors
   8897  33ce
   8898  33ce		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8899  33d1
   8900  33d1				   .
   8901  33d1							;
   8902  33d1
   8903  33d1				   .
   8904  33d1							;
   8905  33d1
   8906  33d1				   .
   8907  33d1							;
   8908  33d1
   8909  33d1				   .
   8910  33d1							;
   8911  33d1
   8912  33d1				   .
   8913  33d1							;
   8914  33d1
   8915  33d1				   .
   8916  33d1							;
   8917  33d1
   8918  33d1				   .
   8919  33d1							;
   8920  33d1
   8921  33d1				   .__Ps3B
   8922  33d1							; __Ps3B
   8923  33d1
   8924  33d1				   .
   8925  33d1							;
   8926  33d1
   8927  33d1				   .L0393		;  pfcolors:
   8928  33d1
   8929  33d1		       a9 9a		      lda	# $9A
   8930  33d3		       85 08		      sta	COLUPF
   8931  33d5				  -	      ifconst	pfres
   8932  33d5				  -	      lda	#>(pfcolorlabel80-129+pfres*pfwidth)
   8933  33d5					      else
   8934  33d5		       a9 f5		      lda	#>(pfcolorlabel80-81)
   8935  33d7					      endif
   8936  33d7		       85 f1		      sta	pfcolortable+1
   8937  33d9				  -	      ifconst	pfres
   8938  33d9				  -	      lda	#<(pfcolorlabel80-129+pfres*pfwidth)
   8939  33d9					      else
   8940  33d9		       a9 68		      lda	#<(pfcolorlabel80-81)
   8941  33db					      endif
   8942  33db		       85 f0		      sta	pfcolortable
   8943  33dd				   .
   8944  33dd							;
   8945  33dd
   8946  33dd				   .L0394		;  COLUP0  =  $9A  :  COLUP1  =  $9A
   8947  33dd
   8948  33dd		       a9 9a		      LDA	#$9A
   8949  33df		       85 06		      STA	COLUP0
   8950  33e1		       85 07		      STA	COLUP1
   8951  33e3				   .
   8952  33e3							;
   8953  33e3
   8954  33e3				   .L0395		;  COLUBK  =  $9C
   8955  33e3
   8956  33e3		       a9 9c		      LDA	#$9C
   8957  33e5		       85 09		      STA	COLUBK
   8958  33e7				   .
   8959  33e7							;
   8960  33e7
   8961  33e7				   .L0396		;  scorecolor	=  $9A
   8962  33e7
   8963  33e7		       a9 9a		      LDA	#$9A
   8964  33e9		       85 a3		      STA	scorecolor
   8965  33eb				   .L0397		;  pfscorecolor  =  $9A
   8966  33eb
   8967  33eb		       a9 9a		      LDA	#$9A
   8968  33ed		       85 f4		      STA	pfscorecolor
   8969  33ef				   .
   8970  33ef							;
   8971  33ef
   8972  33ef				   .L0398		;  goto __Got_Pause_Colors
   8973  33ef
   8974  33ef		       4c 65 52 	      jmp	.__Got_Pause_Colors
   8975  33f2
   8976  33f2				   .
   8977  33f2							;
   8978  33f2
   8979  33f2				   .
   8980  33f2							;
   8981  33f2
   8982  33f2				   .
   8983  33f2							;
   8984  33f2
   8985  33f2				   .
   8986  33f2							;
   8987  33f2
   8988  33f2				   .
   8989  33f2							;
   8990  33f2
   8991  33f2				   .
   8992  33f2							;
   8993  33f2
   8994  33f2				   .
   8995  33f2							;
   8996  33f2
   8997  33f2				   .__Ps4
   8998  33f2							; __Ps4
   8999  33f2
   9000  33f2				   .
   9001  33f2							;
   9002  33f2
   9003  33f2				   .L0399		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps4B
   9004  33f2
   9005  33f2		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   9006  33f4		       29 04		      AND	#4
   9007  33f6		       f0 03		      BEQ	.skipL0399
   9008  33f8				   .condpart164
   9009  33f8		       4c 1c 54 	      jmp	.__Ps4B
   9010  33fb
   9011  33fb				   .skipL0399
   9012  33fb				   .
   9013  33fb							;
   9014  33fb
   9015  33fb				   .L0400		;  pfcolors:
   9016  33fb
   9017  33fb		       a9 cc		      lda	# $CC
   9018  33fd		       85 08		      sta	COLUPF
   9019  33ff				  -	      ifconst	pfres
   9020  33ff				  -	      lda	#>(pfcolorlabel105-132+pfres*pfwidth)
   9021  33ff					      else
   9022  33ff		       a9 f6		      lda	#>(pfcolorlabel105-84)
   9023  3401					      endif
   9024  3401		       85 f1		      sta	pfcolortable+1
   9025  3403				  -	      ifconst	pfres
   9026  3403				  -	      lda	#<(pfcolorlabel105-132+pfres*pfwidth)
   9027  3403					      else
   9028  3403		       a9 04		      lda	#<(pfcolorlabel105-84)
   9029  3405					      endif
   9030  3405		       85 f0		      sta	pfcolortable
   9031  3407				   .
   9032  3407							;
   9033  3407
   9034  3407				   .L0401		;  COLUP0  =  $CC  :  COLUP1  =  $CC
   9035  3407
   9036  3407		       a9 cc		      LDA	#$CC
   9037  3409		       85 06		      STA	COLUP0
   9038  340b		       85 07		      STA	COLUP1
   9039  340d				   .
   9040  340d							;
   9041  340d
   9042  340d				   .L0402		;  COLUBK  =  $CA
   9043  340d
   9044  340d		       a9 ca		      LDA	#$CA
   9045  340f		       85 09		      STA	COLUBK
   9046  3411				   .
   9047  3411							;
   9048  3411
   9049  3411				   .L0403		;  scorecolor	=  $CC
   9050  3411
   9051  3411		       a9 cc		      LDA	#$CC
   9052  3413		       85 a3		      STA	scorecolor
   9053  3415				   .L0404		;  pfscorecolor  =  $CC
   9054  3415
   9055  3415		       a9 cc		      LDA	#$CC
   9056  3417		       85 f4		      STA	pfscorecolor
   9057  3419				   .
   9058  3419							;
   9059  3419
   9060  3419				   .L0405		;  goto __Got_Pause_Colors
   9061  3419
   9062  3419		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9063  341c
   9064  341c				   .
   9065  341c							;
   9066  341c
   9067  341c				   .
   9068  341c							;
   9069  341c
   9070  341c				   .
   9071  341c							;
   9072  341c
   9073  341c				   .
   9074  341c							;
   9075  341c
   9076  341c				   .
   9077  341c							;
   9078  341c
   9079  341c				   .
   9080  341c							;
   9081  341c
   9082  341c				   .
   9083  341c							;
   9084  341c
   9085  341c				   .__Ps4B
   9086  341c							; __Ps4B
   9087  341c
   9088  341c				   .
   9089  341c							;
   9090  341c
   9091  341c				   .L0406		;  pfcolors:
   9092  341c
   9093  341c		       a9 ca		      lda	# $CA
   9094  341e		       85 08		      sta	COLUPF
   9095  3420				  -	      ifconst	pfres
   9096  3420				  -	      lda	#>(pfcolorlabel105-131+pfres*pfwidth)
   9097  3420					      else
   9098  3420		       a9 f6		      lda	#>(pfcolorlabel105-83)
   9099  3422					      endif
   9100  3422		       85 f1		      sta	pfcolortable+1
   9101  3424				  -	      ifconst	pfres
   9102  3424				  -	      lda	#<(pfcolorlabel105-131+pfres*pfwidth)
   9103  3424					      else
   9104  3424		       a9 05		      lda	#<(pfcolorlabel105-83)
   9105  3426					      endif
   9106  3426		       85 f0		      sta	pfcolortable
   9107  3428				   .
   9108  3428							;
   9109  3428
   9110  3428				   .L0407		;  COLUP0  =  $CA  :  COLUP1  =  $CA
   9111  3428
   9112  3428		       a9 ca		      LDA	#$CA
   9113  342a		       85 06		      STA	COLUP0
   9114  342c		       85 07		      STA	COLUP1
   9115  342e				   .
   9116  342e							;
   9117  342e
   9118  342e				   .L0408		;  COLUBK  =  $CC
   9119  342e
   9120  342e		       a9 cc		      LDA	#$CC
   9121  3430		       85 09		      STA	COLUBK
   9122  3432				   .
   9123  3432							;
   9124  3432
   9125  3432				   .L0409		;  scorecolor	=  $CA
   9126  3432
   9127  3432		       a9 ca		      LDA	#$CA
   9128  3434		       85 a3		      STA	scorecolor
   9129  3436				   .
   9130  3436							;
   9131  3436
   9132  3436				   .L0410		;  goto __Got_Pause_Colors
   9133  3436
   9134  3436		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9135  3439
   9136  3439				   .
   9137  3439							;
   9138  3439
   9139  3439				   .
   9140  3439							;
   9141  3439
   9142  3439				   .
   9143  3439							;
   9144  3439
   9145  3439				   .
   9146  3439							;
   9147  3439
   9148  3439				   .
   9149  3439							;
   9150  3439
   9151  3439				   .
   9152  3439							;
   9153  3439
   9154  3439				   .
   9155  3439							;
   9156  3439
   9157  3439				   .__Ps5
   9158  3439							; __Ps5
   9159  3439
   9160  3439				   .
   9161  3439							;
   9162  3439
   9163  3439				   .L0411		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps5B
   9164  3439
   9165  3439		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   9166  343b		       29 04		      AND	#4
   9167  343d		       f0 03		      BEQ	.skipL0411
   9168  343f				   .condpart165
   9169  343f		       4c 5f 54 	      jmp	.__Ps5B
   9170  3442
   9171  3442				   .skipL0411
   9172  3442				   .
   9173  3442							;
   9174  3442
   9175  3442				   .L0412		;  pfcolors:
   9176  3442
   9177  3442		       a9 fc		      lda	# $FC
   9178  3444		       85 08		      sta	COLUPF
   9179  3446				  -	      ifconst	pfres
   9180  3446				  -	      lda	#>(pfcolorlabel105-130+pfres*pfwidth)
   9181  3446					      else
   9182  3446		       a9 f6		      lda	#>(pfcolorlabel105-82)
   9183  3448					      endif
   9184  3448		       85 f1		      sta	pfcolortable+1
   9185  344a				  -	      ifconst	pfres
   9186  344a				  -	      lda	#<(pfcolorlabel105-130+pfres*pfwidth)
   9187  344a					      else
   9188  344a		       a9 06		      lda	#<(pfcolorlabel105-82)
   9189  344c					      endif
   9190  344c		       85 f0		      sta	pfcolortable
   9191  344e				   .
   9192  344e							;
   9193  344e
   9194  344e				   .L0413		;  COLUP0  =  $FC  :  COLUP1  =  $FC
   9195  344e
   9196  344e		       a9 fc		      LDA	#$FC
   9197  3450		       85 06		      STA	COLUP0
   9198  3452		       85 07		      STA	COLUP1
   9199  3454				   .
   9200  3454							;
   9201  3454
   9202  3454				   .L0414		;  COLUBK  =  $FA
   9203  3454
   9204  3454		       a9 fa		      LDA	#$FA
   9205  3456		       85 09		      STA	COLUBK
   9206  3458				   .
   9207  3458							;
   9208  3458
   9209  3458				   .L0415		;  scorecolor	=  $FC
   9210  3458
   9211  3458		       a9 fc		      LDA	#$FC
   9212  345a		       85 a3		      STA	scorecolor
   9213  345c				   .
   9214  345c							;
   9215  345c
   9216  345c				   .L0416		;  goto __Got_Pause_Colors
   9217  345c
   9218  345c		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9219  345f
   9220  345f				   .
   9221  345f							;
   9222  345f
   9223  345f				   .
   9224  345f							;
   9225  345f
   9226  345f				   .
   9227  345f							;
   9228  345f
   9229  345f				   .
   9230  345f							;
   9231  345f
   9232  345f				   .
   9233  345f							;
   9234  345f
   9235  345f				   .
   9236  345f							;
   9237  345f
   9238  345f				   .
   9239  345f							;
   9240  345f
   9241  345f				   .__Ps5B
   9242  345f							; __Ps5B
   9243  345f
   9244  345f				   .
   9245  345f							;
   9246  345f
   9247  345f				   .L0417		;  pfcolors:
   9248  345f
   9249  345f		       a9 fa		      lda	# $FA
   9250  3461		       85 08		      sta	COLUPF
   9251  3463				  -	      ifconst	pfres
   9252  3463				  -	      lda	#>(pfcolorlabel105-129+pfres*pfwidth)
   9253  3463					      else
   9254  3463		       a9 f6		      lda	#>(pfcolorlabel105-81)
   9255  3465					      endif
   9256  3465		       85 f1		      sta	pfcolortable+1
   9257  3467				  -	      ifconst	pfres
   9258  3467				  -	      lda	#<(pfcolorlabel105-129+pfres*pfwidth)
   9259  3467					      else
   9260  3467		       a9 07		      lda	#<(pfcolorlabel105-81)
   9261  3469					      endif
   9262  3469		       85 f0		      sta	pfcolortable
   9263  346b				   .
   9264  346b							;
   9265  346b
   9266  346b				   .L0418		;  COLUP0  =  $FA  :  COLUP1  =  $FA
   9267  346b
   9268  346b		       a9 fa		      LDA	#$FA
   9269  346d		       85 06		      STA	COLUP0
   9270  346f		       85 07		      STA	COLUP1
   9271  3471				   .
   9272  3471							;
   9273  3471
   9274  3471				   .L0419		;  COLUBK  =  $FC
   9275  3471
   9276  3471		       a9 fc		      LDA	#$FC
   9277  3473		       85 09		      STA	COLUBK
   9278  3475				   .
   9279  3475							;
   9280  3475
   9281  3475				   .L0420		;  scorecolor	=  $FA
   9282  3475
   9283  3475		       a9 fa		      LDA	#$FA
   9284  3477		       85 a3		      STA	scorecolor
   9285  3479				   .
   9286  3479							;
   9287  3479
   9288  3479				   .L0421		;  goto __Got_Pause_Colors
   9289  3479
   9290  3479		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9291  347c
   9292  347c				   .
   9293  347c							;
   9294  347c
   9295  347c				   .
   9296  347c							;
   9297  347c
   9298  347c				   .
   9299  347c							;
   9300  347c
   9301  347c				   .
   9302  347c							;
   9303  347c
   9304  347c				   .
   9305  347c							;
   9306  347c
   9307  347c				   .
   9308  347c							;
   9309  347c
   9310  347c				   .
   9311  347c							;
   9312  347c
   9313  347c				   .__Ps6
   9314  347c							; __Ps6
   9315  347c
   9316  347c				   .
   9317  347c							;
   9318  347c
   9319  347c				   .L0422		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps6B
   9320  347c
   9321  347c		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   9322  347e		       29 04		      AND	#4
   9323  3480		       f0 03		      BEQ	.skipL0422
   9324  3482				   .condpart166
   9325  3482		       4c a6 54 	      jmp	.__Ps6B
   9326  3485
   9327  3485				   .skipL0422
   9328  3485				   .
   9329  3485							;
   9330  3485
   9331  3485				   .L0423		;  pfcolors:
   9332  3485
   9333  3485		       a9 8c		      lda	# $8C
   9334  3487		       85 08		      sta	COLUPF
   9335  3489				  -	      ifconst	pfres
   9336  3489				  -	      lda	#>(pfcolorlabel130-132+pfres*pfwidth)
   9337  3489					      else
   9338  3489		       a9 f6		      lda	#>(pfcolorlabel130-84)
   9339  348b					      endif
   9340  348b		       85 f1		      sta	pfcolortable+1
   9341  348d				  -	      ifconst	pfres
   9342  348d				  -	      lda	#<(pfcolorlabel130-132+pfres*pfwidth)
   9343  348d					      else
   9344  348d		       a9 30		      lda	#<(pfcolorlabel130-84)
   9345  348f					      endif
   9346  348f		       85 f0		      sta	pfcolortable
   9347  3491				   .
   9348  3491							;
   9349  3491
   9350  3491				   .L0424		;  COLUP0  =  $8C  :  COLUP1  =  $8C
   9351  3491
   9352  3491		       a9 8c		      LDA	#$8C
   9353  3493		       85 06		      STA	COLUP0
   9354  3495		       85 07		      STA	COLUP1
   9355  3497				   .
   9356  3497							;
   9357  3497
   9358  3497				   .L0425		;  COLUBK  =  $8A
   9359  3497
   9360  3497		       a9 8a		      LDA	#$8A
   9361  3499		       85 09		      STA	COLUBK
   9362  349b				   .
   9363  349b							;
   9364  349b
   9365  349b				   .L0426		;  scorecolor	=  $8C
   9366  349b
   9367  349b		       a9 8c		      LDA	#$8C
   9368  349d		       85 a3		      STA	scorecolor
   9369  349f				   .L0427		;  pfscorecolor  =  $8C
   9370  349f
   9371  349f		       a9 8c		      LDA	#$8C
   9372  34a1		       85 f4		      STA	pfscorecolor
   9373  34a3				   .
   9374  34a3							;
   9375  34a3
   9376  34a3				   .L0428		;  goto __Got_Pause_Colors
   9377  34a3
   9378  34a3		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9379  34a6
   9380  34a6				   .
   9381  34a6							;
   9382  34a6
   9383  34a6				   .
   9384  34a6							;
   9385  34a6
   9386  34a6				   .
   9387  34a6							;
   9388  34a6
   9389  34a6				   .
   9390  34a6							;
   9391  34a6
   9392  34a6				   .
   9393  34a6							;
   9394  34a6
   9395  34a6				   .
   9396  34a6							;
   9397  34a6
   9398  34a6				   .
   9399  34a6							;
   9400  34a6
   9401  34a6				   .__Ps6B
   9402  34a6							; __Ps6B
   9403  34a6
   9404  34a6				   .
   9405  34a6							;
   9406  34a6
   9407  34a6				   .L0429		;  pfcolors:
   9408  34a6
   9409  34a6		       a9 8a		      lda	# $8A
   9410  34a8		       85 08		      sta	COLUPF
   9411  34aa				  -	      ifconst	pfres
   9412  34aa				  -	      lda	#>(pfcolorlabel130-131+pfres*pfwidth)
   9413  34aa					      else
   9414  34aa		       a9 f6		      lda	#>(pfcolorlabel130-83)
   9415  34ac					      endif
   9416  34ac		       85 f1		      sta	pfcolortable+1
   9417  34ae				  -	      ifconst	pfres
   9418  34ae				  -	      lda	#<(pfcolorlabel130-131+pfres*pfwidth)
   9419  34ae					      else
   9420  34ae		       a9 31		      lda	#<(pfcolorlabel130-83)
   9421  34b0					      endif
   9422  34b0		       85 f0		      sta	pfcolortable
   9423  34b2				   .
   9424  34b2							;
   9425  34b2
   9426  34b2				   .L0430		;  COLUP0  =  $8A  :  COLUP1  =  $8A
   9427  34b2
   9428  34b2		       a9 8a		      LDA	#$8A
   9429  34b4		       85 06		      STA	COLUP0
   9430  34b6		       85 07		      STA	COLUP1
   9431  34b8				   .
   9432  34b8							;
   9433  34b8
   9434  34b8				   .L0431		;  COLUBK  =  $8C
   9435  34b8
   9436  34b8		       a9 8c		      LDA	#$8C
   9437  34ba		       85 09		      STA	COLUBK
   9438  34bc				   .
   9439  34bc							;
   9440  34bc
   9441  34bc				   .L0432		;  scorecolor	=  $8A
   9442  34bc
   9443  34bc		       a9 8a		      LDA	#$8A
   9444  34be		       85 a3		      STA	scorecolor
   9445  34c0				   .L0433		;  pfscorecolor  =  $8A
   9446  34c0
   9447  34c0		       a9 8a		      LDA	#$8A
   9448  34c2		       85 f4		      STA	pfscorecolor
   9449  34c4				   .
   9450  34c4							;
   9451  34c4
   9452  34c4				   .L0434		;  goto __Got_Pause_Colors
   9453  34c4
   9454  34c4		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9455  34c7
   9456  34c7				   .
   9457  34c7							;
   9458  34c7
   9459  34c7				   .
   9460  34c7							;
   9461  34c7
   9462  34c7				   .
   9463  34c7							;
   9464  34c7
   9465  34c7				   .
   9466  34c7							;
   9467  34c7
   9468  34c7				   .
   9469  34c7							;
   9470  34c7
   9471  34c7				   .
   9472  34c7							;
   9473  34c7
   9474  34c7				   .
   9475  34c7							;
   9476  34c7
   9477  34c7				   .__Ps7
   9478  34c7							; __Ps7
   9479  34c7
   9480  34c7				   .
   9481  34c7							;
   9482  34c7
   9483  34c7				   .L0435		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps7B
   9484  34c7
   9485  34c7		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   9486  34c9		       29 04		      AND	#4
   9487  34cb		       f0 03		      BEQ	.skipL0435
   9488  34cd				   .condpart167
   9489  34cd		       4c f1 54 	      jmp	.__Ps7B
   9490  34d0
   9491  34d0				   .skipL0435
   9492  34d0				   .
   9493  34d0							;
   9494  34d0
   9495  34d0				   .L0436		;  pfcolors:
   9496  34d0
   9497  34d0		       a9 2c		      lda	# $2C
   9498  34d2		       85 08		      sta	COLUPF
   9499  34d4				  -	      ifconst	pfres
   9500  34d4				  -	      lda	#>(pfcolorlabel130-130+pfres*pfwidth)
   9501  34d4					      else
   9502  34d4		       a9 f6		      lda	#>(pfcolorlabel130-82)
   9503  34d6					      endif
   9504  34d6		       85 f1		      sta	pfcolortable+1
   9505  34d8				  -	      ifconst	pfres
   9506  34d8				  -	      lda	#<(pfcolorlabel130-130+pfres*pfwidth)
   9507  34d8					      else
   9508  34d8		       a9 32		      lda	#<(pfcolorlabel130-82)
   9509  34da					      endif
   9510  34da		       85 f0		      sta	pfcolortable
   9511  34dc				   .
   9512  34dc							;
   9513  34dc
   9514  34dc				   .L0437		;  COLUP0  =  $2C  :  COLUP1  =  $2C
   9515  34dc
   9516  34dc		       a9 2c		      LDA	#$2C
   9517  34de		       85 06		      STA	COLUP0
   9518  34e0		       85 07		      STA	COLUP1
   9519  34e2				   .
   9520  34e2							;
   9521  34e2
   9522  34e2				   .L0438		;  COLUBK  =  $2A
   9523  34e2
   9524  34e2		       a9 2a		      LDA	#$2A
   9525  34e4		       85 09		      STA	COLUBK
   9526  34e6				   .
   9527  34e6							;
   9528  34e6
   9529  34e6				   .L0439		;  scorecolor	=  $2C
   9530  34e6
   9531  34e6		       a9 2c		      LDA	#$2C
   9532  34e8		       85 a3		      STA	scorecolor
   9533  34ea				   .L0440		;  pfscorecolor  =  $2C
   9534  34ea
   9535  34ea		       a9 2c		      LDA	#$2C
   9536  34ec		       85 f4		      STA	pfscorecolor
   9537  34ee				   .
   9538  34ee							;
   9539  34ee
   9540  34ee				   .L0441		;  goto __Got_Pause_Colors
   9541  34ee
   9542  34ee		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9543  34f1
   9544  34f1				   .
   9545  34f1							;
   9546  34f1
   9547  34f1				   .
   9548  34f1							;
   9549  34f1
   9550  34f1				   .
   9551  34f1							;
   9552  34f1
   9553  34f1				   .
   9554  34f1							;
   9555  34f1
   9556  34f1				   .
   9557  34f1							;
   9558  34f1
   9559  34f1				   .
   9560  34f1							;
   9561  34f1
   9562  34f1				   .
   9563  34f1							;
   9564  34f1
   9565  34f1				   .__Ps7B
   9566  34f1							; __Ps7B
   9567  34f1
   9568  34f1				   .
   9569  34f1							;
   9570  34f1
   9571  34f1				   .L0442		;  pfcolors:
   9572  34f1
   9573  34f1		       a9 2a		      lda	# $2A
   9574  34f3		       85 08		      sta	COLUPF
   9575  34f5				  -	      ifconst	pfres
   9576  34f5				  -	      lda	#>(pfcolorlabel130-129+pfres*pfwidth)
   9577  34f5					      else
   9578  34f5		       a9 f6		      lda	#>(pfcolorlabel130-81)
   9579  34f7					      endif
   9580  34f7		       85 f1		      sta	pfcolortable+1
   9581  34f9				  -	      ifconst	pfres
   9582  34f9				  -	      lda	#<(pfcolorlabel130-129+pfres*pfwidth)
   9583  34f9					      else
   9584  34f9		       a9 33		      lda	#<(pfcolorlabel130-81)
   9585  34fb					      endif
   9586  34fb		       85 f0		      sta	pfcolortable
   9587  34fd				   .
   9588  34fd							;
   9589  34fd
   9590  34fd				   .L0443		;  COLUP0  =  $2A  :  COLUP1  =  $2A
   9591  34fd
   9592  34fd		       a9 2a		      LDA	#$2A
   9593  34ff		       85 06		      STA	COLUP0
   9594  3501		       85 07		      STA	COLUP1
   9595  3503				   .
   9596  3503							;
   9597  3503
   9598  3503				   .L0444		;  COLUBK  =  $2C
   9599  3503
   9600  3503		       a9 2c		      LDA	#$2C
   9601  3505		       85 09		      STA	COLUBK
   9602  3507				   .
   9603  3507							;
   9604  3507
   9605  3507				   .L0445		;  scorecolor	=  $2A
   9606  3507
   9607  3507		       a9 2a		      LDA	#$2A
   9608  3509		       85 a3		      STA	scorecolor
   9609  350b				   .L0446		;  pfscorecolor  =  $2A
   9610  350b
   9611  350b		       a9 2a		      LDA	#$2A
   9612  350d		       85 f4		      STA	pfscorecolor
   9613  350f				   .
   9614  350f							;
   9615  350f
   9616  350f				   .L0447		;  goto __Got_Pause_Colors
   9617  350f
   9618  350f		       4c 65 52 	      jmp	.__Got_Pause_Colors
   9619  3512
   9620  3512				   .
   9621  3512							;
   9622  3512
   9623  3512				   .
   9624  3512							;
   9625  3512
   9626  3512				   .
   9627  3512							;
   9628  3512
   9629  3512				   .L0448		;  bank 4
   9630  3512
   9631  3512					      if	ECHO3
      2754 bytes of ROM space left in bank 3
   9632  3512					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   9633  3512					      endif
   9634  3512		       00 01	   ECHO3      =	1
   9635  3fd4					      ORG	$3FF4-bscode_length
   9636  3fd4					      RORG	$5FF4-bscode_length
   9637  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   9638  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9639  3fd6				  -	      stx	FASTFETCH
   9640  3fd6					      endif
   9641  3fd6		       9a		      txs
   9642  3fd7				  -	      if	bankswitch == 64
   9643  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9644  3fd7					      else
   9645  3fd7		       a9 f2		      lda	#>(start-1)
   9646  3fd9					      endif
   9647  3fd9		       48		      pha
   9648  3fda		       a9 51		      lda	#<(start-1)
   9649  3fdc		       48		      pha
   9650  3fdd		       48		      pha
   9651  3fde		       8a		      txa
   9652  3fdf		       48		      pha
   9653  3fe0		       ba		      tsx
   9654  3fe1					      if	bankswitch != 64
   9655  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   9656  3fe3		       2a		      rol
   9657  3fe4		       2a		      rol
   9658  3fe5		       2a		      rol
   9659  3fe6		       2a		      rol
   9660  3fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9661  3fe9		       aa		      tax
   9662  3fea		       e8		      inx
   9663  3feb				  -	      else
   9664  3feb				  -	      lda	4,x	; get high byte of return address
   9665  3feb				  -	      tay
   9666  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9667  3feb				  -	      sta	4,x
   9668  3feb				  -	      tya
   9669  3feb				  -	      lsr
   9670  3feb				  -	      lsr
   9671  3feb				  -	      lsr
   9672  3feb				  -	      lsr
   9673  3feb				  -	      tax
   9674  3feb				  -	      inx
   9675  3feb					      endif
   9676  3feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9677  3fee		       68		      pla
   9678  3fef		       aa		      tax
   9679  3ff0		       68		      pla
   9680  3ff1		       60		      rts
   9681  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9682  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9683  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9684  3ff2					      endif
   9685  3ffc					      ORG	$3FFC
   9686  3ffc					      RORG	$5FFC
   9687  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   9688  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   9689  4000					      ORG	$4000
   9690  4000					      RORG	$7000
   9691  4000				   .
   9692  4000							;
   9693  4000
   9694  4000				   .
   9695  4000							;
   9696  4000
   9697  4000				   .
   9698  4000							;
   9699  4000
   9700  4000				   .L0449		;  bank 5
   9701  4000
   9702  4000					      if	ECHO4
      4052 bytes of ROM space left in bank 4
   9703  4000					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   9704  4000					      endif
   9705  4000		       00 01	   ECHO4      =	1
   9706  4fd4					      ORG	$4FF4-bscode_length
   9707  4fd4					      RORG	$7FF4-bscode_length
   9708  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   9709  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9710  4fd6				  -	      stx	FASTFETCH
   9711  4fd6					      endif
   9712  4fd6		       9a		      txs
   9713  4fd7				  -	      if	bankswitch == 64
   9714  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9715  4fd7					      else
   9716  4fd7		       a9 f2		      lda	#>(start-1)
   9717  4fd9					      endif
   9718  4fd9		       48		      pha
   9719  4fda		       a9 51		      lda	#<(start-1)
   9720  4fdc		       48		      pha
   9721  4fdd		       48		      pha
   9722  4fde		       8a		      txa
   9723  4fdf		       48		      pha
   9724  4fe0		       ba		      tsx
   9725  4fe1					      if	bankswitch != 64
   9726  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   9727  4fe3		       2a		      rol
   9728  4fe4		       2a		      rol
   9729  4fe5		       2a		      rol
   9730  4fe6		       2a		      rol
   9731  4fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9732  4fe9		       aa		      tax
   9733  4fea		       e8		      inx
   9734  4feb				  -	      else
   9735  4feb				  -	      lda	4,x	; get high byte of return address
   9736  4feb				  -	      tay
   9737  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9738  4feb				  -	      sta	4,x
   9739  4feb				  -	      tya
   9740  4feb				  -	      lsr
   9741  4feb				  -	      lsr
   9742  4feb				  -	      lsr
   9743  4feb				  -	      lsr
   9744  4feb				  -	      tax
   9745  4feb				  -	      inx
   9746  4feb					      endif
   9747  4feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9748  4fee		       68		      pla
   9749  4fef		       aa		      tax
   9750  4ff0		       68		      pla
   9751  4ff1		       60		      rts
   9752  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9753  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9754  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9755  4ff2					      endif
   9756  4ffc					      ORG	$4FFC
   9757  4ffc					      RORG	$7FFC
   9758  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   9759  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   9760  5000					      ORG	$5000
   9761  5000					      RORG	$9000
   9762  5000				   .
   9763  5000							;
   9764  5000
   9765  5000				   .
   9766  5000							;
   9767  5000
   9768  5000				   .
   9769  5000							;
   9770  5000
   9771  5000				   .L0450		;  bank 6
   9772  5000
   9773  5000					      if	ECHO5
      4052 bytes of ROM space left in bank 5
   9774  5000					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   9775  5000					      endif
   9776  5000		       00 01	   ECHO5      =	1
   9777  5fd4					      ORG	$5FF4-bscode_length
   9778  5fd4					      RORG	$9FF4-bscode_length
   9779  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   9780  5fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9781  5fd6				  -	      stx	FASTFETCH
   9782  5fd6					      endif
   9783  5fd6		       9a		      txs
   9784  5fd7				  -	      if	bankswitch == 64
   9785  5fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9786  5fd7					      else
   9787  5fd7		       a9 f2		      lda	#>(start-1)
   9788  5fd9					      endif
   9789  5fd9		       48		      pha
   9790  5fda		       a9 51		      lda	#<(start-1)
   9791  5fdc		       48		      pha
   9792  5fdd		       48		      pha
   9793  5fde		       8a		      txa
   9794  5fdf		       48		      pha
   9795  5fe0		       ba		      tsx
   9796  5fe1					      if	bankswitch != 64
   9797  5fe1		       b5 04		      lda	4,x	; get high byte of return address
   9798  5fe3		       2a		      rol
   9799  5fe4		       2a		      rol
   9800  5fe5		       2a		      rol
   9801  5fe6		       2a		      rol
   9802  5fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9803  5fe9		       aa		      tax
   9804  5fea		       e8		      inx
   9805  5feb				  -	      else
   9806  5feb				  -	      lda	4,x	; get high byte of return address
   9807  5feb				  -	      tay
   9808  5feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9809  5feb				  -	      sta	4,x
   9810  5feb				  -	      tya
   9811  5feb				  -	      lsr
   9812  5feb				  -	      lsr
   9813  5feb				  -	      lsr
   9814  5feb				  -	      lsr
   9815  5feb				  -	      tax
   9816  5feb				  -	      inx
   9817  5feb					      endif
   9818  5feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9819  5fee		       68		      pla
   9820  5fef		       aa		      tax
   9821  5ff0		       68		      pla
   9822  5ff1		       60		      rts
   9823  5ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9824  5ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9825  5ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9826  5ff2					      endif
   9827  5ffc					      ORG	$5FFC
   9828  5ffc					      RORG	$9FFC
   9829  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   9830  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   9831  6000					      ORG	$6000
   9832  6000					      RORG	$B000
   9833  6000				   .
   9834  6000							;
   9835  6000
   9836  6000				   .
   9837  6000							;
   9838  6000
   9839  6000				   .
   9840  6000							;
   9841  6000
   9842  6000				   .L0451		;  bank 7
   9843  6000
   9844  6000					      if	ECHO6
      4052 bytes of ROM space left in bank 6
   9845  6000					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   9846  6000					      endif
   9847  6000		       00 01	   ECHO6      =	1
   9848  6fd4					      ORG	$6FF4-bscode_length
   9849  6fd4					      RORG	$BFF4-bscode_length
   9850  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   9851  6fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9852  6fd6				  -	      stx	FASTFETCH
   9853  6fd6					      endif
   9854  6fd6		       9a		      txs
   9855  6fd7				  -	      if	bankswitch == 64
   9856  6fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9857  6fd7					      else
   9858  6fd7		       a9 f2		      lda	#>(start-1)
   9859  6fd9					      endif
   9860  6fd9		       48		      pha
   9861  6fda		       a9 51		      lda	#<(start-1)
   9862  6fdc		       48		      pha
   9863  6fdd		       48		      pha
   9864  6fde		       8a		      txa
   9865  6fdf		       48		      pha
   9866  6fe0		       ba		      tsx
   9867  6fe1					      if	bankswitch != 64
   9868  6fe1		       b5 04		      lda	4,x	; get high byte of return address
   9869  6fe3		       2a		      rol
   9870  6fe4		       2a		      rol
   9871  6fe5		       2a		      rol
   9872  6fe6		       2a		      rol
   9873  6fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9874  6fe9		       aa		      tax
   9875  6fea		       e8		      inx
   9876  6feb				  -	      else
   9877  6feb				  -	      lda	4,x	; get high byte of return address
   9878  6feb				  -	      tay
   9879  6feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9880  6feb				  -	      sta	4,x
   9881  6feb				  -	      tya
   9882  6feb				  -	      lsr
   9883  6feb				  -	      lsr
   9884  6feb				  -	      lsr
   9885  6feb				  -	      lsr
   9886  6feb				  -	      tax
   9887  6feb				  -	      inx
   9888  6feb					      endif
   9889  6feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9890  6fee		       68		      pla
   9891  6fef		       aa		      tax
   9892  6ff0		       68		      pla
   9893  6ff1		       60		      rts
   9894  6ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9895  6ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9896  6ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9897  6ff2					      endif
   9898  6ffc					      ORG	$6FFC
   9899  6ffc					      RORG	$BFFC
   9900  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   9901  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   9902  7000					      ORG	$7000
   9903  7000					      RORG	$D000
   9904  7000				   .
   9905  7000							;
   9906  7000
   9907  7000				   .
   9908  7000							;
   9909  7000
   9910  7000				   .
   9911  7000							;
   9912  7000
   9913  7000				   .L0452		;  bank 8
   9914  7000
   9915  7000					      if	ECHO7
      4052 bytes of ROM space left in bank 7
   9916  7000					      echo	"    ",[(start_bank7 - *)]d , "bytes of ROM space left in bank 7")
   9917  7000					      endif
   9918  7000		       00 01	   ECHO7      =	1
   9919  7fd4					      ORG	$7FF4-bscode_length
   9920  7fd4					      RORG	$DFF4-bscode_length
   9921  7fd4		       a2 ff	   start_bank7 ldx	#$ff
   9922  7fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9923  7fd6				  -	      stx	FASTFETCH
   9924  7fd6					      endif
   9925  7fd6		       9a		      txs
   9926  7fd7				  -	      if	bankswitch == 64
   9927  7fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9928  7fd7					      else
   9929  7fd7		       a9 f2		      lda	#>(start-1)
   9930  7fd9					      endif
   9931  7fd9		       48		      pha
   9932  7fda		       a9 51		      lda	#<(start-1)
   9933  7fdc		       48		      pha
   9934  7fdd		       48		      pha
   9935  7fde		       8a		      txa
   9936  7fdf		       48		      pha
   9937  7fe0		       ba		      tsx
   9938  7fe1					      if	bankswitch != 64
   9939  7fe1		       b5 04		      lda	4,x	; get high byte of return address
   9940  7fe3		       2a		      rol
   9941  7fe4		       2a		      rol
   9942  7fe5		       2a		      rol
   9943  7fe6		       2a		      rol
   9944  7fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9945  7fe9		       aa		      tax
   9946  7fea		       e8		      inx
   9947  7feb				  -	      else
   9948  7feb				  -	      lda	4,x	; get high byte of return address
   9949  7feb				  -	      tay
   9950  7feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9951  7feb				  -	      sta	4,x
   9952  7feb				  -	      tya
   9953  7feb				  -	      lsr
   9954  7feb				  -	      lsr
   9955  7feb				  -	      lsr
   9956  7feb				  -	      lsr
   9957  7feb				  -	      tax
   9958  7feb				  -	      inx
   9959  7feb					      endif
   9960  7feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9961  7fee		       68		      pla
   9962  7fef		       aa		      tax
   9963  7ff0		       68		      pla
   9964  7ff1		       60		      rts
   9965  7ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9966  7ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9967  7ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9968  7ff2					      endif
   9969  7ffc					      ORG	$7FFC
   9970  7ffc					      RORG	$DFFC
   9971  7ffc		       d4 df		      .word.w	(start_bank7 & $ffff)
   9972  7ffe		       d4 df		      .word.w	(start_bank7 & $ffff)
   9973  8000					      ORG	$8000
   9974  8000					      RORG	$F000
   9975  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   9976  8000
   9977  8000							; This is a 2-line kernel!
   9978  8000					      ifnconst	vertical_reflect
   9979  8000				   kernel
   9980  8000					      endif
   9981  8000		       85 02		      sta	WSYNC
   9982  8002		       a9 ff		      lda	#255
   9983  8004		       8d 96 02 	      sta	TIM64T
   9984  8007
   9985  8007		       a9 01		      lda	#1
   9986  8009		       85 27		      sta	VDELBL
   9987  800b		       85 25		      sta	VDELP0
   9988  800d		       a6 92		      ldx	ballheight
   9989  800f		       e8		      inx
   9990  8010		       e8		      inx
   9991  8011		       86 9f		      stx	temp4
   9992  8013		       a5 86		      lda	player1y
   9993  8015		       85 9e		      sta	temp3
   9994  8017
   9995  8017				  -	      ifconst	shakescreen
   9996  8017				  -	      jsr	doshakescreen
   9997  8017					      else
   9998  8017		       a6 90		      ldx	missile0height
   9999  8019		       e8		      inx
  10000  801a					      endif
  10001  801a
  10002  801a		       e8		      inx
  10003  801b		       86 f6		      stx	stack1
  10004  801d
  10005  801d		       a5 89		      lda	bally
  10006  801f		       85 f7		      sta	stack2
  10007  8021
  10008  8021		       a5 85		      lda	player0y
  10009  8023		       a2 00		      ldx	#0
  10010  8025		       85 02		      sta	WSYNC
  10011  8027		       86 1b		      stx	GRP0
  10012  8029		       86 1c		      stx	GRP1
  10013  802b		       86 0e		      stx	PF1L
  10014  802d		       86 0f		      stx	PF2
  10015  802f		       86 2c		      stx	CXCLR
  10016  8031				  -	      ifconst	readpaddle
  10017  8031				  -	      stx	paddle
  10018  8031					      else
      0  8031					      sleep	3
      1  8031				   .CYCLES    SET	3
      2  8031
      3  8031				  -	      IF	.CYCLES < 2
      4  8031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8031				  -	      ERR
      6  8031					      ENDIF
      7  8031
      8  8031					      IF	.CYCLES & 1
      9  8031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8031		       04 00		      nop	0
     11  8033				  -	      ELSE
     12  8033				  -	      bit	VSYNC
     13  8033					      ENDIF
     14  8033				   .CYCLES    SET	.CYCLES - 3
     15  8033					      ENDIF
     16  8033
     17  8033				  -	      REPEAT	.CYCLES / 2
     18  8033				  -	      nop
     19  8033					      REPEND
  10020  8033					      endif
  10021  8033
  10022  8033		       95 9d		      sta	temp2,x
  10023  8035
  10024  8035							;store these so they can be retrieved later
  10025  8035					      ifnconst	pfres
  10026  8035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
  10027  8037				  -	      else
  10028  8037				  -	      ldx	#132-pfres*pfwidth
  10029  8037					      endif
  10030  8037
  10031  8037		       c6 85		      dec	player0y
  10032  8039
  10033  8039		       a5 91		      lda	missile0y
  10034  803b		       85 a0		      sta	temp5
  10035  803d		       a5 88		      lda	missile1y
  10036  803f		       85 a1		      sta	temp6
  10037  8041
  10038  8041		       a5 ef		      lda	playfieldpos
  10039  8043		       85 9c		      sta	temp1
  10040  8045
  10041  8045				  -	      ifconst	pfrowheight
  10042  8045				  -	      lda	#pfrowheight+2
  10043  8045					      else
  10044  8045					      ifnconst	pfres
  10045  8045		       a9 0a		      lda	#10
  10046  8047				  -	      else
  10047  8047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
  10048  8047					      endif
  10049  8047					      endif
  10050  8047		       18		      clc
  10051  8048		       e5 ef		      sbc	playfieldpos
  10052  804a		       85 ef		      sta	playfieldpos
  10053  804c		       4c 74 f0 	      jmp	.startkernel
  10054  804f
  10055  804f				   .skipDrawP0
  10056  804f		       a9 00		      lda	#0
  10057  8051		       a8		      tay
  10058  8052		       4c a2 f0 	      jmp	.continueP0
  10059  8055
  10060  8055				   .skipDrawP1
  10061  8055		       a9 00		      lda	#0
  10062  8057		       a8		      tay
  10063  8058		       4c 7e f0 	      jmp	.continueP1
  10064  805b
  10065  805b				   .kerloop		; enter at cycle 59??
  10066  805b
  10067  805b				   continuekernel
      0  805b					      sleep	2
      1  805b				   .CYCLES    SET	2
      2  805b
      3  805b				  -	      IF	.CYCLES < 2
      4  805b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  805b				  -	      ERR
      6  805b					      ENDIF
      7  805b
      8  805b				  -	      IF	.CYCLES & 1
      9  805b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  805b				  -	      nop	0
     11  805b				  -	      ELSE
     12  805b				  -	      bit	VSYNC
     13  805b				  -	      ENDIF
     14  805b				  -.CYCLES    SET	.CYCLES - 3
     15  805b					      ENDIF
     16  805b
     17  805b					      REPEAT	.CYCLES / 2
     18  805b		       ea		      nop
     19  805c					      REPEND
  10069  805c				   continuekernel2
  10070  805c		       a5 92		      lda	ballheight
  10071  805e
  10072  805e				  -	      ifconst	pfres
  10073  805e				  -	      ldy	playfield+pfres*pfwidth-132,x
  10074  805e				  -	      sty	PF1L	;3
  10075  805e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
  10076  805e				  -	      sty	PF2L	;3
  10077  805e				  -	      ldy	playfield+pfres*pfwidth-129,x
  10078  805e				  -	      sty	PF1R	; 3 too early?
  10079  805e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
  10080  805e				  -	      sty	PF2R	;3
  10081  805e					      else
  10082  805e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
  10083  8060		       84 0e		      sty	PF1L	;3
  10084  8062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
  10085  8064		       84 0f		      sty	PF2L	;3
  10086  8066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
  10087  8068		       84 0e		      sty	PF1R	; 3 too early?
  10088  806a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
  10089  806c		       84 0f		      sty	PF2R	;3
  10090  806e					      endif
  10091  806e
  10092  806e							; should be playfield+$38 for width=2
  10093  806e
  10094  806e		       c7 89		      dcp	bally
  10095  8070		       2a		      rol
  10096  8071		       2a		      rol
  10097  8072							; rol
  10098  8072							; rol
  10099  8072				   goback
  10100  8072		       85 1f		      sta	ENABL
  10101  8074				   .startkernel
  10102  8074		       a5 8f		      lda	player1height	;3
  10103  8076		       c7 86		      dcp	player1y	;5
  10104  8078		       90 db		      bcc	.skipDrawP1	;2
  10105  807a		       a4 86		      ldy	player1y	;3
  10106  807c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
  10107  807e							; so it doesn't cross a page boundary!
  10108  807e
  10109  807e				   .continueP1
  10110  807e		       85 1c		      sta	GRP1	;3
  10111  8080
  10112  8080					      ifnconst	player1colors
  10113  8080		       a5 87		      lda	missile1height	;3
  10114  8082		       c7 88		      dcp	missile1y	;5
  10115  8084		       2a		      rol		;2
  10116  8085		       2a		      rol		;2
  10117  8086		       85 1e		      sta	ENAM1	;3
  10118  8088				  -	      else
  10119  8088				  -	      lda	(player1color),y
  10120  8088				  -	      sta	COLUP1
  10121  8088				  -	      ifnconst	playercolors
  10122  8088				  -	      sleep	7
  10123  8088				  -	      else
  10124  8088				  -	      lda.w	player0colorstore
  10125  8088				  -	      sta	COLUP0
  10126  8088				  -	      endif
  10127  8088					      endif
  10128  8088
  10129  8088				  -	      ifconst	pfres
  10130  8088				  -	      lda	playfield+pfres*pfwidth-132,x
  10131  8088				  -	      sta	PF1L	;3
  10132  8088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
  10133  8088				  -	      sta	PF2L	;3
  10134  8088				  -	      lda	playfield+pfres*pfwidth-129,x
  10135  8088				  -	      sta	PF1R	; 3 too early?
  10136  8088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
  10137  8088				  -	      sta	PF2R	;3
  10138  8088					      else
  10139  8088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
  10140  808a		       85 0e		      sta	PF1L	;3
  10141  808c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
  10142  808e		       85 0f		      sta	PF2L	;3
  10143  8090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
  10144  8092		       85 0e		      sta	PF1R	; 3 too early?
  10145  8094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
  10146  8096		       85 0f		      sta	PF2R	;3
  10147  8098					      endif
  10148  8098							; sleep 3
  10149  8098
  10150  8098		       a5 8e		      lda	player0height
  10151  809a		       c7 85		      dcp	player0y
  10152  809c		       90 b1		      bcc	.skipDrawP0
  10153  809e		       a4 85		      ldy	player0y
  10154  80a0		       b1 8a		      lda	(player0pointer),y
  10155  80a2				   .continueP0
  10156  80a2		       85 1b		      sta	GRP0
  10157  80a4
  10158  80a4				  -	      ifnconst	no_blank_lines
  10159  80a4				  -	      ifnconst	playercolors
  10160  80a4				  -	      lda	missile0height	;3
  10161  80a4				  -	      dcp	missile0y	;5
  10162  80a4				  -	      sbc	stack1
  10163  80a4				  -	      sta	ENAM0	;3
  10164  80a4				  -	      else
  10165  80a4				  -	      lda	(player0color),y
  10166  80a4				  -	      sta	player0colorstore
  10167  80a4				  -	      sleep	6
  10168  80a4				  -	      endif
  10169  80a4				  -	      dec	temp1
  10170  80a4				  -	      bne	continuekernel
  10171  80a4					      else
  10172  80a4		       c6 9c		      dec	temp1
  10173  80a6		       f0 0c		      beq	altkernel2
  10174  80a8				  -	      ifconst	readpaddle
  10175  80a8				  -	      ldy	currentpaddle
  10176  80a8				  -	      lda	INPT0,y
  10177  80a8				  -	      bpl	noreadpaddle
  10178  80a8				  -	      inc	paddle
  10179  80a8				  -	      jmp	continuekernel2
  10180  80a8				  -noreadpaddle
  10181  80a8				  -	      sleep	2
  10182  80a8				  -	      jmp	continuekernel
  10183  80a8					      else
  10184  80a8					      ifnconst	playercolors
  10185  80a8					      ifconst	PFcolors
  10186  80a8		       8a		      txa
  10187  80a9		       a8		      tay
  10188  80aa		       b1 f0		      lda	(pfcolortable),y
  10189  80ac					      ifnconst	backgroundchange
  10190  80ac		       85 08		      sta	COLUPF
  10191  80ae				  -	      else
  10192  80ae				  -	      sta	COLUBK
  10193  80ae					      endif
  10194  80ae		       4c 5b f0 	      jmp	continuekernel
  10195  80b1				  -	      else
  10196  80b1				  -	      ifconst	kernelmacrodef
  10197  80b1				  -	      kernelmacro
  10198  80b1				  -	      else
  10199  80b1				  -	      sleep	12
  10200  80b1				  -	      endif
  10201  80b1					      endif
  10202  80b1				  -	      else
  10203  80b1				  -	      lda	(player0color),y
  10204  80b1				  -	      sta	player0colorstore
  10205  80b1				  -	      sleep	4
  10206  80b1					      endif
  10207  80b1		       4c 5b f0 	      jmp	continuekernel
  10208  80b4					      endif
  10209  80b4				   altkernel2
  10210  80b4		       8a		      txa
  10211  80b5					      ifnconst	vertical_reflect
  10212  80b5		       cb fc		      sbx	#256-pfwidth
  10213  80b7				  -	      else
  10214  80b7				  -	      sbx	#256-pfwidth/2
  10215  80b7					      endif
  10216  80b7		       30 24		      bmi	lastkernelline
  10217  80b9				  -	      ifconst	pfrowheight
  10218  80b9				  -	      lda	#pfrowheight
  10219  80b9					      else
  10220  80b9					      ifnconst	pfres
  10221  80b9		       a9 08		      lda	#8
  10222  80bb				  -	      else
  10223  80bb				  -	      lda	#(96/pfres)	; try to come close to the real size
  10224  80bb					      endif
  10225  80bb					      endif
  10226  80bb		       85 9c		      sta	temp1
  10227  80bd		       4c 5b f0 	      jmp	continuekernel
  10228  80c0					      endif
  10229  80c0
  10230  80c0				   altkernel
  10231  80c0
  10232  80c0				  -	      ifconst	PFmaskvalue
  10233  80c0				  -	      lda	#PFmaskvalue
  10234  80c0					      else
  10235  80c0		       a9 00		      lda	#0
  10236  80c2					      endif
  10237  80c2		       85 0e		      sta	PF1L
  10238  80c4		       85 0f		      sta	PF2
  10239  80c6
  10240  80c6
  10241  80c6							;sleep 3
  10242  80c6
  10243  80c6							;28 cycles to fix things
  10244  80c6							;minus 11=17
  10245  80c6
  10246  80c6							; lax temp4
  10247  80c6							; clc
  10248  80c6		       8a		      txa
  10249  80c7					      ifnconst	vertical_reflect
  10250  80c7		       cb fc		      sbx	#256-pfwidth
  10251  80c9				  -	      else
  10252  80c9				  -	      sbx	#256-pfwidth/2
  10253  80c9					      endif
  10254  80c9
  10255  80c9		       30 12		      bmi	lastkernelline
  10256  80cb
  10257  80cb				  -	      ifconst	PFcolorandheight
  10258  80cb				  -	      ifconst	pfres
  10259  80cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
  10260  80cb				  -	      else
  10261  80cb				  -	      ldy	playfieldcolorandheight-87,x
  10262  80cb				  -	      endif
  10263  80cb				  -	      ifnconst	backgroundchange
  10264  80cb				  -	      sty	COLUPF
  10265  80cb				  -	      else
  10266  80cb				  -	      sty	COLUBK
  10267  80cb				  -	      endif
  10268  80cb				  -	      ifconst	pfres
  10269  80cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
  10270  80cb				  -	      else
  10271  80cb				  -	      lda	playfieldcolorandheight-88,x
  10272  80cb				  -	      endif
  10273  80cb				  -	      sta.w	temp1
  10274  80cb					      endif
  10275  80cb				  -	      ifconst	PFheights
  10276  80cb				  -	      lsr
  10277  80cb				  -	      lsr
  10278  80cb				  -	      tay
  10279  80cb				  -	      lda	(pfheighttable),y
  10280  80cb				  -	      sta.w	temp1
  10281  80cb					      endif
  10282  80cb					      ifconst	PFcolors
  10283  80cb		       a8		      tay
  10284  80cc		       b1 f0		      lda	(pfcolortable),y
  10285  80ce					      ifnconst	backgroundchange
  10286  80ce		       85 08		      sta	COLUPF
  10287  80d0				  -	      else
  10288  80d0				  -	      sta	COLUBK
  10289  80d0					      endif
  10290  80d0				  -	      ifconst	pfrowheight
  10291  80d0				  -	      lda	#pfrowheight
  10292  80d0					      else
  10293  80d0					      ifnconst	pfres
  10294  80d0		       a9 08		      lda	#8
  10295  80d2				  -	      else
  10296  80d2				  -	      lda	#(96/pfres)	; try to come close to the real size
  10297  80d2					      endif
  10298  80d2					      endif
  10299  80d2		       85 9c		      sta	temp1
  10300  80d4					      endif
  10301  80d4					      ifnconst	PFcolorandheight
  10302  80d4				  -	      ifnconst	PFcolors
  10303  80d4				  -	      ifnconst	PFheights
  10304  80d4				  -	      ifnconst	no_blank_lines
  10305  80d4				  -			; read paddle 0
  10306  80d4				  -			; lo-res paddle read
  10307  80d4				  -			; bit INPT0
  10308  80d4				  -			; bmi paddleskipread
  10309  80d4				  -			; inc paddle0
  10310  80d4				  -			;donepaddleskip
  10311  80d4				  -	      sleep	10
  10312  80d4				  -	      ifconst	pfrowheight
  10313  80d4				  -	      lda	#pfrowheight
  10314  80d4				  -	      else
  10315  80d4				  -	      ifnconst	pfres
  10316  80d4				  -	      lda	#8
  10317  80d4				  -	      else
  10318  80d4				  -	      lda	#(96/pfres)	; try to come close to the real size
  10319  80d4				  -	      endif
  10320  80d4				  -	      endif
  10321  80d4				  -	      sta	temp1
  10322  80d4				  -	      endif
  10323  80d4				  -	      endif
  10324  80d4					      endif
  10325  80d4					      endif
  10326  80d4
  10327  80d4
  10328  80d4		       a5 92		      lda	ballheight
  10329  80d6		       c7 89		      dcp	bally
  10330  80d8		       e5 9f		      sbc	temp4
  10331  80da
  10332  80da
  10333  80da		       4c 72 f0 	      jmp	goback
  10334  80dd
  10335  80dd
  10336  80dd				  -	      ifnconst	no_blank_lines
  10337  80dd				  -lastkernelline
  10338  80dd				  -	      ifnconst	PFcolors
  10339  80dd				  -	      sleep	10
  10340  80dd				  -	      else
  10341  80dd				  -	      ldy	#124
  10342  80dd				  -	      lda	(pfcolortable),y
  10343  80dd				  -	      sta	COLUPF
  10344  80dd				  -	      endif
  10345  80dd				  -
  10346  80dd				  -	      ifconst	PFheights
  10347  80dd				  -	      ldx	#1
  10348  80dd				  -			;sleep 4
  10349  80dd				  -	      sleep	3	; this was over 1 cycle
  10350  80dd				  -	      else
  10351  80dd				  -	      ldx	playfieldpos
  10352  80dd				  -			;sleep 3
  10353  80dd				  -	      sleep	2	; this was over 1 cycle
  10354  80dd				  -	      endif
  10355  80dd				  -
  10356  80dd				  -	      jmp	enterlastkernel
  10357  80dd				  -
  10358  80dd					      else
  10359  80dd				   lastkernelline
  10360  80dd
  10361  80dd				  -	      ifconst	PFheights
  10362  80dd				  -	      ldx	#1
  10363  80dd				  -			;sleep 5
  10364  80dd				  -	      sleep	4	; this was over 1 cycle
  10365  80dd					      else
  10366  80dd		       a6 ef		      ldx	playfieldpos
  10367  80df							;sleep 4
      0  80df					      sleep	3	; this was over 1 cycle
      1  80df				   .CYCLES    SET	3
      2  80df
      3  80df				  -	      IF	.CYCLES < 2
      4  80df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80df				  -	      ERR
      6  80df					      ENDIF
      7  80df
      8  80df					      IF	.CYCLES & 1
      9  80df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  80df		       04 00		      nop	0
     11  80e1				  -	      ELSE
     12  80e1				  -	      bit	VSYNC
     13  80e1					      ENDIF
     14  80e1				   .CYCLES    SET	.CYCLES - 3
     15  80e1					      ENDIF
     16  80e1
     17  80e1				  -	      REPEAT	.CYCLES / 2
     18  80e1				  -	      nop
     19  80e1					      REPEND
  10369  80e1					      endif
  10370  80e1
  10371  80e1		       e0 00		      cpx	#0
  10372  80e3		       d0 22		      bne	.enterfromNBL
  10373  80e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
  10374  80e8					      endif
  10375  80e8
  10376  80e8					      if	((<*)>$d5)
  10377  8100		       00 00 00 00*	      align	256
  10378  8100					      endif
  10379  8100							; this is a kludge to prevent page wrapping - fix!!!
  10380  8100
  10381  8100				   .skipDrawlastP1
  10382  8100		       a9 00		      lda	#0
  10383  8102		       a8		      tay		; added so we don't cross a page
  10384  8103		       4c 2d f1 	      jmp	.continuelastP1
  10385  8106
  10386  8106				   .endkerloop		; enter at cycle 59??
  10387  8106
  10388  8106		       ea		      nop
  10389  8107
  10390  8107				   .enterfromNBL
  10391  8107				  -	      ifconst	pfres
  10392  8107				  -	      ldy.w	playfield+pfres*pfwidth-4
  10393  8107				  -	      sty	PF1L	;3
  10394  8107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
  10395  8107				  -	      sty	PF2L	;3
  10396  8107				  -	      ldy.w	playfield+pfres*pfwidth-1
  10397  8107				  -	      sty	PF1R	; possibly too early?
  10398  8107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
  10399  8107				  -	      sty	PF2R	;3
  10400  8107					      else
  10401  8107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
  10402  810a		       84 0e		      sty	PF1L	;3
  10403  810c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
  10404  810f		       84 0f		      sty	PF2L	;3
  10405  8111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
  10406  8114		       84 0e		      sty	PF1R	; possibly too early?
  10407  8116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
  10408  8119		       84 0f		      sty	PF2R	;3
  10409  811b					      endif
  10410  811b
  10411  811b				   enterlastkernel
  10412  811b		       a5 92		      lda	ballheight
  10413  811d
  10414  811d							; tya
  10415  811d		       c7 89		      dcp	bally
  10416  811f							; sleep 4
  10417  811f
  10418  811f							; sbc stack3
  10419  811f		       2a		      rol
  10420  8120		       2a		      rol
  10421  8121		       85 1f		      sta	ENABL
  10422  8123
  10423  8123		       a5 8f		      lda	player1height	;3
  10424  8125		       c7 86		      dcp	player1y	;5
  10425  8127		       90 d7		      bcc	.skipDrawlastP1
  10426  8129		       a4 86		      ldy	player1y	;3
  10427  812b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
  10428  812d							; so it doesn't cross a page boundary!
  10429  812d
  10430  812d				   .continuelastP1
  10431  812d		       85 1c		      sta	GRP1	;3
  10432  812f
  10433  812f					      ifnconst	player1colors
  10434  812f		       a5 87		      lda	missile1height	;3
  10435  8131		       c7 88		      dcp	missile1y	;5
  10436  8133				  -	      else
  10437  8133				  -	      lda	(player1color),y
  10438  8133				  -	      sta	COLUP1
  10439  8133					      endif
  10440  8133
  10441  8133		       ca		      dex
  10442  8134							;dec temp4 ; might try putting this above PF writes
  10443  8134		       f0 34		      beq	endkernel
  10444  8136
  10445  8136
  10446  8136				  -	      ifconst	pfres
  10447  8136				  -	      ldy.w	playfield+pfres*pfwidth-4
  10448  8136				  -	      sty	PF1L	;3
  10449  8136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
  10450  8136				  -	      sty	PF2L	;3
  10451  8136				  -	      ldy.w	playfield+pfres*pfwidth-1
  10452  8136				  -	      sty	PF1R	; possibly too early?
  10453  8136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
  10454  8136				  -	      sty	PF2R	;3
  10455  8136					      else
  10456  8136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
  10457  8139		       84 0e		      sty	PF1L	;3
  10458  813b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
  10459  813e		       84 0f		      sty	PF2L	;3
  10460  8140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
  10461  8143		       84 0e		      sty	PF1R	; possibly too early?
  10462  8145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
  10463  8148		       84 0f		      sty	PF2R	;3
  10464  814a					      endif
  10465  814a
  10466  814a					      ifnconst	player1colors
  10467  814a		       2a		      rol		;2
  10468  814b		       2a		      rol		;2
  10469  814c		       85 1e		      sta	ENAM1	;3
  10470  814e				  -	      else
  10471  814e				  -	      ifnconst	playercolors
  10472  814e				  -	      sleep	7
  10473  814e				  -	      else
  10474  814e				  -	      lda.w	player0colorstore
  10475  814e				  -	      sta	COLUP0
  10476  814e				  -	      endif
  10477  814e					      endif
  10478  814e
  10479  814e		       ad 8e 00 	      lda.w	player0height
  10480  8151		       c7 85		      dcp	player0y
  10481  8153		       90 0d		      bcc	.skipDrawlastP0
  10482  8155		       a4 85		      ldy	player0y
  10483  8157		       b1 8a		      lda	(player0pointer),y
  10484  8159				   .continuelastP0
  10485  8159		       85 1b		      sta	GRP0
  10486  815b
  10487  815b
  10488  815b
  10489  815b				  -	      ifnconst	no_blank_lines
  10490  815b				  -	      lda	missile0height	;3
  10491  815b				  -	      dcp	missile0y	;5
  10492  815b				  -	      sbc	stack1
  10493  815b				  -	      sta	ENAM0	;3
  10494  815b				  -	      jmp	.endkerloop
  10495  815b					      else
  10496  815b				  -	      ifconst	readpaddle
  10497  815b				  -	      ldy	currentpaddle
  10498  815b				  -	      lda	INPT0,y
  10499  815b				  -	      bpl	noreadpaddle2
  10500  815b				  -	      inc	paddle
  10501  815b				  -	      jmp	.endkerloop
  10502  815b				  -noreadpaddle2
  10503  815b				  -	      sleep	4
  10504  815b				  -	      jmp	.endkerloop
  10505  815b					      else		; no_blank_lines and no paddle reading
  10506  815b		       68		      pla
  10507  815c		       48		      pha		; 14 cycles in 4 bytes
  10508  815d		       68		      pla
  10509  815e		       48		      pha
  10510  815f							; sleep 14
  10511  815f		       4c 06 f1 	      jmp	.endkerloop
  10512  8162					      endif
  10513  8162					      endif
  10514  8162
  10515  8162
  10516  8162							; ifconst donepaddleskip
  10517  8162							;paddleskipread
  10518  8162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
  10519  8162							; plus we get a lo-res paddle read
  10520  8162							; bmi donepaddleskip
  10521  8162							; endif
  10522  8162
  10523  8162				   .skipDrawlastP0
  10524  8162		       a9 00		      lda	#0
  10525  8164		       a8		      tay
  10526  8165		       4c 59 f1 	      jmp	.continuelastP0
  10527  8168
  10528  8168					      ifconst	no_blank_lines
  10529  8168				   no_blank_lines_bailout
  10530  8168		       a2 00		      ldx	#0
  10531  816a					      endif
  10532  816a
  10533  816a				   endkernel
  10534  816a							; 6 digit score routine
  10535  816a		       86 0e		      stx	PF1
  10536  816c		       86 0f		      stx	PF2
  10537  816e		       86 0d		      stx	PF0
  10538  8170		       18		      clc
  10539  8171
  10540  8171				  -	      ifconst	pfrowheight
  10541  8171				  -	      lda	#pfrowheight+2
  10542  8171					      else
  10543  8171					      ifnconst	pfres
  10544  8171		       a9 0a		      lda	#10
  10545  8173				  -	      else
  10546  8173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
  10547  8173					      endif
  10548  8173					      endif
  10549  8173
  10550  8173		       e5 ef		      sbc	playfieldpos
  10551  8175		       85 ef		      sta	playfieldpos
  10552  8177		       8a		      txa
  10553  8178
  10554  8178				  -	      ifconst	shakescreen
  10555  8178				  -	      bit	shakescreen
  10556  8178				  -	      bmi	noshakescreen2
  10557  8178				  -	      ldx	#$3D
  10558  8178				  -noshakescreen2
  10559  8178					      endif
  10560  8178
  10561  8178		       95 02		      sta	WSYNC,x
  10562  817a
  10563  817a							; STA WSYNC ;first one, need one more
  10564  817a		       85 0b		      sta	REFP0
  10565  817c		       85 0c		      sta	REFP1
  10566  817e		       85 1b		      STA	GRP0
  10567  8180		       85 1c		      STA	GRP1
  10568  8182							; STA PF1
  10569  8182							; STA PF2
  10570  8182		       85 2b		      sta	HMCLR
  10571  8184		       85 1d		      sta	ENAM0
  10572  8186		       85 1e		      sta	ENAM1
  10573  8188		       85 1f		      sta	ENABL
  10574  818a
  10575  818a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
  10576  818c		       85 85		      sta	player0y
  10577  818e		       a5 9e		      lda	temp3
  10578  8190		       85 86		      sta	player1y
  10579  8192					      ifnconst	player1colors
  10580  8192		       a5 a1		      lda	temp6
  10581  8194		       85 88		      sta	missile1y
  10582  8196					      endif
  10583  8196					      ifnconst	playercolors
  10584  8196					      ifnconst	readpaddle
  10585  8196		       a5 a0		      lda	temp5
  10586  8198		       85 91		      sta	missile0y
  10587  819a					      endif
  10588  819a					      endif
  10589  819a		       a5 f7		      lda	stack2
  10590  819c		       85 89		      sta	bally
  10591  819e
  10592  819e							; strangely, this isn't required any more. might have
  10593  819e							; resulted from the no_blank_lines score bounce fix
  10594  819e							;ifconst no_blank_lines
  10595  819e							;sta WSYNC
  10596  819e							;endif
  10597  819e
  10598  819e		       ad 84 02 	      lda	INTIM
  10599  81a1		       18		      clc
  10600  81a2					      ifnconst	vblank_time
  10601  81a2		       69 8e		      adc	#43+12+87
  10602  81a4				  -	      else
  10603  81a4				  -	      adc	#vblank_time+12+87
  10604  81a4				  -
  10605  81a4					      endif
  10606  81a4							; sta WSYNC
  10607  81a4		       8d 96 02 	      sta	TIM64T
  10608  81a7
  10609  81a7				  -	      ifconst	minikernel
  10610  81a7				  -	      jsr	minikernel
  10611  81a7					      endif
  10612  81a7
  10613  81a7							; now reassign temp vars for score pointers
  10614  81a7
  10615  81a7							; score pointers contain:
  10616  81a7							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
  10617  81a7							; swap lo2->temp1
  10618  81a7							; swap lo4->temp3
  10619  81a7							; swap lo6->temp5
  10620  81a7					      ifnconst	noscore
  10621  81a7		       a5 97		      lda	scorepointers+1
  10622  81a9							; ldy temp1
  10623  81a9		       85 9c		      sta	temp1
  10624  81ab							; sty scorepointers+1
  10625  81ab
  10626  81ab		       a5 99		      lda	scorepointers+3
  10627  81ad							; ldy temp3
  10628  81ad		       85 9e		      sta	temp3
  10629  81af							; sty scorepointers+3
  10630  81af
  10631  81af
  10632  81af		       85 2b		      sta	HMCLR
  10633  81b1		       ba		      tsx
  10634  81b2		       86 f6		      stx	stack1
  10635  81b4		       a2 e0		      ldx	#$E0
  10636  81b6		       86 20		      stx	HMP0
  10637  81b8
  10638  81b8		       a5 a3		      LDA	scorecolor
  10639  81ba		       85 06		      STA	COLUP0
  10640  81bc		       85 07		      STA	COLUP1
  10641  81be				  -	      ifconst	scorefade
  10642  81be				  -	      STA	stack2
  10643  81be					      endif
  10644  81be					      ifconst	pfscore
  10645  81be		       a5 f4		      lda	pfscorecolor
  10646  81c0		       85 08		      sta	COLUPF
  10647  81c2					      endif
  10648  81c2		       85 02		      sta	WSYNC
  10649  81c4		       a2 00		      ldx	#0
  10650  81c6		       86 1b		      STx	GRP0
  10651  81c8		       86 1c		      STx	GRP1	; seems to be needed because of vdel
  10652  81ca
  10653  81ca		       a5 9b		      lda	scorepointers+5
  10654  81cc							; ldy temp5
  10655  81cc		       95 a0		      sta	temp5,x
  10656  81ce							; sty scorepointers+5
  10657  81ce		       a9 ff		      lda	#>scoretable
  10658  81d0		       85 97		      sta	scorepointers+1
  10659  81d2		       85 99		      sta	scorepointers+3
  10660  81d4		       85 9b		      sta	scorepointers+5
  10661  81d6		       85 9d		      sta	temp2
  10662  81d8		       85 9f		      sta	temp4
  10663  81da		       85 a1		      sta	temp6
  10664  81dc		       a0 07		      LDY	#7
  10665  81de		       84 25		      STY	VDELP0
  10666  81e0		       85 10		      STA	RESP0
  10667  81e2		       85 11		      STA	RESP1
  10668  81e4
  10669  81e4
  10670  81e4		       a9 03		      LDA	#$03
  10671  81e6		       85 04		      STA	NUSIZ0
  10672  81e8		       85 05		      STA	NUSIZ1
  10673  81ea		       85 26		      STA	VDELP1
  10674  81ec		       a9 f0		      LDA	#$F0
  10675  81ee		       85 21		      STA	HMP1
  10676  81f0		       b1 96		      lda	(scorepointers),y
  10677  81f2		       85 1b		      sta	GRP0
  10678  81f4		       85 2a		      STA	HMOVE	; cycle 73 ?
  10679  81f6		       4c 09 f2 	      jmp	beginscore
  10680  81f9
  10681  81f9
  10682  81f9					      if	((<*)>$d4)
  10683  8200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
  10684  8200					      endif
  10685  8200
  10686  8200				   loop2
  10687  8200		       b1 96		      lda	(scorepointers),y	;+5 68 204
  10688  8202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
  10689  8204					      ifconst	pfscore
  10690  8204		       ad f2 00 	      lda.w	pfscore1
  10691  8207		       85 0e		      sta	PF1
  10692  8209				  -	      else
  10693  8209				  -	      ifconst	scorefade
  10694  8209				  -	      sleep	2
  10695  8209				  -	      dec	stack2	; decrement the temporary scorecolor
  10696  8209				  -	      else
  10697  8209				  -	      sleep	7
  10698  8209				  -	      endif
  10699  8209					      endif
  10700  8209							; cycle 0
  10701  8209				   beginscore
  10702  8209		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
  10703  820b		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
  10704  820d		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
  10705  820f		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
  10706  8211		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
  10707  8213		       9a		      txs
  10708  8214		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
  10709  8216				  -	      ifconst	scorefade
  10710  8216				  -	      lda	stack2
  10711  8216					      else
      0  8216					      sleep	3
      1  8216				   .CYCLES    SET	3
      2  8216
      3  8216				  -	      IF	.CYCLES < 2
      4  8216				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8216				  -	      ERR
      6  8216					      ENDIF
      7  8216
      8  8216					      IF	.CYCLES & 1
      9  8216					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8216		       04 00		      nop	0
     11  8218				  -	      ELSE
     12  8218				  -	      bit	VSYNC
     13  8218					      ENDIF
     14  8218				   .CYCLES    SET	.CYCLES - 3
     15  8218					      ENDIF
     16  8218
     17  8218				  -	      REPEAT	.CYCLES / 2
     18  8218				  -	      nop
     19  8218					      REPEND
  10713  8218					      endif
  10714  8218
  10715  8218					      ifconst	pfscore
  10716  8218		       a5 f3		      lda	pfscore2
  10717  821a		       85 0e		      sta	PF1
  10718  821c				  -	      else
  10719  821c				  -	      ifconst	scorefade
  10720  821c				  -	      sta	COLUP0
  10721  821c				  -	      sta	COLUP1
  10722  821c				  -	      else
  10723  821c				  -	      sleep	6
  10724  821c				  -	      endif
  10725  821c					      endif
  10726  821c
  10727  821c		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
  10728  821e		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
  10729  8220		       ba		      tsx
  10730  8221		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
  10731  8223		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
  10732  8225		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
  10733  8227		       88		      dey
  10734  8228		       10 d6		      bpl	loop2	;+2 60 180
  10735  822a
  10736  822a		       a6 f6		      ldx	stack1
  10737  822c		       9a		      txs
  10738  822d							; lda scorepointers+1
  10739  822d		       a4 9c		      ldy	temp1
  10740  822f							; sta temp1
  10741  822f		       84 97		      sty	scorepointers+1
  10742  8231
  10743  8231		       a9 00		      LDA	#0
  10744  8233		       85 0e		      sta	PF1
  10745  8235		       85 1b		      STA	GRP0
  10746  8237		       85 1c		      STA	GRP1
  10747  8239		       85 25		      STA	VDELP0
  10748  823b		       85 26		      STA	VDELP1	;do we need these
  10749  823d		       85 04		      STA	NUSIZ0
  10750  823f		       85 05		      STA	NUSIZ1
  10751  8241
  10752  8241							; lda scorepointers+3
  10753  8241		       a4 9e		      ldy	temp3
  10754  8243							; sta temp3
  10755  8243		       84 99		      sty	scorepointers+3
  10756  8245
  10757  8245							; lda scorepointers+5
  10758  8245		       a4 a0		      ldy	temp5
  10759  8247							; sta temp5
  10760  8247		       84 9b		      sty	scorepointers+5
  10761  8249					      endif		;noscore
  10762  8249				  -	      ifconst	readpaddle
  10763  8249				  -	      lda	#%11000010
  10764  8249					      else
  10765  8249				  -	      ifconst	qtcontroller
  10766  8249				  -	      lda	qtcontroller
  10767  8249				  -	      lsr		; bit 0 in carry
  10768  8249				  -	      lda	#4
  10769  8249				  -	      ror		; carry into top of A
  10770  8249					      else
  10771  8249		       a9 02		      lda	#2
  10772  824b					      endif		; qtcontroller
  10773  824b					      endif		; readpaddle
  10774  824b		       85 02		      sta	WSYNC
  10775  824d		       85 01		      sta	VBLANK
      0  824f					      RETURN
      1  824f				  -	      ifnconst	bankswitch
      2  824f				  -	      rts
      3  824f					      else
      4  824f		       4c dd ff 	      jmp	BS_return
      5  8252					      endif
  10777  8252				  -	      ifconst	shakescreen
  10778  8252				  -doshakescreen
  10779  8252				  -	      bit	shakescreen
  10780  8252				  -	      bmi	noshakescreen
  10781  8252				  -	      sta	WSYNC
  10782  8252				  -noshakescreen
  10783  8252				  -	      ldx	missile0height
  10784  8252				  -	      inx
  10785  8252				  -	      rts
  10786  8252					      endif
  10787  8252
  10788  8252							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10789  8252
  10790  8252				   start
  10791  8252		       78		      sei
  10792  8253		       d8		      cld
  10793  8254		       a0 00		      ldy	#0
  10794  8256		       a5 d0		      lda	$D0
  10795  8258		       c9 2c		      cmp	#$2C	;check RAM location #1
  10796  825a		       d0 07		      bne	MachineIs2600
  10797  825c		       a5 d1		      lda	$D1
  10798  825e		       c9 a9		      cmp	#$A9	;check RAM location #2
  10799  8260		       d0 01		      bne	MachineIs2600
  10800  8262		       88		      dey
  10801  8263				   MachineIs2600
  10802  8263		       a2 00		      ldx	#0
  10803  8265		       8a		      txa
  10804  8266				   clearmem
  10805  8266		       e8		      inx
  10806  8267		       9a		      txs
  10807  8268		       48		      pha
  10808  8269		       d0 fb		      bne	clearmem
  10809  826b		       84 9c		      sty	temp1
  10810  826d					      ifnconst	multisprite
  10811  826d				  -	      ifconst	pfrowheight
  10812  826d				  -	      lda	#pfrowheight
  10813  826d					      else
  10814  826d				  -	      ifconst	pfres
  10815  826d				  -	      lda	#(96/pfres)
  10816  826d					      else
  10817  826d		       a9 08		      lda	#8
  10818  826f					      endif
  10819  826f					      endif
  10820  826f		       85 ef		      sta	playfieldpos
  10821  8271					      endif
  10822  8271		       a2 05		      ldx	#5
  10823  8273				   initscore
  10824  8273		       a9 74		      lda	#<scoretable
  10825  8275		       95 96		      sta	scorepointers,x
  10826  8277		       ca		      dex
  10827  8278		       10 f9		      bpl	initscore
  10828  827a		       a9 01		      lda	#1
  10829  827c		       85 0a		      sta	CTRLPF
  10830  827e		       0d 84 02 	      ora	INTIM
  10831  8281		       85 a2		      sta	rand
  10832  8283
  10833  8283				  -	      ifconst	multisprite
  10834  8283				  -	      jsr	multisprite_setup
  10835  8283					      endif
  10836  8283
  10837  8283				  -	      ifnconst	bankswitch
  10838  8283				  -	      jmp	game
  10839  8283					      else
  10840  8283		       a9 0f		      lda	#>(game-1)
  10841  8285		       48		      pha
  10842  8286		       a9 ff		      lda	#<(game-1)
  10843  8288		       48		      pha
  10844  8289		       48		      pha
  10845  828a		       48		      pha
  10846  828b		       a2 01		      ldx	#1
  10847  828d		       4c eb ff 	      jmp	BS_jsr
  10848  8290					      endif
  10849  8290							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10850  8290
  10851  8290							; playfield drawing routines
  10852  8290							; you get a 32x12 bitmapped display in a single color :)
  10853  8290							; 0-31 and 0-11
  10854  8290
  10855  8290				   pfclear		; clears playfield - or fill with pattern
  10856  8290				  -	      ifconst	pfres
  10857  8290				  -	      ldx	#pfres*pfwidth-1
  10858  8290					      else
  10859  8290		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
  10860  8292					      endif
  10861  8292				   pfclear_loop
  10862  8292					      ifnconst	superchip
  10863  8292		       95 a4		      sta	playfield,x
  10864  8294				  -	      else
  10865  8294				  -	      sta	playfield-128,x
  10866  8294					      endif
  10867  8294		       ca		      dex
  10868  8295		       10 fb		      bpl	pfclear_loop
      0  8297					      RETURN
      1  8297				  -	      ifnconst	bankswitch
      2  8297				  -	      rts
      3  8297					      else
      4  8297		       4c dd ff 	      jmp	BS_return
      5  829a					      endif
  10870  829a
  10871  829a				   setuppointers
  10872  829a		       86 9d		      stx	temp2	; store on.off.flip value
  10873  829c		       aa		      tax		; put x-value in x 
  10874  829d		       4a		      lsr
  10875  829e		       4a		      lsr
  10876  829f		       4a		      lsr		; divide x pos by 8 
  10877  82a0		       85 9c		      sta	temp1
  10878  82a2		       98		      tya
  10879  82a3		       0a		      asl
  10880  82a4					      if	pfwidth=4
  10881  82a4		       0a		      asl		; multiply y pos by 4
  10882  82a5					      endif		; else multiply by 2
  10883  82a5		       18		      clc
  10884  82a6		       65 9c		      adc	temp1	; add them together to get actual memory location offset
  10885  82a8		       a8		      tay		; put the value in y
  10886  82a9		       a5 9d		      lda	temp2	; restore on.off.flip value
  10887  82ab		       60		      rts
  10888  82ac
  10889  82ac				   pfread
  10890  82ac							;x=xvalue, y=yvalue
  10891  82ac		       20 9a f2 	      jsr	setuppointers
  10892  82af		       bd 44 f3 	      lda	setbyte,x
  10893  82b2		       39 a4 00 	      and	playfield,y
  10894  82b5		       5d 44 f3 	      eor	setbyte,x
  10895  82b8							; beq readzero
  10896  82b8							; lda #1
  10897  82b8							; readzero
      0  82b8					      RETURN
      1  82b8				  -	      ifnconst	bankswitch
      2  82b8				  -	      rts
      3  82b8					      else
      4  82b8		       4c dd ff 	      jmp	BS_return
      5  82bb					      endif
  10899  82bb
  10900  82bb				   pfpixel
  10901  82bb							;x=xvalue, y=yvalue, a=0,1,2
  10902  82bb		       20 9a f2 	      jsr	setuppointers
  10903  82be
  10904  82be					      ifconst	bankswitch
  10905  82be		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
  10906  82c0		       f0 0f		      beq	pixelon_r	; if "on" go to on
  10907  82c2		       4a		      lsr
  10908  82c3		       b0 18		      bcs	pixeloff_r	; value is 1 if true
  10909  82c5		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
  10910  82c8		       5d 44 f3 	      eor	setbyte,x
  10911  82cb				  -	      ifconst	superchip
  10912  82cb				  -	      sta	playfield-128,y
  10913  82cb					      else
  10914  82cb		       99 a4 00 	      sta	playfield,y
  10915  82ce					      endif
      0  82ce					      RETURN
      1  82ce				  -	      ifnconst	bankswitch
      2  82ce				  -	      rts
      3  82ce					      else
      4  82ce		       4c dd ff 	      jmp	BS_return
      5  82d1					      endif
  10917  82d1				   pixelon_r
  10918  82d1		       b9 a4 00 	      lda	playfield,y
  10919  82d4		       1d 44 f3 	      ora	setbyte,x
  10920  82d7				  -	      ifconst	superchip
  10921  82d7				  -	      sta	playfield-128,y
  10922  82d7					      else
  10923  82d7		       99 a4 00 	      sta	playfield,y
  10924  82da					      endif
      0  82da					      RETURN
      1  82da				  -	      ifnconst	bankswitch
      2  82da				  -	      rts
      3  82da					      else
      4  82da		       4c dd ff 	      jmp	BS_return
      5  82dd					      endif
  10926  82dd				   pixeloff_r
  10927  82dd		       bd 44 f3 	      lda	setbyte,x
  10928  82e0		       49 ff		      eor	#$ff
  10929  82e2		       39 a4 00 	      and	playfield,y
  10930  82e5				  -	      ifconst	superchip
  10931  82e5				  -	      sta	playfield-128,y
  10932  82e5					      else
  10933  82e5		       99 a4 00 	      sta	playfield,y
  10934  82e8					      endif
      0  82e8					      RETURN
      1  82e8				  -	      ifnconst	bankswitch
      2  82e8				  -	      rts
      3  82e8					      else
      4  82e8		       4c dd ff 	      jmp	BS_return
      5  82eb					      endif
  10936  82eb
  10937  82eb				  -	      else
  10938  82eb				  -	      jmp	plotpoint
  10939  82eb					      endif
  10940  82eb
  10941  82eb				   pfhline
  10942  82eb							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
  10943  82eb		       20 9a f2 	      jsr	setuppointers
  10944  82ee		       4c f8 f2 	      jmp	noinc
  10945  82f1				   keepgoing
  10946  82f1		       e8		      inx
  10947  82f2		       8a		      txa
  10948  82f3		       29 07		      and	#7
  10949  82f5		       d0 01		      bne	noinc
  10950  82f7		       c8		      iny
  10951  82f8				   noinc
  10952  82f8		       20 1d f3 	      jsr	plotpoint
  10953  82fb		       e4 9e		      cpx	temp3
  10954  82fd		       30 f2		      bmi	keepgoing
      0  82ff					      RETURN
      1  82ff				  -	      ifnconst	bankswitch
      2  82ff				  -	      rts
      3  82ff					      else
      4  82ff		       4c dd ff 	      jmp	BS_return
      5  8302					      endif
  10956  8302
  10957  8302				   pfvline
  10958  8302							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
  10959  8302		       20 9a f2 	      jsr	setuppointers
  10960  8305		       84 9c		      sty	temp1	; store memory location offset
  10961  8307		       e6 9e		      inc	temp3	; increase final x by 1 
  10962  8309		       a5 9e		      lda	temp3
  10963  830b		       0a		      asl
  10964  830c					      if	pfwidth=4
  10965  830c		       0a		      asl		; multiply by 4
  10966  830d					      endif		; else multiply by 2
  10967  830d		       85 9e		      sta	temp3	; store it
  10968  830f							; Thanks to Michael Rideout for fixing a bug in this code
  10969  830f							; right now, temp1=y=starting memory location, temp3=final
  10970  830f							; x should equal original x value
  10971  830f				   keepgoingy
  10972  830f		       20 1d f3 	      jsr	plotpoint
  10973  8312		       c8		      iny
  10974  8313		       c8		      iny
  10975  8314					      if	pfwidth=4
  10976  8314		       c8		      iny
  10977  8315		       c8		      iny
  10978  8316					      endif
  10979  8316		       c4 9e		      cpy	temp3
  10980  8318		       30 f5		      bmi	keepgoingy
      0  831a					      RETURN
      1  831a				  -	      ifnconst	bankswitch
      2  831a				  -	      rts
      3  831a					      else
      4  831a		       4c dd ff 	      jmp	BS_return
      5  831d					      endif
  10982  831d
  10983  831d				   plotpoint
  10984  831d		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
  10985  831f		       f0 0d		      beq	pixelon	; if "on" go to on
  10986  8321		       4a		      lsr
  10987  8322		       b0 14		      bcs	pixeloff	; value is 1 if true
  10988  8324		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
  10989  8327		       5d 44 f3 	      eor	setbyte,x
  10990  832a				  -	      ifconst	superchip
  10991  832a				  -	      sta	playfield-128,y
  10992  832a					      else
  10993  832a		       99 a4 00 	      sta	playfield,y
  10994  832d					      endif
  10995  832d		       60		      rts
  10996  832e				   pixelon
  10997  832e		       b9 a4 00 	      lda	playfield,y
  10998  8331		       1d 44 f3 	      ora	setbyte,x
  10999  8334				  -	      ifconst	superchip
  11000  8334				  -	      sta	playfield-128,y
  11001  8334					      else
  11002  8334		       99 a4 00 	      sta	playfield,y
  11003  8337					      endif
  11004  8337		       60		      rts
  11005  8338				   pixeloff
  11006  8338		       bd 44 f3 	      lda	setbyte,x
  11007  833b		       49 ff		      eor	#$ff
  11008  833d		       39 a4 00 	      and	playfield,y
  11009  8340				  -	      ifconst	superchip
  11010  8340				  -	      sta	playfield-128,y
  11011  8340					      else
  11012  8340		       99 a4 00 	      sta	playfield,y
  11013  8343					      endif
  11014  8343		       60		      rts
  11015  8344
  11016  8344				   setbyte
  11017  8344					      ifnconst	pfcenter
  11018  8344		       80		      .byte.b	$80
  11019  8345		       40		      .byte.b	$40
  11020  8346		       20		      .byte.b	$20
  11021  8347		       10		      .byte.b	$10
  11022  8348		       08		      .byte.b	$08
  11023  8349		       04		      .byte.b	$04
  11024  834a		       02		      .byte.b	$02
  11025  834b		       01		      .byte.b	$01
  11026  834c					      endif
  11027  834c		       01		      .byte.b	$01
  11028  834d		       02		      .byte.b	$02
  11029  834e		       04		      .byte.b	$04
  11030  834f		       08		      .byte.b	$08
  11031  8350		       10		      .byte.b	$10
  11032  8351		       20		      .byte.b	$20
  11033  8352		       40		      .byte.b	$40
  11034  8353		       80		      .byte.b	$80
  11035  8354		       80		      .byte.b	$80
  11036  8355		       40		      .byte.b	$40
  11037  8356		       20		      .byte.b	$20
  11038  8357		       10		      .byte.b	$10
  11039  8358		       08		      .byte.b	$08
  11040  8359		       04		      .byte.b	$04
  11041  835a		       02		      .byte.b	$02
  11042  835b		       01		      .byte.b	$01
  11043  835c		       01		      .byte.b	$01
  11044  835d		       02		      .byte.b	$02
  11045  835e		       04		      .byte.b	$04
  11046  835f		       08		      .byte.b	$08
  11047  8360		       10		      .byte.b	$10
  11048  8361		       20		      .byte.b	$20
  11049  8362		       40		      .byte.b	$40
  11050  8363		       80		      .byte.b	$80
  11051  8364							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11052  8364
  11053  8364				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
  11054  8364		       d0 15		      bne	notleft
  11055  8366							;left
  11056  8366				  -	      ifconst	pfres
  11057  8366				  -	      ldx	#pfres*4
  11058  8366					      else
  11059  8366		       a2 30		      ldx	#48
  11060  8368					      endif
  11061  8368				   leftloop
  11062  8368		       b5 a3		      lda	playfield-1,x
  11063  836a		       4a		      lsr
  11064  836b
  11065  836b				  -	      ifconst	superchip
  11066  836b				  -	      lda	playfield-2,x
  11067  836b				  -	      rol
  11068  836b				  -	      sta	playfield-130,x
  11069  836b				  -	      lda	playfield-3,x
  11070  836b				  -	      ror
  11071  836b				  -	      sta	playfield-131,x
  11072  836b				  -	      lda	playfield-4,x
  11073  836b				  -	      rol
  11074  836b				  -	      sta	playfield-132,x
  11075  836b				  -	      lda	playfield-1,x
  11076  836b				  -	      ror
  11077  836b				  -	      sta	playfield-129,x
  11078  836b					      else
  11079  836b		       36 a2		      rol	playfield-2,x
  11080  836d		       76 a1		      ror	playfield-3,x
  11081  836f		       36 a0		      rol	playfield-4,x
  11082  8371		       76 a3		      ror	playfield-1,x
  11083  8373					      endif
  11084  8373
  11085  8373		       8a		      txa
  11086  8374		       cb 04		      sbx	#4
  11087  8376		       d0 f0		      bne	leftloop
      0  8378					      RETURN
      1  8378				  -	      ifnconst	bankswitch
      2  8378				  -	      rts
      3  8378					      else
      4  8378		       4c dd ff 	      jmp	BS_return
      5  837b					      endif
  11089  837b
  11090  837b				   notleft
  11091  837b		       4a		      lsr
  11092  837c		       90 15		      bcc	notright
  11093  837e							;right
  11094  837e
  11095  837e				  -	      ifconst	pfres
  11096  837e				  -	      ldx	#pfres*4
  11097  837e					      else
  11098  837e		       a2 30		      ldx	#48
  11099  8380					      endif
  11100  8380				   rightloop
  11101  8380		       b5 a0		      lda	playfield-4,x
  11102  8382		       4a		      lsr
  11103  8383				  -	      ifconst	superchip
  11104  8383				  -	      lda	playfield-3,x
  11105  8383				  -	      rol
  11106  8383				  -	      sta	playfield-131,x
  11107  8383				  -	      lda	playfield-2,x
  11108  8383				  -	      ror
  11109  8383				  -	      sta	playfield-130,x
  11110  8383				  -	      lda	playfield-1,x
  11111  8383				  -	      rol
  11112  8383				  -	      sta	playfield-129,x
  11113  8383				  -	      lda	playfield-4,x
  11114  8383				  -	      ror
  11115  8383				  -	      sta	playfield-132,x
  11116  8383					      else
  11117  8383		       36 a1		      rol	playfield-3,x
  11118  8385		       76 a2		      ror	playfield-2,x
  11119  8387		       36 a3		      rol	playfield-1,x
  11120  8389		       76 a0		      ror	playfield-4,x
  11121  838b					      endif
  11122  838b		       8a		      txa
  11123  838c		       cb 04		      sbx	#4
  11124  838e		       d0 f0		      bne	rightloop
      0  8390					      RETURN
      1  8390				  -	      ifnconst	bankswitch
      2  8390				  -	      rts
      3  8390					      else
      4  8390		       4c dd ff 	      jmp	BS_return
      5  8393					      endif
  11126  8393
  11127  8393				   notright
  11128  8393		       4a		      lsr
  11129  8394		       90 4b		      bcc	notup
  11130  8396							;up
  11131  8396		       4a		      lsr
  11132  8397		       90 02		      bcc	onedecup
  11133  8399		       c6 ef		      dec	playfieldpos
  11134  839b				   onedecup
  11135  839b		       c6 ef		      dec	playfieldpos
  11136  839d		       f0 02		      beq	shiftdown
  11137  839f		       10 3d		      bpl	noshiftdown2
  11138  83a1				   shiftdown
  11139  83a1				  -	      ifconst	pfrowheight
  11140  83a1				  -	      lda	#pfrowheight
  11141  83a1					      else
  11142  83a1					      ifnconst	pfres
  11143  83a1		       a9 08		      lda	#8
  11144  83a3				  -	      else
  11145  83a3				  -	      lda	#(96/pfres)	; try to come close to the real size
  11146  83a3					      endif
  11147  83a3					      endif
  11148  83a3
  11149  83a3		       85 ef		      sta	playfieldpos
  11150  83a5		       a5 a7		      lda	playfield+3
  11151  83a7		       85 9f		      sta	temp4
  11152  83a9		       a5 a6		      lda	playfield+2
  11153  83ab		       85 9e		      sta	temp3
  11154  83ad		       a5 a5		      lda	playfield+1
  11155  83af		       85 9d		      sta	temp2
  11156  83b1		       a5 a4		      lda	playfield
  11157  83b3		       85 9c		      sta	temp1
  11158  83b5		       a2 00		      ldx	#0
  11159  83b7				   up2
  11160  83b7		       b5 a8		      lda	playfield+4,x
  11161  83b9				  -	      ifconst	superchip
  11162  83b9				  -	      sta	playfield-128,x
  11163  83b9				  -	      lda	playfield+5,x
  11164  83b9				  -	      sta	playfield-127,x
  11165  83b9				  -	      lda	playfield+6,x
  11166  83b9				  -	      sta	playfield-126,x
  11167  83b9				  -	      lda	playfield+7,x
  11168  83b9				  -	      sta	playfield-125,x
  11169  83b9					      else
  11170  83b9		       95 a4		      sta	playfield,x
  11171  83bb		       b5 a9		      lda	playfield+5,x
  11172  83bd		       95 a5		      sta	playfield+1,x
  11173  83bf		       b5 aa		      lda	playfield+6,x
  11174  83c1		       95 a6		      sta	playfield+2,x
  11175  83c3		       b5 ab		      lda	playfield+7,x
  11176  83c5		       95 a7		      sta	playfield+3,x
  11177  83c7					      endif
  11178  83c7		       8a		      txa
  11179  83c8		       cb fc		      sbx	#252
  11180  83ca				  -	      ifconst	pfres
  11181  83ca				  -	      cpx	#(pfres-1)*4
  11182  83ca					      else
  11183  83ca		       e0 2c		      cpx	#44
  11184  83cc					      endif
  11185  83cc		       d0 e9		      bne	up2
  11186  83ce
  11187  83ce		       a5 9f		      lda	temp4
  11188  83d0
  11189  83d0				  -	      ifconst	superchip
  11190  83d0				  -	      ifconst	pfres
  11191  83d0				  -	      sta	playfield+pfres*4-129
  11192  83d0				  -	      lda	temp3
  11193  83d0				  -	      sta	playfield+pfres*4-130
  11194  83d0				  -	      lda	temp2
  11195  83d0				  -	      sta	playfield+pfres*4-131
  11196  83d0				  -	      lda	temp1
  11197  83d0				  -	      sta	playfield+pfres*4-132
  11198  83d0				  -	      else
  11199  83d0				  -	      sta	playfield+47-128
  11200  83d0				  -	      lda	temp3
  11201  83d0				  -	      sta	playfield+46-128
  11202  83d0				  -	      lda	temp2
  11203  83d0				  -	      sta	playfield+45-128
  11204  83d0				  -	      lda	temp1
  11205  83d0				  -	      sta	playfield+44-128
  11206  83d0				  -	      endif
  11207  83d0					      else
  11208  83d0				  -	      ifconst	pfres
  11209  83d0				  -	      sta	playfield+pfres*4-1
  11210  83d0				  -	      lda	temp3
  11211  83d0				  -	      sta	playfield+pfres*4-2
  11212  83d0				  -	      lda	temp2
  11213  83d0				  -	      sta	playfield+pfres*4-3
  11214  83d0				  -	      lda	temp1
  11215  83d0				  -	      sta	playfield+pfres*4-4
  11216  83d0					      else
  11217  83d0		       85 d3		      sta	playfield+47
  11218  83d2		       a5 9e		      lda	temp3
  11219  83d4		       85 d2		      sta	playfield+46
  11220  83d6		       a5 9d		      lda	temp2
  11221  83d8		       85 d1		      sta	playfield+45
  11222  83da		       a5 9c		      lda	temp1
  11223  83dc		       85 d0		      sta	playfield+44
  11224  83de					      endif
  11225  83de					      endif
  11226  83de				   noshiftdown2
      0  83de					      RETURN
      1  83de				  -	      ifnconst	bankswitch
      2  83de				  -	      rts
      3  83de					      else
      4  83de		       4c dd ff 	      jmp	BS_return
      5  83e1					      endif
  11228  83e1
  11229  83e1
  11230  83e1				   notup
  11231  83e1							;down
  11232  83e1		       4a		      lsr
  11233  83e2		       b0 02		      bcs	oneincup
  11234  83e4		       e6 ef		      inc	playfieldpos
  11235  83e6				   oneincup
  11236  83e6		       e6 ef		      inc	playfieldpos
  11237  83e8		       a5 ef		      lda	playfieldpos
  11238  83ea
  11239  83ea				  -	      ifconst	pfrowheight
  11240  83ea				  -	      cmp	#pfrowheight+1
  11241  83ea					      else
  11242  83ea					      ifnconst	pfres
  11243  83ea		       c9 09		      cmp	#9
  11244  83ec				  -	      else
  11245  83ec				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
  11246  83ec					      endif
  11247  83ec					      endif
  11248  83ec
  11249  83ec		       90 3b		      bcc	noshiftdown
  11250  83ee		       a9 01		      lda	#1
  11251  83f0		       85 ef		      sta	playfieldpos
  11252  83f2
  11253  83f2				  -	      ifconst	pfres
  11254  83f2				  -	      lda	playfield+pfres*4-1
  11255  83f2				  -	      sta	temp4
  11256  83f2				  -	      lda	playfield+pfres*4-2
  11257  83f2				  -	      sta	temp3
  11258  83f2				  -	      lda	playfield+pfres*4-3
  11259  83f2				  -	      sta	temp2
  11260  83f2				  -	      lda	playfield+pfres*4-4
  11261  83f2					      else
  11262  83f2		       a5 d3		      lda	playfield+47
  11263  83f4		       85 9f		      sta	temp4
  11264  83f6		       a5 d2		      lda	playfield+46
  11265  83f8		       85 9e		      sta	temp3
  11266  83fa		       a5 d1		      lda	playfield+45
  11267  83fc		       85 9d		      sta	temp2
  11268  83fe		       a5 d0		      lda	playfield+44
  11269  8400					      endif
  11270  8400
  11271  8400		       85 9c		      sta	temp1
  11272  8402
  11273  8402				  -	      ifconst	pfres
  11274  8402				  -	      ldx	#(pfres-1)*4
  11275  8402					      else
  11276  8402		       a2 2c		      ldx	#44
  11277  8404					      endif
  11278  8404				   down2
  11279  8404		       b5 a3		      lda	playfield-1,x
  11280  8406				  -	      ifconst	superchip
  11281  8406				  -	      sta	playfield-125,x
  11282  8406				  -	      lda	playfield-2,x
  11283  8406				  -	      sta	playfield-126,x
  11284  8406				  -	      lda	playfield-3,x
  11285  8406				  -	      sta	playfield-127,x
  11286  8406				  -	      lda	playfield-4,x
  11287  8406				  -	      sta	playfield-128,x
  11288  8406					      else
  11289  8406		       95 a7		      sta	playfield+3,x
  11290  8408		       b5 a2		      lda	playfield-2,x
  11291  840a		       95 a6		      sta	playfield+2,x
  11292  840c		       b5 a1		      lda	playfield-3,x
  11293  840e		       95 a5		      sta	playfield+1,x
  11294  8410		       b5 a0		      lda	playfield-4,x
  11295  8412		       95 a4		      sta	playfield,x
  11296  8414					      endif
  11297  8414		       8a		      txa
  11298  8415		       cb 04		      sbx	#4
  11299  8417		       d0 eb		      bne	down2
  11300  8419
  11301  8419		       a5 9f		      lda	temp4
  11302  841b				  -	      ifconst	superchip
  11303  841b				  -	      sta	playfield-125
  11304  841b				  -	      lda	temp3
  11305  841b				  -	      sta	playfield-126
  11306  841b				  -	      lda	temp2
  11307  841b				  -	      sta	playfield-127
  11308  841b				  -	      lda	temp1
  11309  841b				  -	      sta	playfield-128
  11310  841b					      else
  11311  841b		       85 a7		      sta	playfield+3
  11312  841d		       a5 9e		      lda	temp3
  11313  841f		       85 a6		      sta	playfield+2
  11314  8421		       a5 9d		      lda	temp2
  11315  8423		       85 a5		      sta	playfield+1
  11316  8425		       a5 9c		      lda	temp1
  11317  8427		       85 a4		      sta	playfield
  11318  8429					      endif
  11319  8429				   noshiftdown
      0  8429					      RETURN
      1  8429				  -	      ifnconst	bankswitch
      2  8429				  -	      rts
      3  8429					      else
      4  8429		       4c dd ff 	      jmp	BS_return
      5  842c					      endif
  11321  842c							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11322  842c
  11323  842c							;standard routines needed for pretty much all games
  11324  842c							; just the random number generator is left - maybe we should remove this asm file altogether?
  11325  842c							; repositioning code and score pointer setup moved to overscan
  11326  842c							; read switches, joysticks now compiler generated (more efficient)
  11327  842c
  11328  842c				   randomize
  11329  842c		       a5 a2		      lda	rand
  11330  842e		       4a		      lsr
  11331  842f					      ifconst	rand16
  11332  842f		       26 ed		      rol	rand16
  11333  8431					      endif
  11334  8431		       90 02		      bcc	noeor
  11335  8433		       49 b4		      eor	#$B4
  11336  8435				   noeor
  11337  8435		       85 a2		      sta	rand
  11338  8437					      ifconst	rand16
  11339  8437		       45 ed		      eor	rand16
  11340  8439					      endif
      0  8439					      RETURN
      1  8439				  -	      ifnconst	bankswitch
      2  8439				  -	      rts
      3  8439					      else
      4  8439		       4c dd ff 	      jmp	BS_return
      5  843c					      endif
  11342  843c							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11343  843c
  11344  843c				   drawscreen
  11345  843c				  -	      ifconst	debugscore
  11346  843c				  -	      ldx	#14
  11347  843c				  -	      lda	INTIM	; display # cycles left in the score
  11348  843c				  -
  11349  843c				  -	      ifconst	mincycles
  11350  843c				  -	      lda	mincycles
  11351  843c				  -	      cmp	INTIM
  11352  843c				  -	      lda	mincycles
  11353  843c				  -	      bcc	nochange
  11354  843c				  -	      lda	INTIM
  11355  843c				  -	      sta	mincycles
  11356  843c				  -nochange
  11357  843c				  -	      endif
  11358  843c				  -
  11359  843c				  -			; cmp #$2B
  11360  843c				  -			; bcs no_cycles_left
  11361  843c				  -	      bmi	cycles_left
  11362  843c				  -	      ldx	#64
  11363  843c				  -	      eor	#$ff	;make negative
  11364  843c				  -cycles_left
  11365  843c				  -	      stx	scorecolor
  11366  843c				  -	      and	#$7f	; clear sign bit
  11367  843c				  -	      tax
  11368  843c				  -	      lda	scorebcd,x
  11369  843c				  -	      sta	score+2
  11370  843c				  -	      lda	scorebcd1,x
  11371  843c				  -	      sta	score+1
  11372  843c				  -	      jmp	done_debugscore
  11373  843c				  -scorebcd
  11374  843c				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
  11375  843c				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
  11376  843c				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
  11377  843c				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
  11378  843c				  -scorebcd1
  11379  843c				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
  11380  843c				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
  11381  843c				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
  11382  843c				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
  11383  843c				  -done_debugscore
  11384  843c					      endif
  11385  843c
  11386  843c				  -	      ifconst	debugcycles
  11387  843c				  -	      lda	INTIM	; if we go over, it mucks up the background color
  11388  843c				  -			; cmp #$2B
  11389  843c				  -			; BCC overscan
  11390  843c				  -	      bmi	overscan
  11391  843c				  -	      sta	COLUBK
  11392  843c				  -	      bcs	doneoverscan
  11393  843c					      endif
  11394  843c
  11395  843c				   overscan
  11396  843c				  -	      ifconst	interlaced
  11397  843c				  -	      PHP
  11398  843c				  -	      PLA
  11399  843c				  -	      EOR	#4	; flip interrupt bit
  11400  843c				  -	      PHA
  11401  843c				  -	      PLP
  11402  843c				  -	      AND	#4	; isolate the interrupt bit
  11403  843c				  -	      TAX		; save it for later
  11404  843c					      endif
  11405  843c
  11406  843c				   overscanloop
  11407  843c		       ad 84 02 	      lda	INTIM	;wait for sync
  11408  843f		       30 fb		      bmi	overscanloop
  11409  8441				   doneoverscan
  11410  8441
  11411  8441							;do VSYNC
  11412  8441
  11413  8441				  -	      ifconst	interlaced
  11414  8441				  -	      CPX	#4
  11415  8441				  -	      BNE	oddframevsync
  11416  8441					      endif
  11417  8441
  11418  8441		       a9 02		      lda	#2
  11419  8443		       85 02		      sta	WSYNC
  11420  8445		       85 00		      sta	VSYNC
  11421  8447		       85 02		      STA	WSYNC
  11422  8449		       85 02		      STA	WSYNC
  11423  844b		       4a		      lsr
  11424  844c		       85 02		      STA	WSYNC
  11425  844e		       85 00		      STA	VSYNC
  11426  8450		       85 01		      sta	VBLANK
  11427  8452					      ifnconst	overscan_time
  11428  8452		       a9 a5		      lda	#37+128
  11429  8454				  -	      else
  11430  8454				  -	      lda	#overscan_time+128
  11431  8454					      endif
  11432  8454		       8d 96 02 	      sta	TIM64T
  11433  8457
  11434  8457				  -	      ifconst	interlaced
  11435  8457				  -	      jmp	postsync
  11436  8457				  -
  11437  8457				  -oddframevsync
  11438  8457				  -	      sta	WSYNC
  11439  8457				  -
  11440  8457				  -	      LDA	($80,X)	; 11 waste
  11441  8457				  -	      LDA	($80,X)	; 11 waste
  11442  8457				  -	      LDA	($80,X)	; 11 waste
  11443  8457				  -
  11444  8457				  -	      lda	#2
  11445  8457				  -	      sta	VSYNC
  11446  8457				  -	      sta	WSYNC
  11447  8457				  -	      sta	WSYNC
  11448  8457				  -	      sta	WSYNC
  11449  8457				  -
  11450  8457				  -	      LDA	($80,X)	; 11 waste
  11451  8457				  -	      LDA	($80,X)	; 11 waste
  11452  8457				  -	      LDA	($80,X)	; 11 waste
  11453  8457				  -
  11454  8457				  -	      lda	#0
  11455  8457				  -	      sta	VSYNC
  11456  8457				  -	      sta	VBLANK
  11457  8457				  -	      ifnconst	overscan_time
  11458  8457				  -	      lda	#37+128
  11459  8457				  -	      else
  11460  8457				  -	      lda	#overscan_time+128
  11461  8457				  -	      endif
  11462  8457				  -	      sta	TIM64T
  11463  8457				  -
  11464  8457				  -postsync
  11465  8457					      endif
  11466  8457
  11467  8457				  -	      ifconst	legacy
  11468  8457				  -	      if	legacy < 100
  11469  8457				  -	      ldx	#4
  11470  8457				  -adjustloop
  11471  8457				  -	      lda	player0x,x
  11472  8457				  -	      sec
  11473  8457				  -	      sbc	#14	;?
  11474  8457				  -	      sta	player0x,x
  11475  8457				  -	      dex
  11476  8457				  -	      bpl	adjustloop
  11477  8457				  -	      endif
  11478  8457					      endif
  11479  8457				  -	      if	((<*)>$e9)&&((<*)<$fa)
  11480  8457				  -	      repeat	($fa-(<*))
  11481  8457				  -	      nop
  11482  8457				  -	      repend
  11483  8457					      endif
  11484  8457		       85 02		      sta	WSYNC
  11485  8459		       a2 04		      ldx	#4
      0  845b					      SLEEP	3
      1  845b				   .CYCLES    SET	3
      2  845b
      3  845b				  -	      IF	.CYCLES < 2
      4  845b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  845b				  -	      ERR
      6  845b					      ENDIF
      7  845b
      8  845b					      IF	.CYCLES & 1
      9  845b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  845b		       04 00		      nop	0
     11  845d				  -	      ELSE
     12  845d				  -	      bit	VSYNC
     13  845d					      ENDIF
     14  845d				   .CYCLES    SET	.CYCLES - 3
     15  845d					      ENDIF
     16  845d
     17  845d				  -	      REPEAT	.CYCLES / 2
     18  845d				  -	      nop
     19  845d					      REPEND
  11487  845d				   HorPosLoop		; 5
  11488  845d		       b5 80		      lda	player0x,X	;+4 9
  11489  845f		       38		      sec		;+2 11
  11490  8460				   DivideLoop
  11491  8460		       e9 0f		      sbc	#15
  11492  8462		       b0 fc		      bcs	DivideLoop	;+4 15
  11493  8464		       95 9c		      sta	temp1,X	;+4 19
  11494  8466		       95 10		      sta	RESP0,X	;+4 23
  11495  8468		       85 02		      sta	WSYNC
  11496  846a		       ca		      dex
  11497  846b		       10 f0		      bpl	HorPosLoop	;+5 5
  11498  846d							; 4
  11499  846d
  11500  846d		       a2 04		      ldx	#4
  11501  846f		       b4 9c		      ldy	temp1,X
  11502  8471		       b9 cd f3 	      lda	repostable-256,Y
  11503  8474		       95 20		      sta	HMP0,X	;+14 18
  11504  8476
  11505  8476		       ca		      dex
  11506  8477		       b4 9c		      ldy	temp1,X
  11507  8479		       b9 cd f3 	      lda	repostable-256,Y
  11508  847c		       95 20		      sta	HMP0,X	;+14 32
  11509  847e
  11510  847e		       ca		      dex
  11511  847f		       b4 9c		      ldy	temp1,X
  11512  8481		       b9 cd f3 	      lda	repostable-256,Y
  11513  8484		       95 20		      sta	HMP0,X	;+14 46
  11514  8486
  11515  8486		       ca		      dex
  11516  8487		       b4 9c		      ldy	temp1,X
  11517  8489		       b9 cd f3 	      lda	repostable-256,Y
  11518  848c		       95 20		      sta	HMP0,X	;+14 60
  11519  848e
  11520  848e		       ca		      dex
  11521  848f		       b4 9c		      ldy	temp1,X
  11522  8491		       b9 cd f3 	      lda	repostable-256,Y
  11523  8494		       95 20		      sta	HMP0,X	;+14 74
  11524  8496
  11525  8496		       85 02		      sta	WSYNC
  11526  8498
  11527  8498		       85 2a		      sta	HMOVE	;+3 3
  11528  849a
  11529  849a
  11530  849a				  -	      ifconst	legacy
  11531  849a				  -	      if	legacy < 100
  11532  849a				  -	      ldx	#4
  11533  849a				  -adjustloop2
  11534  849a				  -	      lda	player0x,x
  11535  849a				  -	      clc
  11536  849a				  -	      adc	#14	;?
  11537  849a				  -	      sta	player0x,x
  11538  849a				  -	      dex
  11539  849a				  -	      bpl	adjustloop2
  11540  849a				  -	      endif
  11541  849a					      endif
  11542  849a
  11543  849a
  11544  849a
  11545  849a
  11546  849a							;set score pointers
  11547  849a		       a7 95		      lax	score+2
  11548  849c		       20 cd f4 	      jsr	scorepointerset
  11549  849f		       84 9b		      sty	scorepointers+5
  11550  84a1		       86 98		      stx	scorepointers+2
  11551  84a3		       a7 94		      lax	score+1
  11552  84a5		       20 cd f4 	      jsr	scorepointerset
  11553  84a8		       84 9a		      sty	scorepointers+4
  11554  84aa		       86 97		      stx	scorepointers+1
  11555  84ac		       a7 93		      lax	score
  11556  84ae		       20 cd f4 	      jsr	scorepointerset
  11557  84b1		       84 99		      sty	scorepointers+3
  11558  84b3		       86 96		      stx	scorepointers
  11559  84b5
  11560  84b5				   vblk
  11561  84b5							; run possible vblank bB code
  11562  84b5				  -	      ifconst	vblank_bB_code
  11563  84b5				  -	      jsr	vblank_bB_code
  11564  84b5					      endif
  11565  84b5				   vblk2
  11566  84b5		       ad 84 02 	      LDA	INTIM
  11567  84b8		       30 fb		      bmi	vblk2
  11568  84ba		       4c 00 f0 	      jmp	kernel
  11569  84bd
  11570  84bd
  11571  84bd		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
  11572  84c6		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
  11573  84cd				   repostable
  11574  84cd
  11575  84cd				   scorepointerset
  11576  84cd		       29 0f		      and	#$0F
  11577  84cf		       0a		      asl
  11578  84d0		       0a		      asl
  11579  84d1		       0a		      asl
  11580  84d2		       69 74		      adc	#<scoretable
  11581  84d4		       a8		      tay
  11582  84d5		       8a		      txa
  11583  84d6							; and #$F0
  11584  84d6							; lsr
  11585  84d6		       4b f0		      asr	#$F0
  11586  84d8		       69 74		      adc	#<scoretable
  11587  84da		       aa		      tax
  11588  84db		       60		      rts
  11589  84dc							;bB.asm
  11590  84dc							; bB.asm file is split here
  11591  84dc				   .
  11592  84dc							;
  11593  84dc
  11594  84dc				   .
  11595  84dc							;
  11596  84dc
  11597  84dc				   .
  11598  84dc							;
  11599  84dc
  11600  84dc				   .
  11601  84dc							;
  11602  84dc
  11603  84dc				   .
  11604  84dc							;
  11605  84dc
  11606  84dc				   .
  11607  84dc							;
  11608  84dc
  11609  84dc				   .
  11610  84dc							;
  11611  84dc
  11612  84dc				   .
  11613  84dc							;
  11614  84dc
  11615  84dc				   .
  11616  84dc							;
  11617  84dc
  11618  84dc				   .
  11619  84dc							;
  11620  84dc
  11621  84dc				   .
  11622  84dc							;
  11623  84dc
  11624  84dc				   .
  11625  84dc							;
  11626  84dc
  11627  84dc				  -	      ifconst	pfres
  11628  84dc				  -	      if	(<*) > (254-pfres*pfwidth)
  11629  84dc				  -	      align	256
  11630  84dc				  -	      endif
  11631  84dc				  -	      if	(<*) < (136-pfres*pfwidth)
  11632  84dc				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11633  84dc				  -	      .byte	0
  11634  84dc				  -	      repend
  11635  84dc				  -	      endif
  11636  84dc					      else
  11637  84dc					      if	(<*) > 206
  11638  8500		       00 00 00 00*	      align	256
  11639  8500					      endif
  11640  8500					      if	(<*) < 88
  11641  8500					      repeat	(88-(<*))
  11642  8500		       00		      .byte.b	0
  11641  8500					      repend
  11642  8501		       00		      .byte.b	0
  11641  8501					      repend
  11642  8502		       00		      .byte.b	0
  11641  8502					      repend
  11642  8503		       00		      .byte.b	0
  11641  8503					      repend
  11642  8504		       00		      .byte.b	0
  11641  8504					      repend
  11642  8505		       00		      .byte.b	0
  11641  8505					      repend
  11642  8506		       00		      .byte.b	0
  11641  8506					      repend
  11642  8507		       00		      .byte.b	0
  11641  8507					      repend
  11642  8508		       00		      .byte.b	0
  11641  8508					      repend
  11642  8509		       00		      .byte.b	0
  11641  8509					      repend
  11642  850a		       00		      .byte.b	0
  11641  850a					      repend
  11642  850b		       00		      .byte.b	0
  11641  850b					      repend
  11642  850c		       00		      .byte.b	0
  11641  850c					      repend
  11642  850d		       00		      .byte.b	0
  11641  850d					      repend
  11642  850e		       00		      .byte.b	0
  11641  850e					      repend
  11642  850f		       00		      .byte.b	0
  11641  850f					      repend
  11642  8510		       00		      .byte.b	0
  11641  8510					      repend
  11642  8511		       00		      .byte.b	0
  11641  8511					      repend
  11642  8512		       00		      .byte.b	0
  11641  8512					      repend
  11642  8513		       00		      .byte.b	0
  11641  8513					      repend
  11642  8514		       00		      .byte.b	0
  11641  8514					      repend
  11642  8515		       00		      .byte.b	0
  11641  8515					      repend
  11642  8516		       00		      .byte.b	0
  11641  8516					      repend
  11642  8517		       00		      .byte.b	0
  11641  8517					      repend
  11642  8518		       00		      .byte.b	0
  11641  8518					      repend
  11642  8519		       00		      .byte.b	0
  11641  8519					      repend
  11642  851a		       00		      .byte.b	0
  11641  851a					      repend
  11642  851b		       00		      .byte.b	0
  11641  851b					      repend
  11642  851c		       00		      .byte.b	0
  11641  851c					      repend
  11642  851d		       00		      .byte.b	0
  11641  851d					      repend
  11642  851e		       00		      .byte.b	0
  11641  851e					      repend
  11642  851f		       00		      .byte.b	0
  11641  851f					      repend
  11642  8520		       00		      .byte.b	0
  11641  8520					      repend
  11642  8521		       00		      .byte.b	0
  11641  8521					      repend
  11642  8522		       00		      .byte.b	0
  11641  8522					      repend
  11642  8523		       00		      .byte.b	0
  11641  8523					      repend
  11642  8524		       00		      .byte.b	0
  11641  8524					      repend
  11642  8525		       00		      .byte.b	0
  11641  8525					      repend
  11642  8526		       00		      .byte.b	0
  11641  8526					      repend
  11642  8527		       00		      .byte.b	0
  11641  8527					      repend
  11642  8528		       00		      .byte.b	0
  11641  8528					      repend
  11642  8529		       00		      .byte.b	0
  11641  8529					      repend
  11642  852a		       00		      .byte.b	0
  11641  852a					      repend
  11642  852b		       00		      .byte.b	0
  11641  852b					      repend
  11642  852c		       00		      .byte.b	0
  11641  852c					      repend
  11642  852d		       00		      .byte.b	0
  11641  852d					      repend
  11642  852e		       00		      .byte.b	0
  11641  852e					      repend
  11642  852f		       00		      .byte.b	0
  11641  852f					      repend
  11642  8530		       00		      .byte.b	0
  11641  8530					      repend
  11642  8531		       00		      .byte.b	0
  11641  8531					      repend
  11642  8532		       00		      .byte.b	0
  11641  8532					      repend
  11642  8533		       00		      .byte.b	0
  11641  8533					      repend
  11642  8534		       00		      .byte.b	0
  11641  8534					      repend
  11642  8535		       00		      .byte.b	0
  11641  8535					      repend
  11642  8536		       00		      .byte.b	0
  11641  8536					      repend
  11642  8537		       00		      .byte.b	0
  11641  8537					      repend
  11642  8538		       00		      .byte.b	0
  11641  8538					      repend
  11642  8539		       00		      .byte.b	0
  11641  8539					      repend
  11642  853a		       00		      .byte.b	0
  11641  853a					      repend
  11642  853b		       00		      .byte.b	0
  11641  853b					      repend
  11642  853c		       00		      .byte.b	0
  11641  853c					      repend
  11642  853d		       00		      .byte.b	0
  11641  853d					      repend
  11642  853e		       00		      .byte.b	0
  11641  853e					      repend
  11642  853f		       00		      .byte.b	0
  11641  853f					      repend
  11642  8540		       00		      .byte.b	0
  11641  8540					      repend
  11642  8541		       00		      .byte.b	0
  11641  8541					      repend
  11642  8542		       00		      .byte.b	0
  11641  8542					      repend
  11642  8543		       00		      .byte.b	0
  11641  8543					      repend
  11642  8544		       00		      .byte.b	0
  11641  8544					      repend
  11642  8545		       00		      .byte.b	0
  11641  8545					      repend
  11642  8546		       00		      .byte.b	0
  11641  8546					      repend
  11642  8547		       00		      .byte.b	0
  11641  8547					      repend
  11642  8548		       00		      .byte.b	0
  11641  8548					      repend
  11642  8549		       00		      .byte.b	0
  11641  8549					      repend
  11642  854a		       00		      .byte.b	0
  11641  854a					      repend
  11642  854b		       00		      .byte.b	0
  11641  854b					      repend
  11642  854c		       00		      .byte.b	0
  11641  854c					      repend
  11642  854d		       00		      .byte.b	0
  11641  854d					      repend
  11642  854e		       00		      .byte.b	0
  11641  854e					      repend
  11642  854f		       00		      .byte.b	0
  11641  854f					      repend
  11642  8550		       00		      .byte.b	0
  11641  8550					      repend
  11642  8551		       00		      .byte.b	0
  11641  8551					      repend
  11642  8552		       00		      .byte.b	0
  11641  8552					      repend
  11642  8553		       00		      .byte.b	0
  11641  8553					      repend
  11642  8554		       00		      .byte.b	0
  11641  8554					      repend
  11642  8555		       00		      .byte.b	0
  11641  8555					      repend
  11642  8556		       00		      .byte.b	0
  11641  8556					      repend
  11642  8557		       00		      .byte.b	0
  11643  8558					      repend
  11644  8558					      endif
  11645  8558					      endif
  11646  8558				   pfcolorlabel13
  11647  8558		       1e 36 2e de	      .byte.b	$1E, $36, $2E, $DE
  11648  855c		       1e 46 2c dc	      .byte.b	$1E, $46, $2C, $DC
  11649  8560		       1c 56 2a da	      .byte.b	$1C, $56, $2A, $DA
  11650  8564		       1c 66 28 d8	      .byte.b	$1C, $66, $28, $D8
  11651  8568		       1a 76 26 d6	      .byte.b	$1A, $76, $26, $D6
  11652  856c		       1a 86 2e de	      .byte.b	$1A, $86, $2E, $DE
  11653  8570		       18 96 2e de	      .byte.b	$18, $96, $2E, $DE
  11654  8574		       18 a6 2c dc	      .byte.b	$18, $A6, $2C, $DC
  11655  8578		       16 b6 2a da	      .byte.b	$16, $B6, $2A, $DA
  11656  857c		       16 c6 28 d8	      .byte.b	$16, $C6, $28, $D8
  11657  8580		       14 00 26 d6	      .byte.b	$14,0, $26, $D6
  11658  8584				  -	      if	(<*) > (<(*+3))
  11659  8584				  -	      repeat	($100-<*)
  11660  8584				  -	      .byte	0
  11661  8584				  -	      repend
  11662  8584					      endif
  11663  8584				   playerL098_0
  11664  8584		       bd		      .byte.b	%10111101
  11665  8585		       ff		      .byte.b	%11111111
  11666  8586		       fb		      .byte.b	%11111011
  11667  8587		       7e		      .byte.b	%01111110
  11668  8588				  -	      if	(<*) > (<(*+4))
  11669  8588				  -	      repeat	($100-<*)
  11670  8588				  -	      .byte	0
  11671  8588				  -	      repend
  11672  8588					      endif
  11673  8588				   playerL099_1
  11674  8588		       0a		      .byte.b	%01010
  11675  8589		       0a		      .byte.b	%01010
  11676  858a		       15		      .byte.b	%10101
  11677  858b		       0e		      .byte.b	%01110
  11678  858c		       04		      .byte.b	%00100
  11679  858d				  -	      ifconst	pfres
  11680  858d				  -	      if	(<*) > (254-pfres*pfwidth)
  11681  858d				  -	      align	256
  11682  858d				  -	      endif
  11683  858d				  -	      if	(<*) < (136-pfres*pfwidth)
  11684  858d				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11685  858d				  -	      .byte	0
  11686  858d				  -	      repend
  11687  858d				  -	      endif
  11688  858d					      else
  11689  858d				  -	      if	(<*) > 206
  11690  858d				  -	      align	256
  11691  858d					      endif
  11692  858d				  -	      if	(<*) < 88
  11693  858d				  -	      repeat	(88-(<*))
  11694  858d				  -	      .byte	0
  11695  858d				  -	      repend
  11696  858d					      endif
  11697  858d					      endif
  11698  858d				   pfcolorlabel55
  11699  858d		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11700  8591		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11701  8595		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11702  8599		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11703  859d		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11704  85a1		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11705  85a5		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11706  85a9		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11707  85ad		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11708  85b1		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11709  85b5		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11710  85b9				  -	      ifconst	pfres
  11711  85b9				  -	      if	(<*) > (254-pfres*pfwidth)
  11712  85b9				  -	      align	256
  11713  85b9				  -	      endif
  11714  85b9				  -	      if	(<*) < (136-pfres*pfwidth)
  11715  85b9				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11716  85b9				  -	      .byte	0
  11717  85b9				  -	      repend
  11718  85b9				  -	      endif
  11719  85b9					      else
  11720  85b9				  -	      if	(<*) > 206
  11721  85b9				  -	      align	256
  11722  85b9					      endif
  11723  85b9				  -	      if	(<*) < 88
  11724  85b9				  -	      repeat	(88-(<*))
  11725  85b9				  -	      .byte	0
  11726  85b9				  -	      repend
  11727  85b9					      endif
  11728  85b9					      endif
  11729  85b9				   pfcolorlabel80
  11730  85b9		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11731  85bd		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11732  85c1		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11733  85c5		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11734  85c9		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11735  85cd		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11736  85d1		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11737  85d5		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11738  85d9		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11739  85dd		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11740  85e1		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11741  85e5				  -	      ifconst	pfres
  11742  85e5				  -	      if	(<*) > (254-pfres*pfwidth)
  11743  85e5				  -	      align	256
  11744  85e5				  -	      endif
  11745  85e5				  -	      if	(<*) < (136-pfres*pfwidth)
  11746  85e5				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11747  85e5				  -	      .byte	0
  11748  85e5				  -	      repend
  11749  85e5				  -	      endif
  11750  85e5					      else
  11751  85e5					      if	(<*) > 206
  11752  8600		       00 00 00 00*	      align	256
  11753  8600					      endif
  11754  8600					      if	(<*) < 88
  11755  8600					      repeat	(88-(<*))
  11756  8600		       00		      .byte.b	0
  11755  8600					      repend
  11756  8601		       00		      .byte.b	0
  11755  8601					      repend
  11756  8602		       00		      .byte.b	0
  11755  8602					      repend
  11756  8603		       00		      .byte.b	0
  11755  8603					      repend
  11756  8604		       00		      .byte.b	0
  11755  8604					      repend
  11756  8605		       00		      .byte.b	0
  11755  8605					      repend
  11756  8606		       00		      .byte.b	0
  11755  8606					      repend
  11756  8607		       00		      .byte.b	0
  11755  8607					      repend
  11756  8608		       00		      .byte.b	0
  11755  8608					      repend
  11756  8609		       00		      .byte.b	0
  11755  8609					      repend
  11756  860a		       00		      .byte.b	0
  11755  860a					      repend
  11756  860b		       00		      .byte.b	0
  11755  860b					      repend
  11756  860c		       00		      .byte.b	0
  11755  860c					      repend
  11756  860d		       00		      .byte.b	0
  11755  860d					      repend
  11756  860e		       00		      .byte.b	0
  11755  860e					      repend
  11756  860f		       00		      .byte.b	0
  11755  860f					      repend
  11756  8610		       00		      .byte.b	0
  11755  8610					      repend
  11756  8611		       00		      .byte.b	0
  11755  8611					      repend
  11756  8612		       00		      .byte.b	0
  11755  8612					      repend
  11756  8613		       00		      .byte.b	0
  11755  8613					      repend
  11756  8614		       00		      .byte.b	0
  11755  8614					      repend
  11756  8615		       00		      .byte.b	0
  11755  8615					      repend
  11756  8616		       00		      .byte.b	0
  11755  8616					      repend
  11756  8617		       00		      .byte.b	0
  11755  8617					      repend
  11756  8618		       00		      .byte.b	0
  11755  8618					      repend
  11756  8619		       00		      .byte.b	0
  11755  8619					      repend
  11756  861a		       00		      .byte.b	0
  11755  861a					      repend
  11756  861b		       00		      .byte.b	0
  11755  861b					      repend
  11756  861c		       00		      .byte.b	0
  11755  861c					      repend
  11756  861d		       00		      .byte.b	0
  11755  861d					      repend
  11756  861e		       00		      .byte.b	0
  11755  861e					      repend
  11756  861f		       00		      .byte.b	0
  11755  861f					      repend
  11756  8620		       00		      .byte.b	0
  11755  8620					      repend
  11756  8621		       00		      .byte.b	0
  11755  8621					      repend
  11756  8622		       00		      .byte.b	0
  11755  8622					      repend
  11756  8623		       00		      .byte.b	0
  11755  8623					      repend
  11756  8624		       00		      .byte.b	0
  11755  8624					      repend
  11756  8625		       00		      .byte.b	0
  11755  8625					      repend
  11756  8626		       00		      .byte.b	0
  11755  8626					      repend
  11756  8627		       00		      .byte.b	0
  11755  8627					      repend
  11756  8628		       00		      .byte.b	0
  11755  8628					      repend
  11756  8629		       00		      .byte.b	0
  11755  8629					      repend
  11756  862a		       00		      .byte.b	0
  11755  862a					      repend
  11756  862b		       00		      .byte.b	0
  11755  862b					      repend
  11756  862c		       00		      .byte.b	0
  11755  862c					      repend
  11756  862d		       00		      .byte.b	0
  11755  862d					      repend
  11756  862e		       00		      .byte.b	0
  11755  862e					      repend
  11756  862f		       00		      .byte.b	0
  11755  862f					      repend
  11756  8630		       00		      .byte.b	0
  11755  8630					      repend
  11756  8631		       00		      .byte.b	0
  11755  8631					      repend
  11756  8632		       00		      .byte.b	0
  11755  8632					      repend
  11756  8633		       00		      .byte.b	0
  11755  8633					      repend
  11756  8634		       00		      .byte.b	0
  11755  8634					      repend
  11756  8635		       00		      .byte.b	0
  11755  8635					      repend
  11756  8636		       00		      .byte.b	0
  11755  8636					      repend
  11756  8637		       00		      .byte.b	0
  11755  8637					      repend
  11756  8638		       00		      .byte.b	0
  11755  8638					      repend
  11756  8639		       00		      .byte.b	0
  11755  8639					      repend
  11756  863a		       00		      .byte.b	0
  11755  863a					      repend
  11756  863b		       00		      .byte.b	0
  11755  863b					      repend
  11756  863c		       00		      .byte.b	0
  11755  863c					      repend
  11756  863d		       00		      .byte.b	0
  11755  863d					      repend
  11756  863e		       00		      .byte.b	0
  11755  863e					      repend
  11756  863f		       00		      .byte.b	0
  11755  863f					      repend
  11756  8640		       00		      .byte.b	0
  11755  8640					      repend
  11756  8641		       00		      .byte.b	0
  11755  8641					      repend
  11756  8642		       00		      .byte.b	0
  11755  8642					      repend
  11756  8643		       00		      .byte.b	0
  11755  8643					      repend
  11756  8644		       00		      .byte.b	0
  11755  8644					      repend
  11756  8645		       00		      .byte.b	0
  11755  8645					      repend
  11756  8646		       00		      .byte.b	0
  11755  8646					      repend
  11756  8647		       00		      .byte.b	0
  11755  8647					      repend
  11756  8648		       00		      .byte.b	0
  11755  8648					      repend
  11756  8649		       00		      .byte.b	0
  11755  8649					      repend
  11756  864a		       00		      .byte.b	0
  11755  864a					      repend
  11756  864b		       00		      .byte.b	0
  11755  864b					      repend
  11756  864c		       00		      .byte.b	0
  11755  864c					      repend
  11756  864d		       00		      .byte.b	0
  11755  864d					      repend
  11756  864e		       00		      .byte.b	0
  11755  864e					      repend
  11756  864f		       00		      .byte.b	0
  11755  864f					      repend
  11756  8650		       00		      .byte.b	0
  11755  8650					      repend
  11756  8651		       00		      .byte.b	0
  11755  8651					      repend
  11756  8652		       00		      .byte.b	0
  11755  8652					      repend
  11756  8653		       00		      .byte.b	0
  11755  8653					      repend
  11756  8654		       00		      .byte.b	0
  11755  8654					      repend
  11756  8655		       00		      .byte.b	0
  11755  8655					      repend
  11756  8656		       00		      .byte.b	0
  11755  8656					      repend
  11756  8657		       00		      .byte.b	0
  11757  8658					      repend
  11758  8658					      endif
  11759  8658					      endif
  11760  8658				   pfcolorlabel105
  11761  8658		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11762  865c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11763  8660		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11764  8664		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11765  8668		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11766  866c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11767  8670		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11768  8674		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11769  8678		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11770  867c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11771  8680		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11772  8684				  -	      ifconst	pfres
  11773  8684				  -	      if	(<*) > (254-pfres*pfwidth)
  11774  8684				  -	      align	256
  11775  8684				  -	      endif
  11776  8684				  -	      if	(<*) < (136-pfres*pfwidth)
  11777  8684				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11778  8684				  -	      .byte	0
  11779  8684				  -	      repend
  11780  8684				  -	      endif
  11781  8684					      else
  11782  8684				  -	      if	(<*) > 206
  11783  8684				  -	      align	256
  11784  8684					      endif
  11785  8684				  -	      if	(<*) < 88
  11786  8684				  -	      repeat	(88-(<*))
  11787  8684				  -	      .byte	0
  11788  8684				  -	      repend
  11789  8684					      endif
  11790  8684					      endif
  11791  8684				   pfcolorlabel130
  11792  8684		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11793  8688		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11794  868c		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11795  8690		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11796  8694		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11797  8698		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11798  869c		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11799  86a0		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11800  86a4		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11801  86a8		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11802  86ac		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11803  86b0					      if	ECHOFIRST
      2244 bytes of ROM space left in bank 8
  11804  86b0					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 8")
  11805  86b0					      endif
  11806  86b0		       00 01	   ECHOFIRST  =	1
  11807  86b0
  11808  86b0
  11809  86b0							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11810  86b0
  11811  86b0							; feel free to modify the score graphics - just keep each digit 8 high
  11812  86b0							; and keep the conditional compilation stuff intact
  11813  86b0				  -	      ifconst	ROM2k
  11814  86b0				  -	      ORG	$F7AC-8
  11815  86b0					      else
  11816  86b0					      ifconst	bankswitch
  11817  86b0				  -	      if	bankswitch == 8
  11818  86b0				  -	      ORG	$2F94-bscode_length
  11819  86b0				  -	      RORG	$FF94-bscode_length
  11820  86b0					      endif
  11821  86b0				  -	      if	bankswitch == 16
  11822  86b0				  -	      ORG	$4F94-bscode_length
  11823  86b0				  -	      RORG	$FF94-bscode_length
  11824  86b0					      endif
  11825  86b0					      if	bankswitch == 32
  11826  8f74					      ORG	$8F94-bscode_length
  11827  8f74					      RORG	$FF94-bscode_length
  11828  8f74					      endif
  11829  8f74				  -	      if	bankswitch == 64
  11830  8f74				  -	      ORG	$10F80-bscode_length
  11831  8f74				  -	      RORG	$1FF80-bscode_length
  11832  8f74					      endif
  11833  8f74				  -	      else
  11834  8f74				  -	      ORG	$FF9C
  11835  8f74					      endif
  11836  8f74					      endif
  11837  8f74
  11838  8f74							; font equates
  11839  8f74		       00 01	   .21stcentury =	1
  11840  8f74		       00 02	   alarmclock =	2
  11841  8f74		       00 03	   handwritten =	3
  11842  8f74		       00 04	   interrupted =	4
  11843  8f74		       00 05	   retroputer =	5
  11844  8f74		       00 06	   whimsey    =	6
  11845  8f74		       00 07	   tiny       =	7
  11846  8f74		       00 08	   hex	      =	8
  11847  8f74
  11848  8f74					      ifconst	font
  11849  8f74				  -	      if	font == hex
  11850  8f74				  -	      ORG	. - 48
  11851  8f74					      endif
  11852  8f74					      endif
  11853  8f74
  11854  8f74				   scoretable
  11855  8f74
  11856  8f74					      ifconst	font
  11857  8f74				  -	      if	font == .21stcentury
  11858  8f74				  -	      include	"score_graphics.asm.21stcentury"
  11859  8f74					      endif
  11860  8f74				  -	      if	font == alarmclock
  11861  8f74				  -	      include	"score_graphics.asm.alarmclock"
  11862  8f74					      endif
  11863  8f74				  -	      if	font == handwritten
  11864  8f74				  -	      include	"score_graphics.asm.handwritten"
  11865  8f74					      endif
  11866  8f74				  -	      if	font == interrupted
  11867  8f74				  -	      include	"score_graphics.asm.interrupted"
  11868  8f74					      endif
  11869  8f74					      if	font == retroputer
------- FILE score_graphics.asm.retroputer LEVEL 2 PASS 2
      0  8f74					      include	"score_graphics.asm.retroputer"
      1  8f74							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8f74
      3  8f74		       7e		      .byte.b	%01111110
      4  8f75		       46		      .byte.b	%01000110
      5  8f76		       46		      .byte.b	%01000110
      6  8f77		       46		      .byte.b	%01000110
      7  8f78		       62		      .byte.b	%01100010
      8  8f79		       62		      .byte.b	%01100010
      9  8f7a		       62		      .byte.b	%01100010
     10  8f7b		       7e		      .byte.b	%01111110
     11  8f7c
     12  8f7c		       38		      .byte.b	%00111000
     13  8f7d		       38		      .byte.b	%00111000
     14  8f7e		       38		      .byte.b	%00111000
     15  8f7f		       38		      .byte.b	%00111000
     16  8f80		       18		      .byte.b	%00011000
     17  8f81		       18		      .byte.b	%00011000
     18  8f82		       18		      .byte.b	%00011000
     19  8f83		       18		      .byte.b	%00011000
     20  8f84
     21  8f84		       7e		      .byte.b	%01111110
     22  8f85		       60		      .byte.b	%01100000
     23  8f86		       60		      .byte.b	%01100000
     24  8f87		       60		      .byte.b	%01100000
     25  8f88		       3e		      .byte.b	%00111110
     26  8f89		       02		      .byte.b	%00000010
     27  8f8a		       42		      .byte.b	%01000010
     28  8f8b		       7e		      .byte.b	%01111110
     29  8f8c
     30  8f8c		       7e		      .byte.b	%01111110
     31  8f8d		       46		      .byte.b	%01000110
     32  8f8e		       06		      .byte.b	%00000110
     33  8f8f		       06		      .byte.b	%00000110
     34  8f90		       3e		      .byte.b	%00111110
     35  8f91		       02		      .byte.b	%00000010
     36  8f92		       42		      .byte.b	%01000010
     37  8f93		       7e		      .byte.b	%01111110
     38  8f94
     39  8f94		       0c		      .byte.b	%00001100
     40  8f95		       0c		      .byte.b	%00001100
     41  8f96		       0c		      .byte.b	%00001100
     42  8f97		       7e		      .byte.b	%01111110
     43  8f98		       44		      .byte.b	%01000100
     44  8f99		       44		      .byte.b	%01000100
     45  8f9a		       44		      .byte.b	%01000100
     46  8f9b		       04		      .byte.b	%00000100
     47  8f9c
     48  8f9c		       7e		      .byte.b	%01111110
     49  8f9d		       46		      .byte.b	%01000110
     50  8f9e		       06		      .byte.b	%00000110
     51  8f9f		       06		      .byte.b	%00000110
     52  8fa0		       7c		      .byte.b	%01111100
     53  8fa1		       40		      .byte.b	%01000000
     54  8fa2		       40		      .byte.b	%01000000
     55  8fa3		       7e		      .byte.b	%01111110
     56  8fa4
     57  8fa4		       7e		      .byte.b	%01111110
     58  8fa5		       46		      .byte.b	%01000110
     59  8fa6		       46		      .byte.b	%01000110
     60  8fa7		       46		      .byte.b	%01000110
     61  8fa8		       7c		      .byte.b	%01111100
     62  8fa9		       40		      .byte.b	%01000000
     63  8faa		       42		      .byte.b	%01000010
     64  8fab		       7e		      .byte.b	%01111110
     65  8fac
     66  8fac		       0c		      .byte.b	%00001100
     67  8fad		       0c		      .byte.b	%00001100
     68  8fae		       0c		      .byte.b	%00001100
     69  8faf		       0c		      .byte.b	%00001100
     70  8fb0		       04		      .byte.b	%00000100
     71  8fb1		       02		      .byte.b	%00000010
     72  8fb2		       42		      .byte.b	%01000010
     73  8fb3		       7e		      .byte.b	%01111110
     74  8fb4
     75  8fb4		       7e		      .byte.b	%01111110
     76  8fb5		       46		      .byte.b	%01000110
     77  8fb6		       46		      .byte.b	%01000110
     78  8fb7		       46		      .byte.b	%01000110
     79  8fb8		       7e		      .byte.b	%01111110
     80  8fb9		       42		      .byte.b	%01000010
     81  8fba		       42		      .byte.b	%01000010
     82  8fbb		       7e		      .byte.b	%01111110
     83  8fbc
     84  8fbc		       06		      .byte.b	%00000110
     85  8fbd		       06		      .byte.b	%00000110
     86  8fbe		       06		      .byte.b	%00000110
     87  8fbf		       02		      .byte.b	%00000010
     88  8fc0		       7e		      .byte.b	%01111110
     89  8fc1		       42		      .byte.b	%01000010
     90  8fc2		       42		      .byte.b	%01000010
     91  8fc3		       7e		      .byte.b	%01111110
     92  8fc4
     93  8fc4					      ifnconst	DPC_kernel_options
     94  8fc4
     95  8fc4		       00		      .byte.b	%00000000
     96  8fc5		       00		      .byte.b	%00000000
     97  8fc6		       00		      .byte.b	%00000000
     98  8fc7		       00		      .byte.b	%00000000
     99  8fc8		       00		      .byte.b	%00000000
    100  8fc9		       00		      .byte.b	%00000000
    101  8fca		       00		      .byte.b	%00000000
    102  8fcb		       00		      .byte.b	%00000000
    103  8fcc
    104  8fcc					      endif
------- FILE spacetaxi.bas.asm
  11871  8fcc					      endif
  11872  8fcc				  -	      if	font == whimsey
  11873  8fcc				  -	      include	"score_graphics.asm.whimsey"
  11874  8fcc					      endif
  11875  8fcc				  -	      if	font == tiny
  11876  8fcc				  -	      include	"score_graphics.asm.tiny"
  11877  8fcc					      endif
  11878  8fcc				  -	      if	font == hex
  11879  8fcc				  -	      include	"score_graphics.asm.hex"
  11880  8fcc					      endif
  11881  8fcc				  -	      else		; default font
  11882  8fcc				  -
  11883  8fcc				  -	      .byte	%00111100
  11884  8fcc				  -	      .byte	%01100110
  11885  8fcc				  -	      .byte	%01100110
  11886  8fcc				  -	      .byte	%01100110
  11887  8fcc				  -	      .byte	%01100110
  11888  8fcc				  -	      .byte	%01100110
  11889  8fcc				  -	      .byte	%01100110
  11890  8fcc				  -	      .byte	%00111100
  11891  8fcc				  -
  11892  8fcc				  -	      .byte	%01111110
  11893  8fcc				  -	      .byte	%00011000
  11894  8fcc				  -	      .byte	%00011000
  11895  8fcc				  -	      .byte	%00011000
  11896  8fcc				  -	      .byte	%00011000
  11897  8fcc				  -	      .byte	%00111000
  11898  8fcc				  -	      .byte	%00011000
  11899  8fcc				  -	      .byte	%00001000
  11900  8fcc				  -
  11901  8fcc				  -	      .byte	%01111110
  11902  8fcc				  -	      .byte	%01100000
  11903  8fcc				  -	      .byte	%01100000
  11904  8fcc				  -	      .byte	%00111100
  11905  8fcc				  -	      .byte	%00000110
  11906  8fcc				  -	      .byte	%00000110
  11907  8fcc				  -	      .byte	%01000110
  11908  8fcc				  -	      .byte	%00111100
  11909  8fcc				  -
  11910  8fcc				  -	      .byte	%00111100
  11911  8fcc				  -	      .byte	%01000110
  11912  8fcc				  -	      .byte	%00000110
  11913  8fcc				  -	      .byte	%00000110
  11914  8fcc				  -	      .byte	%00011100
  11915  8fcc				  -	      .byte	%00000110
  11916  8fcc				  -	      .byte	%01000110
  11917  8fcc				  -	      .byte	%00111100
  11918  8fcc				  -
  11919  8fcc				  -	      .byte	%00001100
  11920  8fcc				  -	      .byte	%00001100
  11921  8fcc				  -	      .byte	%01111110
  11922  8fcc				  -	      .byte	%01001100
  11923  8fcc				  -	      .byte	%01001100
  11924  8fcc				  -	      .byte	%00101100
  11925  8fcc				  -	      .byte	%00011100
  11926  8fcc				  -	      .byte	%00001100
  11927  8fcc				  -
  11928  8fcc				  -	      .byte	%00111100
  11929  8fcc				  -	      .byte	%01000110
  11930  8fcc				  -	      .byte	%00000110
  11931  8fcc				  -	      .byte	%00000110
  11932  8fcc				  -	      .byte	%00111100
  11933  8fcc				  -	      .byte	%01100000
  11934  8fcc				  -	      .byte	%01100000
  11935  8fcc				  -	      .byte	%01111110
  11936  8fcc				  -
  11937  8fcc				  -	      .byte	%00111100
  11938  8fcc				  -	      .byte	%01100110
  11939  8fcc				  -	      .byte	%01100110
  11940  8fcc				  -	      .byte	%01100110
  11941  8fcc				  -	      .byte	%01111100
  11942  8fcc				  -	      .byte	%01100000
  11943  8fcc				  -	      .byte	%01100010
  11944  8fcc				  -	      .byte	%00111100
  11945  8fcc				  -
  11946  8fcc				  -	      .byte	%00110000
  11947  8fcc				  -	      .byte	%00110000
  11948  8fcc				  -	      .byte	%00110000
  11949  8fcc				  -	      .byte	%00011000
  11950  8fcc				  -	      .byte	%00001100
  11951  8fcc				  -	      .byte	%00000110
  11952  8fcc				  -	      .byte	%01000010
  11953  8fcc				  -	      .byte	%00111110
  11954  8fcc				  -
  11955  8fcc				  -	      .byte	%00111100
  11956  8fcc				  -	      .byte	%01100110
  11957  8fcc				  -	      .byte	%01100110
  11958  8fcc				  -	      .byte	%01100110
  11959  8fcc				  -	      .byte	%00111100
  11960  8fcc				  -	      .byte	%01100110
  11961  8fcc				  -	      .byte	%01100110
  11962  8fcc				  -	      .byte	%00111100
  11963  8fcc				  -
  11964  8fcc				  -	      .byte	%00111100
  11965  8fcc				  -	      .byte	%01000110
  11966  8fcc				  -	      .byte	%00000110
  11967  8fcc				  -	      .byte	%00111110
  11968  8fcc				  -	      .byte	%01100110
  11969  8fcc				  -	      .byte	%01100110
  11970  8fcc				  -	      .byte	%01100110
  11971  8fcc				  -	      .byte	%00111100
  11972  8fcc				  -
  11973  8fcc				  -	      ifnconst	DPC_kernel_options
  11974  8fcc				  -
  11975  8fcc				  -	      .byte	%00000000
  11976  8fcc				  -	      .byte	%00000000
  11977  8fcc				  -	      .byte	%00000000
  11978  8fcc				  -	      .byte	%00000000
  11979  8fcc				  -	      .byte	%00000000
  11980  8fcc				  -	      .byte	%00000000
  11981  8fcc				  -	      .byte	%00000000
  11982  8fcc				  -	      .byte	%00000000
  11983  8fcc				  -
  11984  8fcc				  -	      endif
  11985  8fcc				  -
  11986  8fcc					      endif
  11987  8fcc
  11988  8fcc				  -	      ifconst	ROM2k
  11989  8fcc				  -	      ORG	$F7FC
  11990  8fcc					      else
  11991  8fcc					      ifconst	bankswitch
  11992  8fcc				  -	      if	bankswitch == 8
  11993  8fcc				  -	      ORG	$2FF4-bscode_length
  11994  8fcc				  -	      RORG	$FFF4-bscode_length
  11995  8fcc					      endif
  11996  8fcc				  -	      if	bankswitch == 16
  11997  8fcc				  -	      ORG	$4FF4-bscode_length
  11998  8fcc				  -	      RORG	$FFF4-bscode_length
  11999  8fcc					      endif
  12000  8fcc					      if	bankswitch == 32
  12001  8fd4					      ORG	$8FF4-bscode_length
  12002  8fd4					      RORG	$FFF4-bscode_length
  12003  8fd4					      endif
  12004  8fd4				  -	      if	bankswitch == 64
  12005  8fd4				  -	      ORG	$10FE0-bscode_length
  12006  8fd4				  -	      RORG	$1FFE0-bscode_length
  12007  8fd4					      endif
  12008  8fd4				  -	      else
  12009  8fd4				  -	      ORG	$FFFC
  12010  8fd4					      endif
  12011  8fd4					      endif
  12012  8fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
  12013  8fd4
  12014  8fd4							; every bank has this stuff at the same place
  12015  8fd4							; this code can switch to/from any bank at any entry point
  12016  8fd4							; and can preserve register values
  12017  8fd4							; note: lines not starting with a space are not placed in all banks
  12018  8fd4							;
  12019  8fd4							; line below tells the compiler how long this is - do not remove
  12020  8fd4							;size=32
  12021  8fd4
  12022  8fd4				   begin_bscode
  12023  8fd4		       a2 ff		      ldx	#$ff
  12024  8fd6				  -	      ifconst	FASTFETCH	; using DPC+
  12025  8fd6				  -	      stx	FASTFETCH
  12026  8fd6					      endif
  12027  8fd6		       9a		      txs
  12028  8fd7				  -	      if	bankswitch == 64
  12029  8fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
  12030  8fd7					      else
  12031  8fd7		       a9 f2		      lda	#>(start-1)
  12032  8fd9					      endif
  12033  8fd9		       48		      pha
  12034  8fda		       a9 51		      lda	#<(start-1)
  12035  8fdc		       48		      pha
  12036  8fdd
  12037  8fdd				   BS_return
  12038  8fdd		       48		      pha
  12039  8fde		       8a		      txa
  12040  8fdf		       48		      pha
  12041  8fe0		       ba		      tsx
  12042  8fe1
  12043  8fe1					      if	bankswitch != 64
  12044  8fe1		       b5 04		      lda	4,x	; get high byte of return address
  12045  8fe3
  12046  8fe3		       2a		      rol
  12047  8fe4		       2a		      rol
  12048  8fe5		       2a		      rol
  12049  8fe6		       2a		      rol
  12050  8fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
  12051  8fe9		       aa		      tax
  12052  8fea		       e8		      inx
  12053  8feb				  -	      else
  12054  8feb				  -	      lda	4,x	; get high byte of return address
  12055  8feb				  -	      tay
  12056  8feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
  12057  8feb				  -	      sta	4,x
  12058  8feb				  -	      tya
  12059  8feb				  -	      lsr
  12060  8feb				  -	      lsr
  12061  8feb				  -	      lsr
  12062  8feb				  -	      lsr
  12063  8feb				  -	      tax
  12064  8feb				  -	      inx
  12065  8feb					      endif
  12066  8feb
  12067  8feb				   BS_jsr
  12068  8feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
  12069  8fee		       68		      pla
  12070  8fef		       aa		      tax
  12071  8ff0		       68		      pla
  12072  8ff1		       60		      rts
  12073  8ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
  12074  8ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
  12075  8ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
  12076  8ff2					      endif
  12077  8ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
  12078  8ff2
  12079  8ff2					      ifconst	bankswitch
  12080  8ff2				  -	      if	bankswitch == 8
  12081  8ff2				  -	      ORG	$2FFC
  12082  8ff2				  -	      RORG	$FFFC
  12083  8ff2					      endif
  12084  8ff2				  -	      if	bankswitch == 16
  12085  8ff2				  -	      ORG	$4FFC
  12086  8ff2				  -	      RORG	$FFFC
  12087  8ff2					      endif
  12088  8ff2					      if	bankswitch == 32
  12089  8ffc					      ORG	$8FFC
  12090  8ffc					      RORG	$FFFC
  12091  8ffc					      endif
  12092  8ffc				  -	      if	bankswitch == 64
  12093  8ffc				  -	      ORG	$10FF0
  12094  8ffc				  -	      RORG	$1FFF0
  12095  8ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
  12096  8ffc				  -	      ORG	$10FF8
  12097  8ffc				  -	      RORG	$1FFF8
  12098  8ffc				  -	      ifconst	superchip
  12099  8ffc				  -	      .byte	"E","F","S","C"
  12100  8ffc				  -	      else
  12101  8ffc				  -	      .byte	"E","F","E","F"
  12102  8ffc				  -	      endif
  12103  8ffc				  -	      ORG	$10FFC
  12104  8ffc				  -	      RORG	$1FFFC
  12105  8ffc					      endif
  12106  8ffc				  -	      else
  12107  8ffc				  -	      ifconst	ROM2k
  12108  8ffc				  -	      ORG	$F7FC
  12109  8ffc				  -	      else
  12110  8ffc				  -	      ORG	$FFFC
  12111  8ffc				  -	      endif
  12112  8ffc					      endif
  12113  8ffc		       52 f2		      .word.w	(start & $ffff)
  12114  8ffe		       52 f2		      .word.w	(start & $ffff)
